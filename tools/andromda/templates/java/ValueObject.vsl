// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by: ValueObject.vsl in openuss/tools/andromda/templates.
//
#if ($stringUtils.isNotBlank($class.packageName))
package $class.packageName;
#end

/**
$class.getDocumentation(" * ")
 */
public#if($class.abstract) abstract#end class $class.name
#if($class.generalization)
    extends $class.generalization.fullyQualifiedName
#end
#if ($serializable)
	implements  java.io.Serializable
#end
#if (!$class.interfaceAbstractions.empty)
    , $class.implementedInterfaceList
#end
{
#if ($serializable)
    /**
     * The serial version UID of this class. Needed for serialization.
     */
    private static final long serialVersionUID = ${class.serialVersionUID}L;

#end
#if ($class.requiredConstructorParameters.size() > 0 || $class.allRequiredConstructorParameters.size() > $class.requiredConstructorParameters.size())
    public ${class.name}()
    {
#if($class.generalization)
        super();
#end
#foreach ($property in $class.requiredConstructorParameters)
        this.${property.name} = ${property.type.javaNullString};
#end
    }

#end
##
##  constructor taking only required properties
##
#if ($class.allProperties.size() > $class.allRequiredConstructorParameters.size())
    public ${class.name}(## no newline
#set ($comma = "")
#foreach ($property in $class.allRequiredConstructorParameters)
${comma}${property.getterSetterTypeName} ${property.name}## no newline
#set ($comma = ", ")
#end
)
    {
#if($class.generalization)
        super(## no newline
#set ($comma = "")
#foreach ($property in $class.generalization.allRequiredConstructorParameters)
${comma}${property.name}## no newline
#set ($comma = ", ")
#end
);
#end
#foreach ($property in $class.requiredConstructorParameters)
        this.${property.name} = ${property.name};
#end
    }

#end
    public ${class.name}(## no newline
#set ($comma = "")
#foreach ($property in $class.allProperties)
${comma}${property.getterSetterTypeName} ${property.name}## no newline
#set ($comma = ", ")
#end
)
    {
#if($class.generalization)
        super(## no newline
#set ($comma = "")
#foreach ($property in $class.generalization.allProperties)
${comma}${property.name}## no newline
#set ($comma = ", ")
#end
);
#end
#foreach ($property in $class.properties)
        this.${property.name} = ${property.name};
#end
    }

    /**
     * Copies constructor from other ${class.name}
     *
     * @param otherBean, cannot be <code>null</code>
     * @throws java.lang.NullPointerException if the argument is <code>null</code>
     */
    public ${class.name}(${class.name} otherBean)
    {
        this(## no newline
#set ($comma = "")
#foreach ($property in $class.allProperties)
${comma}otherBean.${property.getterName}()## no newline
#set ($comma = ", ")
#end
);
    }

    /**
     * Copies all properties from the argument value object into this value object.
     */
    public void copy(${class.name} otherBean)
    {
#foreach ($property in $class.allProperties)
        this.${property.setterName}(otherBean.${property.getterName}());
#end
    }

#foreach ($attribute in $class.attributes)
    private $attribute.getterSetterTypeName $attribute.name#if ($attribute.defaultValuePresent) = $attribute.defaultValue#end;

    /**
$attribute.getDocumentation("     * ")
     */
    public $attribute.getterSetterTypeName ${attribute.getterName}()
    {
        return this.${attribute.name};
    }

## - always have as public, having read-only causes too many issues when attempting to 
##   use in other cartridges
    public void ${attribute.setterName}($attribute.getterSetterTypeName $attribute.name)
    {
        this.${attribute.name} = $attribute.name;
    }

#end
## Generate the relation methods.
#foreach ($associationEnd in $class.associationEnds)
#set ($target = $associationEnd.otherEnd)
#if ($target.navigable)
    private $target.getterSetterTypeName $target.name;

    /**
     * Get the $target.name
$target.getDocumentation("     * ")
     */
    public $target.getterSetterTypeName ${target.getterName}()
    {
        return this.${target.name};
    }

## - always have as public, having read-only causes too many issues when attempting to 
##   use in other cartridges
    /**
     * Sets the $target.name
     */
    public void ${target.setterName}($target.getterSetterTypeName $target.name)
    {
        this.${target.name} = ${target.name};
    }

#end
#end

## - adding equals method if an attribute with name id exists 

#foreach($attribute in $class.attributes)		
#if($stringUtils.equalsIgnoreCase($attribute.name, "id"))

#set ($identifiers = $class.getIdentifiers(false))
    /**
#if ($identifiers.empty)
     * This entity does not have any identifiers
#if ($class.generalization)
     * but since it extends the <code>$class.generalization.fullyQualifiedName</code> class
     * it will simply delegate the call up there.
     *
     * @see $class.generalization.fullyQualifiedName#equals(Object)
#else
     * and is not extending any other entity,
     * so this method will only return <code>true</code> if the argument reference and <code>this</code>
     * refer to the same object.
#end
#else
#if ($class.generalization)
     * Returns <code>true</code> if the argument is an $class.name instance and all identifiers for this entity
     * equal the identifiers of the argument entity. The <code>equals</code> method of the parent entity
     * will also need to return <code>true</code>. Returns <code>false</code> otherwise.
     *
     * @see $class.generalization.fullyQualifiedEntityName#equals(Object)
#else
     * Returns <code>true</code> if the argument is an $class.name instance and all identifiers for this object
     * equal the identifiers of the argument object. Returns <code>false</code> otherwise.
#end
#end
     */
    public boolean equals(Object object)
    {
        if (this == object)
        {
            return true;
        }
        if (!(object instanceof ${class.name}))
        {
            return false;
        }
        final ${class.name} that = (${class.name})object;
        if (this.id == null || that.getId() == null || !this.id.equals(that.getId()))
        {
            return false;
        }

        return true;
    }

    /**
#if ($class.generalization)
     * Returns a hash code based on this entity's identifiers and the hash code of the parent entity.
     *
     * @see $class.generalization.fullyQualifiedName#hashCode()
#else
     * Returns a hash code based on this entity's identifiers.
#end
     */
    public int hashCode()
    {
        int hashCode = 0;
        hashCode = 29 * hashCode + (id == null ? 0 : id.hashCode());

        return hashCode;
    }
#end
#end

}