package org.openuss.security.acegi.shibboleth;

import javax.naming.NamingException;

import org.acegisecurity.AccountExpiredException;
import org.acegisecurity.Authentication;
import org.acegisecurity.AuthenticationException;
import org.acegisecurity.AuthenticationServiceException;
import org.acegisecurity.BadCredentialsException;
import org.acegisecurity.DisabledException;
import org.acegisecurity.LockedException;
import org.acegisecurity.adapters.PrincipalAcegiUserToken;
import org.acegisecurity.providers.ProviderNotFoundException;
import org.acegisecurity.providers.UsernamePasswordAuthenticationToken;
import org.acegisecurity.providers.dao.AbstractUserDetailsAuthenticationProvider;
import org.acegisecurity.userdetails.UserDetails;
import org.acegisecurity.userdetails.UserDetailsService;
import org.acegisecurity.userdetails.UsernameNotFoundException;
import org.openuss.framework.web.acegi.shibboleth.ShibbolethUserDetails;
import org.openuss.framework.web.acegi.shibboleth.ShibbolethUserDetailsImpl;
import org.openuss.security.SecurityDomainUtility;
import org.springframework.dao.DataAccessException;
import org.springframework.util.Assert;

/**
 * @author Standard
 *
 */
public class ShibbolethAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider {

	//~ Instance fields ================================================================================================

    /**
     * Our user details service (which does the real work of checking the user against a back-end user store).
     */
    protected UserDetailsService userDetailsService;
    /**
     * Indicates, which filter has generated the authentication request. 
     * Only PrincipalAcegiUserToken with proper key will be processed.
     * Assure setting the key according to the key property of the corresponding <code>ShibbolethAuthenticationProcessingFilter</code>.
     */
    protected String key;
    
	/**
	 * Enables migration, i. e. either automatic migration, if a user can be found, or manual migration by redirecting the user within an extended <code>ExceptionTranslationFilter</code> to a specific migration page. 
	 * Defaults to <code>false</code>.
	 */
	protected boolean migrationEnabled = false;
	/**
	 * Possibly useful for automatic migration of disabled or not yet enabled users, e. g. if user has registered, but not yet verified his email address.
	 * Defaults to <code>false</code>.
	 */
	protected boolean ignoreDisabledException = false;
	
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
	    Assert.isTrue(supports(authentication.getClass()), messages.getMessage("ShibbolethAuthenticationProvider.onlySupports",
	            "Only PrincipalAcegiUserToken is supported"));
	    if (!(((PrincipalAcegiUserToken)authentication).getKeyHash() == getKey().hashCode())) {
	    	throw new BadCredentialsException("An authentication was presented, that was not generated by the corresponding shibboleth filter and is thus not supported.");
	    }
	    
	    // Determine username
	    String username = generateUsernameFromAuthentication(authentication);
	    if (username == null) {
	    	username = "NONE_PROVIDED";
	    }
	
	    boolean cacheWasUsed = true;
	    UserDetails user = getUserCache().getUserFromCache(username);
	
	    if (user == null) {
	        cacheWasUsed = false;
	
	        try {
	            user = retrieveUser(username, (PrincipalAcegiUserToken) authentication);
	        } catch (UsernameNotFoundException notFound) {
	            if (isHideUserNotFoundExceptions()) {
	                throw new BadCredentialsException(messages.getMessage(
	                        "AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));
	            }
	            if (isMigrationEnabled()) {
	            	// Return authentication request, so that new user or user, that cannot be migrated automatically, 
	            	// can be redirected to a MigrationEntryPoint within an extended ExceptionTranslationFilter 
	            	return authentication;
	            }	            
	            else {
	                throw notFound;
	            }
	        }
	    }
	
	    // User details found
	    try {
	        additionalAuthenticationChecks(user, (PrincipalAcegiUserToken) authentication);
	    } catch (AuthenticationException exception) {
	        if (cacheWasUsed) {
	            // There was a problem, so try again after checking
	            // we're using latest data (ie not from the cache)
	            cacheWasUsed = false;
	            user = retrieveUser(username, (PrincipalAcegiUserToken) authentication);
	            additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);
	        } else {
	            throw exception;
	        }
	    }
	
	    getPostAuthenticationChecks().check(user);
	    
	    
	    // Automatic migration
	    if (isMigrationEnabled() && !isAlreadyMigrated(user, authentication)) {
	    	// do migration
	    	
	    	// Force cache update
	    	cacheWasUsed = false;
	    }
	
	    if (!cacheWasUsed) {
	        getUserCache().putUserInCache(user);
	    }
	
	    Object principalToReturn = user;
	
	    if (isForcePrincipalAsString()) {
	        principalToReturn = user.getUsername();
	    }
	
	    return createSuccessAuthentication(principalToReturn, authentication, user);
	}

	
	
	protected void doAfterPropertiesSet() throws Exception {
		Assert.notNull(this.userDetailsService, "A UserDetailsService must be set");
		Assert.hasLength(key, "A key must be set");
	}
	
	protected String generateUsernameFromAuthentication(Authentication authentication) {
		String domainName = "";
		String username = "";
		try {
			 domainName = (String)((ShibbolethUserDetails) authentication.getDetails()).getAttributes().get(ShibbolethUserDetailsImpl.AUTHENTICATIONDOMAINNAME_KEY).get();
			 username = (String)((ShibbolethUserDetails) authentication.getDetails()).getAttributes().get(ShibbolethUserDetailsImpl.USERNAME_KEY).get();
		} catch (NamingException e) {
			throw new IllegalArgumentException(e.getMessage(),e);
		}
		return SecurityDomainUtility.toUsername(domainName, username);
	}
	
	@Override
	public boolean supports(Class authentication) {
		return (PrincipalAcegiUserToken.class.isAssignableFrom(authentication));
	}
	
    protected final UserDetails retrieveUser(final String username, final PrincipalAcegiUserToken authentication) throws AuthenticationException {

        UserDetails loadedUser;

        try {
			String userEmailAddress = (String)((ShibbolethUserDetails) authentication.getDetails()).getAttributes().get(ShibbolethUserDetailsImpl.EMAIL_KEY).get();
            // Due to insufficient interface declaration, we had to extend our UserDetailsService implementation, so that it can also load a user by email address.
			// May the Acegi developers extend the interface by a loadUserByEmail or a similar method.
			loadedUser = this.getUserDetailsService().loadUserByUsername(userEmailAddress);
        } catch (DataAccessException repositoryProblem) {
            throw new AuthenticationServiceException(repositoryProblem.getMessage(), repositoryProblem);
        } catch (NamingException e) {
        	throw new IllegalArgumentException(e.getMessage(),e);
        }

        if (loadedUser == null) {
            throw new AuthenticationServiceException("UserDetailsService returned null, which is an interface contract violation");
        }

        return loadedUser;
    }
    
    
    /**
     * Check user migration status using user details and authentication request.
     * @param user
     * @param authentication
     * @return migration status
     */
    public boolean isAlreadyMigrated(UserDetails user, Authentication authentication) {
    	return SecurityDomainUtility.containsDomain(user.getUsername());
    }
	
	public boolean isMigrationEnabled() {
		return migrationEnabled;
	}

	public void setMigrationEnabled(boolean migrationEnabled) {
		this.migrationEnabled = migrationEnabled;
	}

	protected void additionalAuthenticationChecks(UserDetails user, PrincipalAcegiUserToken authentication) throws AuthenticationException {
		// No password checking necessary, since this was done by the shibboleth identity provider, already.
		if (!user.isEnabled() && !isIgnoreDisabledException()) {
			throw new DisabledException(messages.getMessage("AbstractUserDetailsAuthenticationProvider.disabled",
			"User is disabled"), user);
		}

		if (!user.isAccountNonLocked()) {
            throw new LockedException(messages.getMessage("AbstractUserDetailsAuthenticationProvider.locked",
                    "User account is locked"), user);
        }

        if (!user.isAccountNonExpired()) {
            throw new AccountExpiredException(messages.getMessage("AbstractUserDetailsAuthenticationProvider.expired",
                    "User account has expired"), user);
        }
	}

	@Override
	protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {
		// This method must be implemented, due to inheritance, but is never used, since we use a PrincipalAcegiUserToken.
	}

	@Override
	protected UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {
		// This method must be implemented, due to inheritance, but is never used, since we use a PrincipalAcegiUserToken.
		return null;
	}

	public UserDetailsService getUserDetailsService() {
		return userDetailsService;
	}

	public void setUserDetailsService(UserDetailsService userDetailsService) {
		this.userDetailsService = userDetailsService;
	}

	public boolean isIgnoreDisabledException() {
		return ignoreDisabledException;
	}

	public void setIgnoreDisabledException(boolean ignoreDisabledException) {
		this.ignoreDisabledException = ignoreDisabledException;
	}



	public String getKey() {
		return key;
	}



	public void setKey(String key) {
		this.key = key;
	}

}
