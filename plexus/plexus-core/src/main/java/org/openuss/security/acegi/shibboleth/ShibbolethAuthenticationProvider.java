package org.openuss.security.acegi.shibboleth;

import javax.naming.NamingException;

import org.acegisecurity.AccountExpiredException;
import org.acegisecurity.Authentication;
import org.acegisecurity.AuthenticationException;
import org.acegisecurity.AuthenticationServiceException;
import org.acegisecurity.BadCredentialsException;
import org.acegisecurity.DisabledException;
import org.acegisecurity.LockedException;
import org.acegisecurity.adapters.PrincipalAcegiUserToken;
import org.acegisecurity.providers.UsernamePasswordAuthenticationToken;
import org.acegisecurity.providers.dao.AbstractUserDetailsAuthenticationProvider;
import org.acegisecurity.userdetails.UserDetails;
import org.acegisecurity.userdetails.UserDetailsService;
import org.acegisecurity.userdetails.UsernameNotFoundException;
import org.openuss.framework.web.acegi.shibboleth.ShibbolethUserDetails;
import org.openuss.framework.web.acegi.shibboleth.ShibbolethUserDetailsImpl;
import org.openuss.security.SecurityDomainUtility;
import org.springframework.dao.DataAccessException;
import org.springframework.util.Assert;

/**
 * @author Standard
 *
 */
public abstract class ShibbolethAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider {

	//~ Instance fields ================================================================================================

    /**
     * Our user details service (which does the real work of checking the user against a back-end user store).
     */
    protected UserDetailsService userDetailsService;
    /**
     * Indicates, which filter has generated the authentication request. 
     * Only PrincipalAcegiUserToken with proper key will be processed.
     * Assure setting the key according to the key property of the corresponding <code>ShibbolethAuthenticationProcessingFilter</code>.
     */
    protected String key;
    
	/**
	 * Enables migration, i. e. either automatic migration, if a user can be found, or manual migration by redirecting the user within an extended <code>ExceptionTranslationFilter</code> to a specific migration page. 
	 * Defaults to <code>false</code>.
	 */
	protected boolean migrationEnabled = false;
	
	/**
	 * Enables reconciliation, i. e. application specific updating of locally stored user details with data received from shibboleth identity provider.
	 * Defaults to <code>false</code>.
	 */
	protected boolean reconciliationEnabled = false;

	
	/**
	 * Possibly useful for automatic migration of disabled or not yet enabled users, e. g. if user has registered, but not yet verified his email address.
	 * Defaults to <code>false</code>.
	 */
	protected boolean ignoreDisabledException = false;
	
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
	    Assert.isTrue(supports(authentication.getClass()), messages.getMessage("ShibbolethAuthenticationProvider.onlySupports",
	            "Only PrincipalAcegiUserToken is supported"));
	    if (!(((PrincipalAcegiUserToken)authentication).getKeyHash() == getKey().hashCode())) {
	    	throw new BadCredentialsException("An authentication was presented, that was not generated by the corresponding shibboleth filter and is thus not supported.");
	    }
	    
	    // Determine username
	    String username = generateUsernameFromAuthentication(authentication);
	    if (username == null) {
	    	username = "NONE_PROVIDED";
	    }
	
	    boolean cacheWasUsed = true;
	    UserDetails user = getUserCache().getUserFromCache(username);
	
	    if (user == null) {
	        cacheWasUsed = false;
	
	        try {
	            user = retrieveUser(username, (PrincipalAcegiUserToken) authentication);
	        } catch (UsernameNotFoundException notFound) {
	            if (isHideUserNotFoundExceptions()) {
	                throw new BadCredentialsException(messages.getMessage(
	                        "AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));
	            }
	            if (isMigrationEnabled()) {
	            	// Return authentication request, so that new user or user, that cannot be migrated automatically, 
	            	// can be redirected to a MigrationEntryPoint within an extended ExceptionTranslationFilter 
	            	return authentication;
	            }	            
	            else {
	                throw notFound;
	            }
	        }
	    }
	
	    // User details found
	    try {
	        additionalAuthenticationChecks(user, (PrincipalAcegiUserToken) authentication);
	    } catch (AuthenticationException exception) {
	        if (cacheWasUsed) {
	            // There was a problem, so try again after checking
	            // we're using latest data (ie not from the cache)
	            cacheWasUsed = false;
	            user = retrieveUser(username, (PrincipalAcegiUserToken) authentication);
	            additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);
	        } else {
	            throw exception;
	        }
	    }
	
	    getPostAuthenticationChecks().check(user);
	    
	    
	    // Automatic migration
	    if (isMigrationEnabled() && !isAlreadyMigrated(user, authentication)) {
	    	if (cacheWasUsed) {
	    		// Reload user to get latest data (i. e. not from cache)
	    		user = retrieveUser(username, (PrincipalAcegiUserToken) authentication);
	    	}
	    	// Cache could have been out-dated regarding the need for migration.
	    	// Possibly user has been migrated otherwise, meanwhile.
	    	if (!isAlreadyMigrated(user, authentication)) {
		    	migrate(user, authentication);
		    	// Reload user
		    	user = retrieveUser(username, (PrincipalAcegiUserToken) authentication);
		    	// Force cache update
		    	cacheWasUsed = false;
	    	}
	    }
	    else if (!cacheWasUsed && isReconciliationEnabled()) {
	    	 	// Only do reconciliation of centrally administered user details and locally saved ones, 
	    		// if local user details came from user details service, to preserve user details being 
	    		// updated with out-dated data from cache.
	    		boolean userWasUpdated = false;
	    		userWasUpdated = reconcile(user, authentication);
		    	if (userWasUpdated) {
		    		// Reload user
			    	user = retrieveUser(username, (PrincipalAcegiUserToken) authentication);
		    	}
	    }
	
	    if (!cacheWasUsed) {
	        getUserCache().putUserInCache(user);
	    }
	
	    Object principalToReturn = user;
	
	    if (isForcePrincipalAsString()) {
	        principalToReturn = user.getUsername();
	    }
	
	    return createSuccessAuthentication(principalToReturn, authentication, user);
	}

	
	
	protected void doAfterPropertiesSet() throws Exception {
		Assert.notNull(this.userDetailsService, "A UserDetailsService must be set");
		Assert.hasLength(key, "A key must be set");
	}
	
	
	/**
	 * Enables application specific derivation of usernames.
	 * @param authentication
	 * @return
	 */
	protected abstract String generateUsernameFromAuthentication(Authentication authentication);
	
	@Override
	public boolean supports(Class authentication) {
		return (PrincipalAcegiUserToken.class.isAssignableFrom(authentication));
	}
	
    protected UserDetails retrieveUser(String username, PrincipalAcegiUserToken authentication) throws AuthenticationException {

        UserDetails loadedUser;

        try {
			loadedUser = this.getUserDetailsService().loadUserByUsername(username);
        } catch (DataAccessException repositoryProblem) {
            throw new AuthenticationServiceException(repositoryProblem.getMessage(), repositoryProblem);
        }

        if (loadedUser == null) {
            throw new AuthenticationServiceException("UserDetailsService returned null, which is an interface contract violation");
        }

        return loadedUser;
    }
    
    /**
     * Application specific migration for users, e. g. set authentication mechanism for user to shibboleth.
     * @param user
     * @param authentication
     */
    protected void migrate(UserDetails user, Authentication authentication) {}
    
    /**
     * Application specific reconciliation of user details, e. g. updating of locally stored user details with 
     * data received by the corresponding shibboleth filter.
     * @param user
     * @param authentication
     * @return reconciliation status: <code>true</code>, if locally stored user details had to be updated.
     */
    protected abstract boolean reconcile(UserDetails user, Authentication authentication);

    /**
     * Check user migration status.
     * @param user
     * @param authentication
     * @return migration status
     */
    protected abstract boolean isAlreadyMigrated(UserDetails user, Authentication authentication);
	
	public boolean isMigrationEnabled() {
		return migrationEnabled;
	}

	public void setMigrationEnabled(boolean migrationEnabled) {
		this.migrationEnabled = migrationEnabled;
	}

	protected void additionalAuthenticationChecks(UserDetails user, PrincipalAcegiUserToken authentication) throws AuthenticationException {
		// No password checking necessary, since this was done by the shibboleth identity provider, already.
		if (!user.isEnabled() && !isIgnoreDisabledException()) {
			throw new DisabledException(messages.getMessage("AbstractUserDetailsAuthenticationProvider.disabled",
			"User is disabled"), user);
		}

		if (!user.isAccountNonLocked()) {
            throw new LockedException(messages.getMessage("AbstractUserDetailsAuthenticationProvider.locked",
                    "User account is locked"), user);
        }

        if (!user.isAccountNonExpired()) {
            throw new AccountExpiredException(messages.getMessage("AbstractUserDetailsAuthenticationProvider.expired",
                    "User account has expired"), user);
        }
	}

	@Override
	protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {
		// This method must be implemented, due to inheritance, but is never used, since we use a PrincipalAcegiUserToken.
	}

	@Override
	protected UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {
		// This method must be implemented, due to inheritance, but is never used, since we use a PrincipalAcegiUserToken.
		return null;
	}

	public UserDetailsService getUserDetailsService() {
		return userDetailsService;
	}

	public void setUserDetailsService(UserDetailsService userDetailsService) {
		this.userDetailsService = userDetailsService;
	}

	public boolean isIgnoreDisabledException() {
		return ignoreDisabledException;
	}

	public void setIgnoreDisabledException(boolean ignoreDisabledException) {
		this.ignoreDisabledException = ignoreDisabledException;
	}

	public String getKey() {
		return key;
	}

	public void setKey(String key) {
		this.key = key;
	}

	public boolean isReconciliationEnabled() {
		return reconciliationEnabled;
	}

	public void setReconciliationEnabled(boolean reconciliationEnabled) {
		this.reconciliationEnabled = reconciliationEnabled;
	}
}