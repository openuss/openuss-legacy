/* Generated by FreestyleLearninngGroup */

package freestyleLearningGroup.independent.gui;

import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.LayoutManager;

public class FLGSingleLayout implements LayoutManager {
    public static final int CENTER = 0;
    public static final int TOP = 1;
    public static final int BOTTOM = 2;
    public static final int LEFT = 3;
    public static final int RIGHT = 4;
    public static final int AS_PREFERRED = 0;
    public static final int SHRINK_AS_NEEDED = 1;
    public static final int FIT_TO_PARENT = 2;
    private int horizontalFit = SHRINK_AS_NEEDED;
    private int verticalFit = SHRINK_AS_NEEDED;
    private boolean proportionalShrink = false;
    private int horizontalAlignment = CENTER;
    private int verticalAlignment = CENTER;

    public FLGSingleLayout() {
    }

    public FLGSingleLayout(int horizontalAlignment, int verticalAlignment) {
        this.horizontalAlignment = horizontalAlignment;
        this.verticalAlignment = verticalAlignment;
    }

    public FLGSingleLayout(int horizontalAlignment, int verticalAlignment, int horizontalFit, int verticalFit,
        boolean proportionalShrink) {
            this.horizontalAlignment = horizontalAlignment;
            this.verticalAlignment = verticalAlignment;
            this.horizontalFit = horizontalFit;
            this.verticalFit = verticalFit;
            this.proportionalShrink = proportionalShrink;
    }

    public void layoutContainer(Container target) {
        Insets insets = target.getInsets();
        Dimension target_size = target.getSize();
        Component child;
        int nChildren = target.getComponentCount();
        if (nChildren > 0) {
            child = target.getComponent(0);
            int maxWidth = target_size.width - insets.left - insets.right;
            int maxHeight = target_size.height - insets.top - insets.bottom;
            int childWidth = child.getPreferredSize().width;
            int childHeight = child.getPreferredSize().height;
            if (childWidth > maxWidth || childHeight > maxHeight) {
                double scaleHeight = 1;
                double scaleWidth = 1;
                if (horizontalFit == SHRINK_AS_NEEDED)
                    scaleWidth = Math.min(1.0, (double)maxWidth / (double)childWidth);
                if (verticalFit == SHRINK_AS_NEEDED)
                    scaleHeight = Math.min(1.0, (double)maxHeight / (double)childHeight);
                if (proportionalShrink) {
                    scaleHeight = Math.min(scaleHeight, scaleWidth);
                    scaleWidth = scaleHeight;
                }
                childWidth = (int)(childWidth * scaleWidth);
                childHeight = (int)(childHeight * scaleHeight);
            }
            if (horizontalFit == FIT_TO_PARENT) childWidth = maxWidth;
            if (verticalFit == FIT_TO_PARENT) childHeight = maxHeight;
            // und plazieren
            int x = insets.left;
            int y = insets.top;
            if (horizontalAlignment == CENTER) x += (maxWidth - childWidth) / 2;
            if (horizontalAlignment == RIGHT) x += maxWidth - childWidth;
            if (verticalAlignment == CENTER) y += (maxHeight - childHeight) / 2;
            if (verticalAlignment == BOTTOM) y += maxHeight - childHeight;
            child.setBounds(x, y, childWidth, childHeight);
        }
    }

    /**
     * Berechnet die bevorzugte r&ouml;sse f&uuml;r den spezifizierten <code>Container</code>.
     * @param	target	der <code>Container</code>, der diesen Layout Manager benutzt.
     * @return				die bevorzugte Gr&ouml;sse.
     */
    public Dimension preferredLayoutSize(Container target) {
        Dimension d = layoutSize(target, 1);
        return d;
    }

    /**
     * Der <code>Container</code> ruft diese Methode auf, um herauszufinden, wie gross das Layout mindestens sein muss.
     * @param	target	der <code>Container</code>, der diesen Layout Manager benutzt.
     * @return				die minimale Gr&ouml;sse dieses Layouts.
     */
    public Dimension minimumLayoutSize(Container target) {
        Dimension d = layoutSize(target, 2);
        return d;
    }

    /**
     * Der <code>Container</code> ruft diese Methode auf, um herauszufinden, wie gross das Layout hoechstens werden darf.
     * @param	target	der <code>Container</code>, der diesen Layout Manager benutzt.
     * @return				die maximale Gr&ouml;sse dieses Layouts.
     */
    public Dimension maximumLayoutSize(Container target) {
        Dimension d = layoutSize(target, 3);
        return d;
    }

    private Dimension layoutSize(Container target, int sizetype) {
        Insets insets = target.getInsets();
        Dimension prefSize = new Dimension(insets.left + insets.right, insets.top + insets.bottom);
        int nChildren = target.getComponentCount();
        if (nChildren > 0) {
            if (target.getComponent(0).isVisible()) {
                Dimension kidPrefSize;
                if (sizetype == 1) kidPrefSize = target.getComponent(0).getPreferredSize();
                else if (sizetype == 2) kidPrefSize = target.getComponent(0).getMinimumSize();
                else
                    kidPrefSize = target.getComponent(0).getMaximumSize();
                prefSize.width += kidPrefSize.width;
                prefSize.height += kidPrefSize.height;
            }
        }
        return prefSize;
    }

    /** Nicht vom Benutzer aufzurufen. Aufruf erfolgt automatisch intern. */
    public void addLayoutComponent(String constraint, Component comp) { }

    /** Nicht vom Benutzer aufzurufen. Aufruf erfolgt automatisch intern. */
    public void addLayoutComponent(Component comp, Object constraint) { }

    /** Nicht vom Benutzer aufzurufen. Aufruf erfolgt automatisch intern. */
    public void removeLayoutComponent(Component comp) { }

    /** Nicht vom Benutzer aufzurufen. Aufruf erfolgt automatisch intern. */
    public void invalidateLayout(Container target) { }

    /** Nicht vom Benutzer aufzurufen. Aufruf erfolgt automatisch intern. */
    public float getLayoutAlignmentX(Container target) { return 0.5f; }

    /** Nicht vom Benutzer aufzurufen. Aufruf erfolgt automatisch intern. */
    public float getLayoutAlignmentY(Container target) { return 0.5f; }
}
