/* Generated by Freestyle Learning Group */

package freestyleLearningGroup.independent.util;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.GradientPaint;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Stroke;
import java.awt.TexturePaint;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;

/**
 * Diese Klasse enth&auml;lt einige Konstanten und Methoden rund um das Thema Grafik und
 * insbesondere Linienarten und F&uuml;llarten, sprich: <code>Stroke</code>s und
 * <code>Texture</code>s.<p> Die in schwarz-wei&szlig; gehaltenen Linien- und
 * F&uuml;llarten k&ouml;nnen insbesondere benutzt werden, um bei der Implementierung des
 * <code>FLGBlackAndWhite</code>-Interfaces farbige Linien und F&uuml;llungen
 * zu ersetzen.<p> Damit die Ersetzung von Farben durch Texturen m&ouml;glichst
 * einheitlich erfolgt, kann an die Methode <code>getTextureForStandardColor</code> eine in der
 * Klasse <code>Color</code> spezifizierte Farbe &uuml;bergeben werden und es wird die hier
 * zugewiesene Textur zur&uuml;ckgeliefert.<p> Mit der Methode <code>isStandardColor</code> kann &uuml;berpr&uuml;ft werden,
 * ob eine Farbe einer Standardfarbe aus der Klasse <code>Color</code> entspricht. Die Methode
 * <code>getStandardColor</code> liefert eine Standardfarbe zu einem angegebenen Index.<p> Soll
 * auf eine gef&uuml;llte Fl&auml;che geschrieben werden, kann
 * durch die Methoden <code>getTextColorFor(int index)</code> respektive <code>getTextColorFor(Color color)</code> eine Farbe
 * bestimmt werden, die auf der F&uuml;llfarbe gut zu erkennen ist.<p> Zudem ist in dieser Klasse
 * die Methode <code>getGradient</code> definiert, die zu einer angegebenen Farbe einen
 * &quot;unauff&auml;lligen&quot; Farbverlauf erzeugt.<p> Last but not least, sind die beiden
 * Konstanten <code>standardOutlineColor</code> und <code>standardFillColor</code> definiert, die
 * benutzt werden k&ouml;nnen f&uuml;r Zeichenoperationen, bei denen nicht explizit andere Farben
 * zugewiesen sind.<p> <p> <b>Beispiel 1</b>: Zeigt die 13 definierten Textures.<p> Alle Texturen haben eine Gr&ouml;sse von 5
 * x 5 Pixeln und sie werden in einem <code>Graphics2D</code> Kontext gesetzt durch die Methode
 * <code>g2.setPaint(FLGTextures.textures[<i>i</i>]);</code>.<p> <p><pre>
 *		<img src="../../../../../images/Textures.gif" width="220" height="220">
 * </pre><p> <p> <b>Beispiel 2</b>: Zeigt die 10 definierten <code>Stroke</code>s und den
 * <code>DEFAULT</code> <code>Stroke</code>, der benutzt werden kann, wenn nach z.B.
 * <code>setStroke(FLGGraphics.getStroke(FLGGraphics.DOUBLE_DOTTED))</code>
 * wieder zur Standard-Linienart gewechselt werden soll.<p> Die <code>Stroke</code>s, k&ouml;nnen
 * bspw. <code>FLGFunction2D</code> und <code>FLGPolygon2D</code>
 * durch die Methode <code>setStroke</code> zugewiesen werden.<p> <p><pre>
 *		<img src="../../../../../images/Strokes.gif" width="200" height="260">
 * </pre><p> <b>Beispiel 3</b>: Zeigt wie in einem <code>FLGPieChart2D</code> Farbverl&auml;fe
 * benutzt werden, wenn dies durch die Methode <code>setPaintWithGradient(true)</code>
 * eingeschaltet wurde.<p> Generell sollten Farbverl&auml;ufe nur optional benutzt werden.<p> <p><pre>
 *	// Je nachdem ob der Wert eine Farbe hat und ob
 *	// ein Farbverlauf benutzt werden soll, wird hier die
 *	// Füllfarbe gesetzt.
 *	if (dataGroup.get(i).getColor() != null) {
 *		if (gradient)
 *		  g2.setPaint(FLGGraphics.getGradient(dataGroup.get(i).getColor(),
 *					center, getEndPoint((Arc2D)piece)));
 *		else
 *		  g2.setPaint(dataGroup.get(i).getColor());
 *	}
 *	else {
 *		if (gradient)
 *		  g2.setPaint(FLGGraphics.getGradient(standardFillColor,
 *					center, getEndPoint((Arc2D)piece)));
 *		else
 *		  g2.setPaint(standardFillColor);
 *	}
 *	g2.fill(piece);
 *
 *		<img src="../../../../../images/Gradient.gif" width="350" height="380">
 * </pre><p> In der Dokumentation zum <code>FLGPieChart</code> werden die Methoden dieser Klasse extensiv genutzt.
 * @see freestyleLearningGroup.independent.plotter.FLGPieChart2D
 * @see FLGBlackAndWhite
 */
public class FLGGraphics {
    //
    // Konstanten
    //
    //
    // Standard Füll- und Umrandungsfarbe
    //

    /** Standardfarbe f&uuml;r eine Umrandung. */
    public static Color standardOutlineColor = Color.black;

    /** Standardf&uuml;llfarbe. */
    public static Color standardFillColor = Color.blue;
    //
    // Die Strokes
    //

    /** Die Anzahl der verf&uuml;gbaren Strokes. */
    static public final int noStrokes = 10;

    /** Der Standard-<code>Stroke</code>. Entspricht der normalen Linie. */
    public static final Stroke STROKE_DEFAULT = new BasicStroke();

    /** Index f&uuml;r eine durchgezogene Linie. */
    public static final int STROKE_SOLID = 0;

    /** Index f&uuml;r eine gestrichelte Linie mit mittellangen Strichen. */
    public static final int STROKE_DASHED = 1;

    /** Index f&uuml;r eine gestrichelte Linie mit kurzen Strichen. */
    public static final int STROKE_DASHED_SHORT = 2;

    /** Index f&uuml;r eine gestrichelte Linie mit langen Strichen. */
    public static final int STROKE_DASHED_LONG = 3;

    /** Index f&uuml;r eine gepunktete Linie mit normalen Abst&auml;nden zwischen den Punkten. */
    public static final int STROKE_DOTTED = 4;

    /** Index f&uuml;r eine gepunktete Linie mit kurzen Abst&auml;nden zwischen den Punkten. */
    public static final int STROKE_DOTTED_NARROW = 5;

    /** Index f&uuml;r eine gepunktete Linie mit langen Abst&auml;nden zwischen den Punkten. */
    public static final int STROKE_DOTTED_WIDE = 6;

    /** Index f&uuml;r eine doppelt-gepunktete Linie. */
    public static final int STROKE_DOUBLE_DOTTED = 7;

    /** Index f&uuml;r eine Linie auf der sich Punkt und Strich abwechseln. */
    public static final int STROKE_DASH_DOTTED = 8;

    /** Index f&uuml;r eine Linie auf der sich doppelter Punkt und Strich abwechseln. */
    public static final int STROKE_DASH_DOUBLE_DOTTED = 9;
    // Die Definition der Linien.
    private static final float[] [] dashes = {
			null, // SOLID
			{10.0f, 5.0f}, // DASHED
			{5.0f, 4.0f}, // DASHED_SHORT
			{25.0f, 12.0f}, // DASHED_LONG
			{2.0f, 8.0f}, // DOTTED
			{2.0f, 3.0f}, // DOTTED_NARROW
			{2.0f, 15.0f}, // DOTTED_WIDE
			{2.0f, 3.0f, 2.0f, 10.0f}, // DOUBLE_DOTTED
			{10.0f, 3.0f, 2.0f, 3.0f}, // DASH_DOTTED
			{15.0f, 3.0f, 2.0f, 3.0f, 2.0f, 3.0f}, // DASH_DOUBLE_DOTTED
	};
    //
    // Die Textures
    //

    /** Die Anzahl der verf&uuml;gbaren Texturen. */
    static public final int noTextures = 13;

    /** Index der ersten Textur. */
    private static final int TEXTURE_FIRST = 20;

    /** Index f&uuml;r nach rechts schraffierte Textur. */
    public static final int TEXTURE_HATCH_RIGHT = TEXTURE_FIRST + 0;

    /** Index f&uuml;r leere Textur. */
    public static final int TEXTURE_PLAIN = TEXTURE_FIRST + 1;

    /** Index f&uuml;r nach links schraffierte Textur. */
    public static final int TEXTURE_HATCH_LEFT = TEXTURE_FIRST + 2;

    /** Index f&uuml;r nach rechts gestreift schraffierte Textur. */
    public static final int TEXTURE_HATCH_RIGHT_DASHED = TEXTURE_FIRST + 3;

    /** Index f&uuml;r nach links gestreift schraffierte Textur. */
    public static final int TEXTURE_HATCH_LEFT_DASHED = TEXTURE_FIRST + 4;

    /** Index f&uuml;r gepunktete Textur. */
    public static final int TEXTURE_DOTTED = TEXTURE_FIRST + 5;

    /** Index f&uuml;r horizontal gezickzackte Textur. */
    public static final int TEXTURE_ZIGZAG_HORIZONTAL = TEXTURE_FIRST + 6;

    /** Index f&uuml;r vertikal gezickzackte Textur. */
    public static final int TEXTURE_ZIGZAG_VERTICAL = TEXTURE_FIRST + 7;

    /** Index f&uuml;r Textur mit kleinen Quadraten. */
    public static final int TEXTURE_SQUARES = TEXTURE_FIRST + 8;

    /** Index f&uuml;r Textur mit kleinen Kreisen. */
    public static final int TEXTURE_CIRCLES = TEXTURE_FIRST + 9;

    /** Index f&uuml;r Textur mit vertikalen Linien. */
    public static final int TEXTURE_LINES_VERTICAL = TEXTURE_FIRST + 10;

    /** Index f&uuml;r Textur mit horizontalen Linien. */
    public static final int TEXTURE_LINES_HORIZONTAL = TEXTURE_FIRST + 11;

    /** Index f&uuml;r gitterartige Textur. */
    public static final int TEXTURE_HATCH_GRID = TEXTURE_FIRST + 12;

    /** Das Array mit den verf&uuml;gbaren Texturen. */
    static private TexturePaint[] textures;
    // Der Anker der Texturen.
    static private Rectangle anchor = new Rectangle(0, 0, 5, 5);

    //
    // Konstruktor
    //
    // Niemand soll diese Klasse instanziieren.
    private FLGGraphics() { }
    //
    // Methoden
    //

    /**
     * Liefert den <code>Stroke</code> zu dem spezifizierten Index. Es k&ouml;nen die oben
     * spezifizierten Konstanten &uuml;bergeben werden, um einen bestimmten <code>Stroke</code> zu
     * erhalten oder es kann &quot;irgendein&quot; Index &uuml;bergeben
     * werden um einen <code>Stroke</code> zu erhalten, der durch den Wert <code>index %
     * noStrokes</code> ausgew&auml;hlt wird.
     * @param index der Index der gew&uuml;nschten Linienart.
     * @return	den gew&uuml;nschten <code>Stroke</code>.
     */
    public static Stroke getStroke(int index) {
        if (index < 0) index = -index;
        if (index >= noStrokes) index = index % 13;
        if (index < noStrokes && index >= 0)
            return new BasicStroke(1.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dashes[index], 0.0f);
        else
            return STROKE_DEFAULT;
    }

    /**
     * Liefert die Textur zu dem spezifizierten Index. Es k&ouml;nen die oben spezifizierten
     * Konstanten &uuml;bergeben werden, um eine bestimmte Textur zu erhalten oder es kann
     * &quot;irgendein&quot; Index &uuml;bergeben werden um eine Textur zu
     * erhalten, die durch den Wert <code>index % noTextures</code> ausgew&auml;hlt wird.
     * @param index der Index der gew&uuml;nschten Textur.
     * @return	die gew&uuml;nschte Textur.
     */
    public static TexturePaint getTexture(int index) {
        if (index >= TEXTURE_FIRST) index -= TEXTURE_FIRST;
        if (index < 0) index = -index;
        if (index >= noTextures) index = index % 13;
        if (index < noTextures && index >= 0) return textures[index];
        else
            return textures[TEXTURE_PLAIN];
    }

    /**
     * Liefert einen &quot;unauff&auml;lligen&quot; Farbverlauf. Aus der spezifizierten Grundfarbe
     * und den angegebenen Start- und Endpunkten wird ein Farbverlauf erzeugt. Die spezifizierte
     * Farbe wird um einen halben Wert aufgehellt oder abdunkelt. Der erzeugte Farbverlauf wird vom Start- zum
     * Endpunkt immer leuchtender.
     * @param baseColor	die Grundfarbe aus dem der Farberverlauf erzeugt werden soll.
     * @param start	der Startpunkt des Farbverlaufs.
     * @param end 	der Endpunkt des Farbverlaufs.
     * @return	den gew&uuml;nschten <code>Stroke</code>.
     */
    public static GradientPaint getGradient(Color baseColor, Point2D start, Point2D end) {
        // die zweite Farbe des Farbverlaufs
        Color newColor;
        // die baseColor als hue - saturation - brightness - Werte
        float[] hsb = Color.RGBtoHSB(baseColor.getRed(), baseColor.getGreen(), baseColor.getBlue(), null);
        // wenn die baseColor eher dunkel ist wird die andere aufgehellt und umgekehrt
        // der Farbverlauf ist von innen nach aussen von dunkel nach hell
        if (hsb[2] >= 0.5) {
            newColor = Color.getHSBColor(hsb[0], hsb[1], hsb[2] - 0.5f);
            return new GradientPaint(start, newColor, end, baseColor);
        }
        else {
            newColor = Color.getHSBColor(hsb[0], hsb[1], hsb[2] + 0.5f);
            return new GradientPaint(start, baseColor, end, newColor);
        }
    }

    /**
     * Pr&uuml;ft ob die &uuml;bergebene Farbe eine in der Klasse <code>Color</code> definierte
     * Farbe ist. Ist dies der Fall, wird der Index dieser Farbe geliefert und zwar in der
     * Reihenfolge, in der die Farben in <code>Color</code> definiert sind (white=0 bis blue=12). Wurde keine Standardfarbe
     * &uuml;bergeben ist der R&uuml;ckgabewert -1.
     * @param standardColor die zu &uuml;berpr&uuml;fende Farbe.
     * @return	den Index der Standardfarbe oder <i>-1</i>, wenn es keine Standardfarbe ist.
     */
    public static int isStandardColor(Color standardColor) {
        if (standardColor.equals(Color.white)) return 0;
        if (standardColor.equals(Color.lightGray)) return 1;
        if (standardColor.equals(Color.gray)) return 2;
        if (standardColor.equals(Color.darkGray)) return 3;
        if (standardColor.equals(Color.black)) return 4;
        if (standardColor.equals(Color.red)) return 5;
        if (standardColor.equals(Color.pink)) return 6;
        if (standardColor.equals(Color.orange)) return 7;
        if (standardColor.equals(Color.yellow)) return 8;
        if (standardColor.equals(Color.green)) return 9;
        if (standardColor.equals(Color.magenta)) return 10;
        if (standardColor.equals(Color.cyan)) return 11;
        if (standardColor.equals(Color.blue)) return 12;
        return -1;
    }

    /**
     * Liefert zu dem &uuml;bergebenem Index eine Standardfarbe. Da in der Klasse <code>Color</code> nur 13 Farben definiert
     * sind, wiederholen sich die Farben bei einem Index gr&ouml;&szlig;er 12 (geliefert wird die
     * Farbe <code>index % 13</code>).<p> Diese Methode kann bspw. f&uuml;r <code>FLGData2D</code>
     * Objekte benutzt werden, f&uuml;r die keine Farbe spezifiziert wurde, indem die Position in
     * der das Objekt enthaltenen <code>FLGDataGroup2D</code> an diese Methode
     * &uuml;bergeben wird. Nat&uuml;rlich kann dabei nicht garantiert werden, da&szlig; nicht
     * eine Farbe geliefert wird, die auch einem anderen <code>FLGData2D</code> Objekt zugewiesen ist.
     * @param index	Index der zu liefernden Farbe.
     * @return	die dem Index zugewiesene Standardfarbe.
     */
    public static Color getStandardColor(int index) {
        switch (index % 13) {
            case 0:
                return Color.white;
            case 1:
                return Color.lightGray;
            case 2:
                return Color.gray;
            case 3:
                return Color.darkGray;
            case 4:
                return Color.black;
            case 5:
                return Color.red;
            case 6:
                return Color.pink;
            case 7:
                return Color.orange;
            case 8:
                return Color.yellow;
            case 9:
                return Color.green;
            case 10:
                return Color.magenta;
            case 11:
                return Color.cyan;
            case 12:
                return Color.blue;
            default:
                return Color.white;
        }
    }

    /**
     * &Uuml;bergeben wird ein Index analog zur Methode <code>getStandardColor</code>. Da durch
     * diesen Index die Farbe mit der ein Objekt gef&uuml;llt ist bestimmt werden kann, liefert
     * diese Methode eine Farbe zur&uuml;ck f&uuml;r Text, der wenn er auf dieser Farbe geschrieben wird, gut zu erkennen ist.
     * In Abh&auml;ngigkeit des Farbtons der durch den Index bestimmten Farbe wird entweder
     * schwarz oder wei&szlig; zur&uuml;ckgeliefert.
     * @param index	Index der Farbe, auf der geschrieben werden soll.
     * @return	schwarz oder weiß je nach Farbton der durch den Index spezifizierten Farbe.
     */
    public static Color getTextColorFor(int index) {
        Color fill = getStandardColor(index);
        return getTextColorFor(fill);
    }

    /**
     * Diese Methode liefert eine Farbe zur&uuml;ck f&uuml;r Text, der wenn er auf die
     * spezifizierte Farbe geschrieben wird, gut zu erkennen ist. In Abh&auml;ngigkeit des
     * Farbtons der &uuml;bergebenen Farbe wird entweder schwarz oder wei&szlig; zur&uuml;ckgeliefert.
     * @param color	die Farbe, auf der geschrieben werden soll.
     * @return	schwarz oder weiß je nach Farbton der spezifizierten Farbe.
     */
    public static Color getTextColorFor(Color color) {
        float[] hsb = Color.RGBtoHSB(color.getRed(), color.getGreen(), color.getBlue(), null);
        if (hsb[0] > 0.5 || hsb[1] < 0.5) return Color.white;
        else
            return Color.black;
    }

    /**
     * Liefert zu einer Standardfarbe, die in der Klasse <code>Color</code> definiert ist eine
     * Textur. Wird eine nicht-standard Farbe &uuml;bergeben wird eine &quot;leere&quot; Textur geliefert.
     * @param standardColor	eine in der Klasse <code>Color</code> definierte Farbe.
     * @return	die Textur zur spezifizierten Farbe.
     */
    public static TexturePaint getTextureForStandardColor(Color standardColor) {
        switch (isStandardColor(standardColor)) {
            case 4:
                return getTexture(TEXTURE_HATCH_LEFT);
            case 12:
                return getTexture(TEXTURE_HATCH_RIGHT);
            case 11:
                return getTexture(TEXTURE_ZIGZAG_HORIZONTAL);
            case 3:
                return getTexture(TEXTURE_LINES_VERTICAL);
            case 2:
                return getTexture(TEXTURE_HATCH_GRID);
            case 9:
                return getTexture(TEXTURE_LINES_HORIZONTAL);
            case 1:
                return getTexture(TEXTURE_DOTTED);
            case 10:
                return getTexture(TEXTURE_ZIGZAG_VERTICAL);
            case 7:
                return getTexture(TEXTURE_CIRCLES);
            case 6:
                return getTexture(TEXTURE_SQUARES);
            case 5:
                return getTexture(TEXTURE_HATCH_LEFT_DASHED);
            case 0:
                return getTexture(TEXTURE_PLAIN);
            case 8:
                return getTexture(TEXTURE_HATCH_RIGHT_DASHED);
            default:
                return getTexture(TEXTURE_PLAIN);
        }
    }

    //
    // Static Initializer:
    // Initialisierung der Texturen, wenn die Klasse das erste mal benutzt wird.
    //
    static {
        BufferedImage bi;
        Graphics2D big;
        textures = new TexturePaint[noTextures];
        int i = 0;
        bi = new BufferedImage(5, 5, BufferedImage.TYPE_INT_RGB);
        big = bi.createGraphics();
        big.setColor(Color.white);
        big.fillRect(0, 0, 5, 5);
        big.setColor(Color.black);
        big.drawLine(0, 2, 2, 0);
        big.drawLine(3, 4, 4, 3);
        textures[i++] = new TexturePaint(bi, anchor);
        bi = new BufferedImage(5, 5, BufferedImage.TYPE_INT_RGB);
        big = bi.createGraphics();
        big.setColor(Color.white);
        big.fillRect(0, 0, 5, 5);
        textures[i++] = new TexturePaint(bi, anchor);
        bi = new BufferedImage(5, 5, BufferedImage.TYPE_INT_RGB);
        big = bi.createGraphics();
        big.setColor(Color.white);
        big.fillRect(0, 0, 5, 5);
        big.setColor(Color.black);
        big.drawLine(0, 2, 2, 4);
        big.drawLine(3, 0, 4, 1);
        textures[i++] = new TexturePaint(bi, anchor);
        bi = new BufferedImage(5, 5, BufferedImage.TYPE_INT_RGB);
        big = bi.createGraphics();
        big.setColor(Color.white);
        big.fillRect(0, 0, 5, 5);
        big.setColor(Color.black);
        big.drawLine(1, 4, 4, 1);
        textures[i++] = new TexturePaint(bi, anchor);
        bi = new BufferedImage(5, 5, BufferedImage.TYPE_INT_RGB);
        big = bi.createGraphics();
        big.setColor(Color.white);
        big.fillRect(0, 0, 5, 5);
        big.setColor(Color.black);
        big.drawLine(1, 1, 4, 4);
        textures[i++] = new TexturePaint(bi, anchor);
        bi = new BufferedImage(5, 5, BufferedImage.TYPE_INT_RGB);
        big = bi.createGraphics();
        big.setColor(Color.white);
        big.fillRect(0, 0, 5, 5);
        big.setColor(Color.black);
        big.drawLine(2, 2, 2, 2);
        textures[i++] = new TexturePaint(bi, anchor);
        bi = new BufferedImage(5, 5, BufferedImage.TYPE_INT_RGB);
        big = bi.createGraphics();
        big.setColor(Color.white);
        big.fillRect(0, 0, 5, 5);
        big.setColor(Color.black);
        big.drawLine(0, 1, 2, 3);
        big.drawLine(2, 3, 4, 1);
        textures[i++] = new TexturePaint(bi, anchor);
        bi = new BufferedImage(5, 5, BufferedImage.TYPE_INT_RGB);
        big = bi.createGraphics();
        big.setColor(Color.white);
        big.fillRect(0, 0, 5, 5);
        big.setColor(Color.black);
        big.drawLine(1, 0, 2, 3);
        big.drawLine(2, 3, 1, 4);
        textures[i++] = new TexturePaint(bi, anchor);
        bi = new BufferedImage(5, 5, BufferedImage.TYPE_INT_RGB);
        big = bi.createGraphics();
        big.setColor(Color.white);
        big.fillRect(0, 0, 5, 5);
        big.setColor(Color.black);
        big.fillRect(1, 1, 2, 2);
        textures[i++] = new TexturePaint(bi, anchor);
        bi = new BufferedImage(5, 5, BufferedImage.TYPE_INT_RGB);
        big = bi.createGraphics();
        big.setColor(Color.white);
        big.fillRect(0, 0, 5, 5);
        big.setColor(Color.black);
        big.drawOval(1, 1, 4, 4);
        textures[i++] = new TexturePaint(bi, anchor);
        bi = new BufferedImage(5, 5, BufferedImage.TYPE_INT_RGB);
        big = bi.createGraphics();
        big.setColor(Color.white);
        big.fillRect(0, 0, 5, 5);
        big.setColor(Color.black);
        big.drawLine(2, 0, 2, 4);
        textures[i++] = new TexturePaint(bi, anchor);
        bi = new BufferedImage(5, 5, BufferedImage.TYPE_INT_RGB);
        big = bi.createGraphics();
        big.setColor(Color.white);
        big.fillRect(0, 0, 5, 5);
        big.setColor(Color.black);
        big.drawLine(0, 2, 4, 2);
        textures[i++] = new TexturePaint(bi, anchor);
        bi = new BufferedImage(5, 5, BufferedImage.TYPE_INT_RGB);
        big = bi.createGraphics();
        big.setColor(Color.white);
        big.fillRect(0, 0, 5, 5);
        big.setColor(Color.black);
        big.drawLine(2, 0, 2, 4);
        big.drawLine(0, 2, 4, 2);
        textures[i++] = new TexturePaint(bi, anchor);
    }
}
