/* Generated by Freestyle Learning Group */

package freestyleLearningGroup.independent.plotter;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.event.ComponentEvent;
import java.awt.geom.Arc2D;
import java.awt.geom.Point2D;

import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JPanel;

import freestyleLearningGroup.independent.util.FLGBlackAndWhite;
import freestyleLearningGroup.independent.util.FLGGraphics;

/**
 * Diese Klasse stellt ein Tortendiagramm zur Verf&uuml;gung f&uuml;r Werte die in einer
 * <code>FLGDataGroup2D</code> gespeichert sind.<p> Die Darstellung des Tortendiagrammes kann
 * durch eine ganze Reihe von Methoden ge&auml;ndert werden. U.A. k&ouml;nnen die Werte in die Tortenst&uuml;cke absolut oder
 * in Prozent in die Tortenst&uuml;cke geschrieben werden oder die Tortenst&uuml;cke mit Farbverl&auml;ufen, die
 * automatisch erzeugt werden, gef&uuml;llt werden. Zudem wird eine
 * Legende angezeigt.<p> Die folgenden Beispiele sollen neben dem <code>FLGPieChart2D</code> vor
 * allem auch die Benutzung der Klasse <code>FLGGraphics</code> und des Interfaces
 * <code>FLGBlackAndWhite</code> erl&auml;utern und verbindliche
 * Richtlinien zu deren Benutzung aufstellen.<p> <p> <b>Beispiel 1</b>: Erstellung eines
 * Tortendiagrammes. An den Konstruktor wird nur die Datengruppe &uuml;bergeben. Das
 * Erscheinungsbild des Tortendiagrammes wird durch die einzelnen <code>set...</code> Methoden bestimmt. <p><pre>
 *		JFrame frame = new JFrame("Beispiel 1");
 *
 *		FLGDataGroup2D data = new FLGDataGroup2D();
 *		
 *		data.add(new FLGData2D("Alex", 100));
 *		data.add(new FLGData2D("Andrea", 200, java.awt.Color.yellow));
 *		data.add(new FLGData2D("Daniel", 300, FLGGraphics.standardFillColor));	
 *		data.add(new FLGData2D("Jan", 50));	
 *		data.add(new FLGData2D("Norman", 20, java.awt.Color.green));	
 *		
 *		FLGPieChart2D piechart = new FLGPieChart2D(data);
 *		piechart.setPaintWithGradient(true);
 *		piechart.setRelativeValues(true);
 *		
 *		frame.getContentPane().add(piechart);
 *		frame.setSize(350,380);
 *		frame.show();
 *
 *		<img src="../../../../../images/PieChart2D.gif" width="350" height="380">
 * </pre><p> <p> <b>Beispiel 2</b>: Wird zu obigem Beispiel die Anweisung <code>piechart.setBlackAndWhite(true)</code>
 * hinzugef&uuml;gt ergibt sich folgendes Aussehen. <p><pre>
 *		piechart.setBlackAndWhite(true);
 *
 *		<img src="../../../../../images/PieChart2D-2.gif" width="350" height="380">
 * </pre><p> <p> <b>Erl&auml;uterungen 1</b>: Farben und Farbverl&auml;ufe.<p> Der folgende
 * Sourcecode ist aus der <code>paintComponent</code> Methode dieser Klasse entnommen.<p> Durch
 * die einheitliche Zuweisung von Farben bzw. Texturen,
 * die analog in der Legendenerstellung erfolgt, ist die &Uuml;bereinstimmung von Farben bzw.
 * Texturen in der Torte und der Legende gew&auml;hrleistet ohne sie explizit &uuml;bergeben zu m&uuml;ssen. <p><pre>
 *	<i>// setPaint in Abhängigkeit von den folgenden Einstellungen:
 *	// - hat das Datum eine zugewiesene Farbe
 *	// - soll in schwarz-weiß gezeichnet werden
 *	// - sollen Farbverläufe benutzt werden.
 *	//</i>
 *	if (dataGroup.get(i).getColor() != null) { <i>// Datum hat Farbe</i>
 *	  if (bw) { <i>// schwarz-weiss</i>
 *	    if (FLGGraphics.isStandardColor(dataGroup.get(i).getColor()) > -1)
 *	      <i>// wenn die Farbe eine Standardfarbe ist, wird sie auch durch
 *	      // die Standardtextur ersetzt.</i>
 *	      g2.setPaint(FLGGraphics.getTextureForStandardColor(dataGroup.get(i).getColor()));
 *	    else
 *	      <i>// Sonst wird die Textur anhand des Index festgelegt.</i>
 *	      g2.setPaint(FLGGraphics.getTexture(i));
 *	  } else { <i>// bunt</i>
 *	    if (gradient) <i>// mit Farbverlauf</i>
 *	      g2.setPaint(FLGGraphics.getGradient(dataGroup.get(i).getColor(),
 *						center,
 *						getEndPoint((Arc2D)piece)));
 *	                                          <i>// getEndPoint ist eine Methode
 *	                                          // dieser Klasse, um den Endpunkt
 *	                                          // des Farbverlaufs zu bestimmen.</i>
 *	    else // <i>ohne Farbverlauf</i>
 *	      g2.setPaint(dataGroup.get(i).getColor());
 *	  }
 *	}
 *	else {  <i>// Datum ist keine Farbe zugewiesen</i>
 *	  if (bw) { <i>// schwarz-weiss</i>
 *	    g2.setPaint(FLGGraphics.getTextureForStandardColor(FLGGraphics.getStandardColor(i)));
 *	  } else { <i>// bunt</i>
 *	    if (gradient) <i>// mit Farbverlauf</i>
 *	      g2.setPaint(FLGGraphics.getGradient(FLGGraphics.getStandardColor(i),
 *						center,
 *						getEndPoint((Arc2D)piece)));
 *	    else <i>// ohne Farbverlauf</i>
 *	      g2.setPaint(FLGGraphics.getStandardColor(i));
 *	  }
 *	}
 *	g2.fill(piece);
 * </pre><p> <b>Erl&auml;uterungen 2</b>: Text.<p> Der folgende Sourcecode ist ebenfalls aus der
 * <code>paintComponent</code> Methode dieser Klasse entnommen und wird ausgef&uuml;hrt, wenn die
 * Werte in die Tortenst&uuml;cke geschrieben werden sollen.<p> . <p><pre>
 *	if (bw) {
 *	  <i>// wenn schwarz-weiss, dann hinter dem Text ein ausreichend
 *	  // grosses weisses Rechteck und Text schwarz.</i>
 *	  g.setColor(Color.white);
 *	  g.fillRect((int)(xPos-2), (int)(yPos - g2.getFontMetrics().getAscent()), wertWidth+4,g2.getFontMetrics().getHeight()+2);
 *		g.setColor(Color.black);
 *	} else {
 *	  <i>// nicht schwarz-weiss</i>
 *	  if (dataGroup.get(i).getColor() != null)
 *	    <i>// Farbe ist spezifiziert: suche passende Textfarbe für diese Farbe</i>
 *	    g2.setColor(FLGGraphics.getTextColorFor(dataGroup.get(i).getColor()));
 *	  else
 *	    <i>// Farbe nicht spezifiziert: suche passende Textfarbe für den Index dieses Datums</i>
 *	    g2.setColor(FLGGraphics.getTextColorFor(i));
 *	}
 *
 *	g2.drawString(wert, (float)xPos, (float)yPos);
 * </pre><p>
 * @see freestyleLearningGroup.independent.util.FLGGraphics
 * @see freestyleLearningGroup.independent.util.FLGBlackAndWhite
 * @see	FLGDataGroup2D
 */
public class FLGPieChart2D extends JPanel implements FLGBlackAndWhite {
    //
    // Variablen
    //

    /** @serial Die Datengruppe, die dieses Diagramm definiert. */
    private FLGDataGroup2D dataGroup;

    /** @serial Das Tortendiagramm. */
    private PieChart chart;

    /** @serial Die Legende. */
    private Legend legend;

    /** @serial Die Winkel der einzelnen Tortenst&uuml;cke, normalisiert auf 360 Grad. */
    private double[] pieData;

    /** @serial Komponente schwarz-weiss zeichnen? */
    private boolean bw = false;

    /** @serial Komponente mit Farbverl&auml;fen zeichnen? */
    private boolean gradient = false;

    /** @serial Sollen die Tortenst&uuml;cke mit ihren Werten beschriftet werden ? */
    private boolean writeValues = false;

    /** @serial	Sollen die Tortenwerte in % angegeben werden. */
    private boolean relativeValues = false;

    /** @serial Soll die Legende gezeichnet werden ? */
    private boolean showLegend = true;

    /** @serial	Summe der Werte der Daten. */
    private double sum;

    /** @serial	Wurde die Datengruppe ge&auml;ndert ? */
    private boolean newDataGroup;
    //
    // Konstruktoren
    //

    /**
     * Erzeugt ein Tortendiagramm aus den spezifizierten Daten.
     * @param	dataGroup	die Daten dieses Balkendiagramms.
     */
    public FLGPieChart2D(FLGDataGroup2D dataGroup) {
        super(new BorderLayout());
        // setBorder(FLGBorderFactory.emptyLoweredBevel10);
        setDataGroup(dataGroup);
        chart = new PieChart();
        add(chart, BorderLayout.CENTER);
        enableEvents(ComponentEvent.COMPONENT_RESIZED);
    }

    /**
     * Erzeugt ein Tortendiagramm aus den spezifizierten Daten.
     * @param	dataGroup	die Daten dieses Balkendiagramms.
     */
    public FLGPieChart2D(FLGDataGroup2D dataGroup, boolean showLegend) {
        super(new BorderLayout());
        this.showLegend = showLegend;
        chart = new PieChart();
        add(chart, BorderLayout.CENTER);
        setDataGroup(dataGroup);
        enableEvents(ComponentEvent.COMPONENT_RESIZED);
    }
    //
    // Methoden
    //

    /**
     * Wann immer die Gr&ouml;&szlig;e ge&auml;ndert wird, ist zu &uuml;berpr&uuml;fen, ob die
     * Legende nach rechts oder nach unten soll.
     */
    protected void processComponentEvent(ComponentEvent e) {
        if (showLegend) positionLegend();
        chart.calcDimensions();
    }

    private void positionLegend() {
        Dimension d = getSize();
        if (d.width > d.height) {
            // breiter als hoch
            if (legend == null || newDataGroup) {
                legend = new Legend(dataGroup, Legend.VERTICAL);
                add(legend, BorderLayout.EAST);
                newDataGroup = false;
            }
            else {
                if (!legend.isVertical()) {
                    remove(legend);
                    legend = new Legend(dataGroup, Legend.VERTICAL);
                    add(legend, BorderLayout.EAST);
                }
            }
        }
        else {
            // höher als breit
            if (legend == null || newDataGroup) {
                legend = new Legend(dataGroup, Legend.HORIZONTAL);
                add(legend, BorderLayout.SOUTH);
                newDataGroup = false;
            }
            else {
                if (legend.isVertical()) {
                    remove(legend);
                    legend = new Legend(dataGroup, Legend.HORIZONTAL);
                    add(legend, BorderLayout.SOUTH);
                }
            }
        }
        legend.setBlackAndWhite(bw);
        chart.calcDimensions();
        validate();
    }

    /**
     * Setzt die Daten dieses Tortendiagrammes auf die spezifizierte <code>FLGDataGroup2D</code>.
     * @param	dataGroup	die neuen Werte dieses Tortendiagrammes.
     * @see	FLGDataGroup2D
     */
    public void setDataGroup(FLGDataGroup2D dataGroup) {
        this.dataGroup = dataGroup;
        newDataGroup = true;
        // Berechne die Winkel der Tortenstücke.
        pieData = new double[dataGroup.size()];
        sum = 0;
        for (int i = 0; i < dataGroup.size(); i++) sum += dataGroup.get(i).getValue();
        for (int i = 0; i < dataGroup.size(); i++)
            pieData[i] = dataGroup.get(i).getValue() * 360.0 / sum;
        if (showLegend) positionLegend();
        // Zeichne neu, wenn dataGroup geändert.
        repaint();
    }

    /**
     * Liefert die Daten dieses Tortendiagrammes.
     * @return die Daten dieses Tortendiagrammes.
     * @see	FLGDataGroup2D
     */
    public FLGDataGroup2D getDataGroup() {
        return dataGroup;
    }

    /**
     * Schaltet das F&uuml;llen der Tortenst&uuml;cke mit Farbverläufen ein oder aus.
     * @param	gradient	<code>true</code>, wenn mit Farbverl&auml;fen gef&uuml;llt werden soll. Sonst <code> false</code>.
     */
    public void setPaintWithGradient(boolean gradient) {
        this.gradient = gradient;
        repaint();
    }

    /**
     * Bestimmt, ob die Tortenst&uuml;cke gerade mit Farbverl&auml;fen gef&uuml;llt werden, oder
     * nicht. Kann durch <code>setPaintWithGradient()</code> ein- und ausgeschaltet werden.
     * @return	<code>true</code>, wenn mit Farbverl&auml;fen gef&uuml;llt werden soll. Sonst <code>false</code>.
     * @see #setPaintWithGradient(boolean)
     */
    public boolean isPaintWithGradient() {
        return gradient;
    }

    /**
     * Schaltet das Schreiben der Werte in die Tortenst&uuml;cke ein bzw. aus.
     * @param	writeValues	sollen die Werte in die Tortenst&uuml;cke geschrieben werden?
     */
    public void setShowValues(boolean writeValues) {
        this.writeValues = writeValues;
    }

    /**
     * Bestimmt, ob die Werte der einzelnen Tortenst&uuml;cke in sie hineingeschrieben werden oder
     * nicht. Kann durch <code>setWriteValue()</code> ein- und ausgeschaltet werden.
     * @return	<code>true</code>, wenn Werte geschrieben werden. Sonst <code>false</code>.
     * @see #setShowValues(boolean)
     */
    public boolean isShowValues() {
        return writeValues;
    }

    /**
     * Schaltet das Angeben der Werte in Prozent ein bzw. aus. Wird das Angeben der Werte in
     * Prozent eingeschaltet, wird auch das Schreiben der Werte in die Tortenst&uuml;cke automatisch aktiviert.
     * @param	relativeValues	sollen die Werte in die Tortenst&uuml;cke geschrieben werden?
     */
    public void setRelativeValues(boolean relativeValues) {
        this.relativeValues = relativeValues;
        if (relativeValues) setShowValues(true);
    }

    /**
     * Bestimmt, ob die Werte der einzelnen Tortenst&uuml;cke in Prozent angegeben werden sollen
     * oder nicht. Kann durch <code>setRelativeValues()</code> ein- und ausgeschaltet werden.
     * @return	<code>true</code>, wenn Werte in Prozent angegeben werden. Sonst <code>false</code>.
     * @see #setRelativeValues(boolean)
     */
    public boolean isRelativeValues() {
        return relativeValues;
    }

    /**
     * Methode des Interfaces <code>FLGBlackAndWhite</code>. Spezifiziert, ob die Komponente
     * farbig oder in Graut&ouml;nen gezeichnet werden soll.
     * @param	bw	soll die Komponente schwarz-weiss gezeichnet werden?
     */
    public void setBlackAndWhite(boolean bw) {
        this.bw = bw;
        if (legend != null) legend.setBlackAndWhite(bw);
    }

    /**
     * Bestimmt, ob das Tortendiagramm schwarz-wei&szlig; gezeichnet wird, oder nicht. Kann durch
     * <code>setBlackAndWhite()</code> ein- und ausgeschaltet werden.
     * @return	<code>true</code>, wenn schwarz-wei&szlig; gezeichnet wird. Sonst <code>false</code>.
     * @see #setBlackAndWhite(boolean)
     */
    public boolean isBlackAndWhite() {
        return bw;
    }

    public void update(Graphics g) {
        if (showLegend) positionLegend();
        chart.calcDimensions();
        super.update(g);
    }

    class PieChart extends JComponent {
        private Point pieMargins;
        private Dimension pieDimension = new Dimension();
        private Point2D.Double center;

        PieChart() {
            enableEvents(ComponentEvent.COMPONENT_RESIZED);
        }

        protected void processComponentEvent(ComponentEvent e) {
            calcDimensions();
        }

        private void calcDimensions() {
            Dimension d = getSize();
            int minDim = (d.width > d.height) ? d.height : d.width;
            pieMargins = new Point((d.width - minDim) / 2 > 0 ? (d.width - minDim) / 2 : 5,
                (d.height - minDim) / 2 > 0 ? (d.height - minDim) / 2 : 5);
            pieDimension.width = d.width - 2 * pieMargins.x;
            pieDimension.height = d.height - 2 * pieMargins.y;
            // die Mitte der Torte
            center = new Point2D.Double(pieMargins.x + pieDimension.width / 2, pieMargins.y + pieDimension.height / 2);
        }

        public void paintComponent(Graphics g) {
            Graphics2D g2 = (Graphics2D)g;
            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
            g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
            // der Startwinkel eines Tortenstücks
            double start = 0.0;
            // der Winkel des Tortenstücks
            double extent = 0.0;
            // rausgerückte Stücke.
            int pieGap = 0;
            for (int i = 0; i < dataGroup.size(); i++) {
                extent = pieData[i];
                // Erzeuge das Tortenstück dieses Wertes
                Shape piece = new Arc2D.Double(pieMargins.x, pieMargins.y, pieDimension.width - 2 * pieGap,
                    pieDimension.height - 2 * pieGap, start, extent, Arc2D.PIE);
                // setPaint in Abhängigkeit von den folgenden Einstellungen:
                // - hat das Datum eine zugewiesene Farbe
                // - soll in schwarz-weiß gezeichnet werden
                // - sollen Farbverläufe benutzt werden.
                //
                if (dataGroup.get(i).getColor() != null) { // Datum hat Farbe
                    if (bw) { // schwarz-weiss
                        if (FLGGraphics.isStandardColor(dataGroup.get(i).getColor()) > -1)
                            g2.setPaint(FLGGraphics.getTextureForStandardColor(dataGroup.get(i).getColor()));
                        else
                            g2.setPaint(FLGGraphics.getTexture(i));
                    }
                    else { // bunt
                        if (gradient) // mit Farbverlauf
                                g2.setPaint(FLGGraphics.getGradient(dataGroup.get(i).getColor(),
                                center, getEndPoint((Arc2D)piece)));
                        else // ohne Farbverlauf
                                g2.setPaint(dataGroup.get(i).getColor());
                    }
                }
                else { // Datum ist keine Farbe zugewiesen
                    if (bw) { // schwarz-weiss
                        g2.setPaint(FLGGraphics.getTextureForStandardColor(FLGGraphics.getStandardColor(i)));
                    }
                    else { // bunt
                        if (gradient) // mit Farbverlauf
                                g2.setPaint(FLGGraphics.getGradient(FLGGraphics.getStandardColor(i),
                                center, getEndPoint((Arc2D)piece)));
                        else // ohne Farbverlauf
                                g2.setPaint(FLGGraphics.getStandardColor(i));
                    }
                }
                g2.fill(piece);
                // Und noch einen Rand um das Stück zeichnen.
                g2.setColor(FLGGraphics.standardOutlineColor);
                g2.draw(piece);
                // Wenn gewünscht, Wert in Tortenstück schreiben
                if (writeValues) {
                    String wert;
                    // Wert in Prozent ausgeben?
                    if (relativeValues) {
                        double relativeValuesValue = 100 * dataGroup.get(i).getValue() / sum;
                        wert = createString(freestyleLearningGroup.independent.util.FLGMathExtension.roundDouble(relativeValuesValue,
                            2)) + "%";
                    }
                    else
                        wert = createString(dataGroup.get(i).getValue());
                    // Breite des Wertes
                    int wertWidth = g2.getFontMetrics().stringWidth(wert);
                    Point2D arcEnd = getEndPoint((Arc2D)piece);
                    double xPos = (center.getX() + 2 * arcEnd.getX()) / 3 - wertWidth / 2;
                    double yPos = (center.getY() + 2 * arcEnd.getY()) / 3 + g2.getFontMetrics().getHeight() / 2;
                    if (bw) {
                        // wenn schwarz-weiss, dann hinter dem Text ein ausreichend
                        // grosses weisses Rechteck und Text schwarz.
                        g.setColor(Color.white);
                        g.fillRect((int)(xPos - 2), (int)(yPos - g2.getFontMetrics().getAscent()),
                            wertWidth + 4, g2.getFontMetrics().getHeight() + 2);
                        g.setColor(Color.black);
                    }
                    else {
                        if (dataGroup.get(i).getColor() != null)
                            // Farbe ist spezifiziert: suche passende Textfarbe für diese Farbe
                                g2.setColor(FLGGraphics.getTextColorFor(dataGroup.get(i).getColor()));
                        else
                            // Farbe nicht spezifiziert: suche passende Textfarbe für den Index dieses Datums
                                g2.setColor(FLGGraphics.getTextColorFor(i));
                    }
                    g2.drawString(wert, (float)xPos, (float)yPos);
                }
                start += extent;
            }
        }

        /** Liefert den Endpunkt für den Farbverlauf: die Mitte des Arc. */
        private Point2D getEndPoint(Arc2D arc) {
            double angle = Math.toRadians(arc.getAngleStart() + arc.getAngleExtent() / 2);
            double x = arc.getX() + (Math.cos(angle) * 0.5 + 0.5) * arc.getWidth();
            double y = arc.getY() + (Math.sin(angle) * 0.5 + 0.5) * arc.getHeight();
            // aus irgendeinem komischen grund muß y 'invertiert' werden
            return new Point2D.Double(x, pieDimension.getHeight() + pieMargins.getY() - y);
        }

        /** Erzeugt einen String aus der Zahl. */
        private String createString(double d) {
            String s = String.valueOf(d);
            int l = s.length();
            if (s.charAt(l - 2) == '.' && s.charAt(l - 1) == '0') s = s.substring(0, l - 2);
            return s;
        }
    }


    public static void main(String args[]) {
        JFrame frame = new JFrame("Beispiel 1");
        FLGDataGroup2D data = new FLGDataGroup2D();
        data.add(new FLGData2D("Alex", 100));
        data.add(new FLGData2D("Andrea", 200, java.awt.Color.yellow));
        data.add(new FLGData2D("zehnbuchst", 300, FLGGraphics.standardFillColor));
        data.add(new FLGData2D("neunzehnbuchtabenar", 50));
        data.add(new FLGData2D("iiiiiiiiiiiiiiiiiii", 20, java.awt.Color.green));
        FLGPieChart2D piechart = new FLGPieChart2D(data, true);
        piechart.setPaintWithGradient(true);
        piechart.setShowValues(true);
        piechart.setBlackAndWhite(false);
        frame.getContentPane().add(piechart);
        frame.setSize(350, 380);
        frame.setVisible(true);
    }
}


/** Die Legende f&uuml;r ein Tortendiagramm. */
class Legend extends JPanel implements FLGBlackAndWhite {
    /** Die Legende in &quot;breit&quot; zeichnen. */
    public static int HORIZONTAL = 0;

    /** Die Legende in &quot;hoch&quot; zeichnen. */
    public static int VERTICAL = 1;

    /** @serial Komponente schwarz-weiss zeichnen? */
    private boolean bw = false;
    private int align = 1;
    private FLGDataGroup2D dataGroup;
    LegendEntry[] entries;

    /**
     * Erzeugt eine neue Legende aus der spezifizierten Datengruppe und richtet die horizontal oder vertikal aus.
     * @param	dataGroup	die die Legende definierende Datengruppe.
     * @param align     die Ausrichtung der Legende.
     */
    Legend(FLGDataGroup2D dataGroup, int align) {
        super();
        this.dataGroup = dataGroup;
        this.align = align;
        if (align == VERTICAL) setLayout(new GridLayout(dataGroup.size(), 1));
        else {
            int rows = dataGroup.size() / 4 + 1;
            setLayout(new GridLayout(rows, 4));
        }
        entries = new LegendEntry[dataGroup.size()];
        for (int i = dataGroup.size() - 1; i >= 0; i--) {
            if (dataGroup.get(i).getColor() != null)
                entries[i] = new LegendEntry(dataGroup.get(i).getName(), dataGroup.get(i).getColor(), i);
            else
                entries[i] = new LegendEntry(dataGroup.get(i).getName(), FLGGraphics.getStandardColor(i), i);
            add(entries[i]);
        }
    }

    /**
     * Bestimmt, ob die Legende vertikal ausgerichtet ist oder nicht.
     * @return	<code>true</code>, wenn die Legende vertikal ausgerichtet ist. Sonst <code>false</code>.
     * @see #setWriteValue(boolean)
     */
    public boolean isVertical() { return (align == VERTICAL); }

    /**
     * Methode des Interfaces <code>FLGBlackAndWhite</code>. Spezifiziert, ob die Komponente
     * farbig oder in Graut&ouml;nen gezeichnet werden soll.
     * @param	bw	soll die Komponente schwarz-weiss gezeichnet werden?
     */
    public void setBlackAndWhite(boolean bw) {
        this.bw = bw;
    }

    /**
     * Ein Eintrag der Legende. Besteht aus einem K&auml;stchen, gef&uuml;llt in der Farbe des
     * Elements einer Datengruppe und dessen Namen.
     */
    class LegendEntry extends JComponent {
        private String name = null;
        private Color color = null;
        private Dimension dim = null;
        private int index;

        /**
         * Erzeugt einen Legendeneintrag in der spezifizierten Farbe und dem &uuml;bergebenem Namen.
         * @param name	der Name des Legendeneintrages.
         * @param color	die Farbe, oder das F&uuml;llmuster des Legendeneintrages.
         */
        LegendEntry(String name, Color color, int index) {
            this.name = name;
            this.color = color;
            this.index = index;
            dim = new Dimension((int)(30 + 6.5 * name.length()), 20);
        }

        /** Zeichnet den Legendeneintrag. */
        public void paintComponent(Graphics g) {
            Graphics2D g2 = (Graphics2D)g;
            g2.setPaint(FLGGraphics.standardOutlineColor);
            g2.drawRect(10, 5, 10, 10);
            g2.drawString(name, 25, 15);
            if (bw) { // schwarz-weiss
                if (FLGGraphics.isStandardColor(color) > -1)
                    g2.setPaint(FLGGraphics.getTextureForStandardColor(color));
                else
                    g2.setPaint(FLGGraphics.getTexture(index));
            }
            else { // bunt
                g2.setPaint(color);
            }
            g2.fillRect(10, 5, 10, 10);
        }

        /** Liefert die minimale Gr&ouml;&szlig;e dieses Legendeneintrages. */
        public Dimension getMinimumSize() {
            return dim;
        }

        /** Liefert die bevorzugte Gr&ouml;&szlig;e dieses Legendeneintrages. */
        public Dimension getPreferredSize() {
            return dim;
        }
    }
}
