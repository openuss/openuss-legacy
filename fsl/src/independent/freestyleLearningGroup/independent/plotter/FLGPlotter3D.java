/* Generated by Freestyle Learning Group */

package freestyleLearningGroup.independent.plotter;

import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Graphics;
import java.awt.event.InputEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;

import freestyleLearningGroup.independent.world3D.FLGFace;
import freestyleLearningGroup.independent.world3D.FLGObj3D;
import freestyleLearningGroup.independent.world3D.FLGPoint;
import freestyleLearningGroup.independent.world3D.FLGWorld3D;

/**
 * Ein Plotter, der dreidimensionale Funktionen zeichnen kann. Es wird automatisch ein zu der
 * &uuml;bergebenen Funktionsgruppe passendes Koordinatensystem erzeugt.<p> <b>Beispiel 1</b>:
 * Erstellt einen dreidimensionalen Funktionsplotter. Gezeichnet wird eine gew&ouml;bte Fl&auml;che. Zudem wird der Plotter
 * ein wenig gedreht, um eine bessere Sicht zu haben. <p> <pre>
 *		FLGFunction3D function = new FLGFunction3D(Double.NEGATIVE_INFINITY,
 *		                                         Double.POSITIVE_INFINITY,
 *		                                         Double.NEGATIVE_INFINITY,
 *		                                         Double.POSITIVE_INFINITY) {
 *		  public double calculate(double x, double z) {
 *		    return (x*x-15*z);
 *		  }
 *		};
 *		
 *		FLGFunctionGroup3D functionGroup = new FLGFunctionGroup3D(0, 10, 0, 10, 20);
 * 		functionGroup.addFunction(function);
 *
 * 		FLGPlotter3D plotter3d = new FLGPlotter3D(functionGroup, 20);
 *		plotter3d.rotate(30, 350, 10);
 *
 *		<img src="../../../../../images/Plotter3D.gif" width="600" height="400">
 *  </pre> </p> <p> <b>Beispiel 2</b>: Erstellt den gleichen dreidimensionalen Funktionsplotter wie
 * in Beispiel 1. Hier wird aber die <code>animate</code>-Methode so &uuml;berschrieben, dass das
 * Modell in 1 Grad-Schritten um die <i>y</i>-Achse gedreht wird. Zudem ist das Grid eingeschaltet. <p> <pre>
 *		FLGFunction3D function = new FLGFunction3D(Double.NEGATIVE_INFINITY,
 *		                                         Double.POSITIVE_INFINITY,
 *		                                         Double.NEGATIVE_INFINITY,
 *		                                         Double.POSITIVE_INFINITY) {
 *		  public double calculate(double x, double z) {
 *		    return (x*x-15*z);
 *		  }
 *		};
 *		
 *		FLGFunctionGroup3D functionGroup = new FLGFunctionGroup3D(0, 10, 0, 10, 20);
 * 		functionGroup.addFunction(function);
 *
 *		FLGPlotter3D plotter3d = new FLGPlotter3D(functionGroup, 20) {
 *			int	myX, myY, myZ;
 *			public void animate() {
 *				this.rotate(0,1,0);
 *			}
 *		};
 *		
 *		JPanel	plotterPanel = new JPanel(new GridLayout(1,1));
 *		plotterPanel.add(plotter3d);
 *		
 *		plotter3d.startAnim();
 *		plotter3d.gridVisible(true);
 *
 *		<img src="../../../../../images/Plotter3D-2.gif" width="600" height="400">
 *  </pre> </p>
 * @see	FLGFunction3D
 * @see FLGFunctionGroup3D
 */
public class FLGPlotter3D extends Component implements Runnable {
    //
    // Konstanten
    //
    private static final double SIZE = 500;
    private static final double DEPTH = 2000 + SIZE / 2;
    //
    // Variablen
    //

    /** @serial Die Aufl&ouml;sung dieses Plotters. */
    private int res = 20;

    /** @serial Die 3D-Welt dieses Plotters. */
    private FLGWorld3D world3D;

    /** @serial	Das Koordinatensystem dieses Plotters. */
    private FLGCoordSystem coordSystem;
    private transient Thread runner = null;

    /** @serial	Die Funktionen dieses Plotters. */
    private FLGFunctionGroup3D functionGroup;

    /** Gerade am Zeichnen ? */
    private transient boolean withinPaint = false;

    /** Muss vor dem Zeichnen noch animiert werden ? */
    private transient boolean doAnim = false;

    /** Letzte Position der Maus - für die Maus-Rotation */
    private int last_x, last_y;
    private boolean mouseRotation = false;

    /** Graphics-Referenz (für repaint) */
    private Graphics g;
    //
    // Konstruktoren
    //

    /**
     * Erzeugt einen 3D Plotter mit den spezifizierten 3D Funktionen und der spezifizierten Aufl&ouml;sung.
     * @param	functionGroup	die Funktionen, deren Daten geplottet werden sollen.
     * @param	res						die Aufl&ouml;sung dieses Plotters.
     */
    public FLGPlotter3D(FLGFunctionGroup3D functionGroup, int res) {
        this.res = res;
        world3D = new FLGWorld3D(this);
        coordSystem = new FLGCoordSystem(SIZE, 10, 0, functionGroup, world3D);
        coordSystem.move(-SIZE / 2, -SIZE / 2, -DEPTH - SIZE / 2);
        coordSystem.setRotPoint(SIZE / 2, SIZE / 2, SIZE / 2);
        world3D.setCoordSystem(coordSystem);
        setFunctionGroup(functionGroup, false);
        initMouseRotatable();
    }
    //
    // Methoden
    //

    /**
     * &Auml;ndert die Funktionen, deren Daten geplottet werden sollen auf die spezifizierten 3D Funktionen und zeichnet sie.
     * @param	functionGroup	die Funktionen, deren Daten geplottet werden sollen.
     */
    public void setFunctionGroup(FLGFunctionGroup3D functionGroup) {
        setFunctionGroup(functionGroup, true);
    }

    /**
     * &Auml;ndert die Funktionen, deren Daten geplottet werden sollen auf die spezifizierten 3D
     * Funktionen und zeichnet sie wenn gewollt.
     * @param	functionGroup	die Funktionen, deren Daten geplottet werden sollen.
     * @param	repaint				sollen die neuen Funktionen sofort gezeichnet werden ?
     */
    public void setFunctionGroup(FLGFunctionGroup3D functionGroup, boolean repaint) {
        this.functionGroup = functionGroup;
        FLGPoint[] points;
        FLGFace[] faces;
        FLGObj3D[] objects = new FLGObj3D[1];
        // Koordinaten immer gegen den Uhrzeigersinn definieren
        // Achtung: Y wächst nach oben hin, X nach rechts und Z aus den Monitor raus
        // (Normalvektor: "rechte-Hand-Regel: Daumen: 1 Vektor, Zeigefinger: 2 Vektor")
        int noFunctions = functionGroup.getNoFunctions();
        points = new FLGPoint[noFunctions * (res + 1) * (res + 1)];
        faces = new FLGFace[noFunctions * res * res];
        int pointsOffset = 0;
        int facesOffset = 0;
        for (int f = 0; f < noFunctions; f++) {
            // calculate points
            for (int z = 0; z < (res + 1); z++) {
                for (int x = 0; x < (res + 1); x++) {
                    points[pointsOffset + (z * (res + 1) + x)] =
                        new FLGPoint(x * (SIZE / res) - SIZE / 2, 0, z * (SIZE / res) - SIZE / 2);
                }
            }
            // calculate faces
            for (int z = 0; z < res; z++) {
                for (int x = 0; x < res; x++) {
                    Color color = Color.red;
                    if (noFunctions > 1) {
                        int colorSwitch = f % 3;
                        if (colorSwitch == 0) color = new Color((x * 191) / (res - 1) + 64, 0, 0);
                        if (colorSwitch == 1) color = new Color(0, (x * 191) / (res - 1) + 64, 0);
                        if (colorSwitch == 2) color = new Color(0, 0, (x * 191) / (res - 1) + 64);
                    }
                    else {
                        color = new Color((x * 191) / (res - 1) + 64, (z * 191) / (res - 1) + 64, 0);
                    }
                    faces[facesOffset + (z * res + x)] = new
                        FLGFace(pointsOffset + (x + z * (res + 1)), pointsOffset + (x + 1 + z * (res + 1)),
                        pointsOffset + (x + 1 + (res + 1) + z * (res + 1)), pointsOffset + (x + (res + 1) + z * (res + 1)), color);
                }
            }
            pointsOffset += (res + 1) * (res + 1);
            facesOffset += res * res;
        }
        objects[0] = new FLGObj3D(points, faces, 0, world3D);
        objects[0].move(0, 0, -DEPTH);
        world3D.setObjects(objects);
        calcFunctions();
        if (repaint) {
            coordSystem.setFunctionGroup(functionGroup);
            repaint();
        }
    }

    /**
     * Liefert die 3D Welt dieses Plotters.
     * @return	die 3D Welt.
     */
    public FLGWorld3D getWorld3D() { return world3D; }

    /**
     * Verschiebt die Zeichenwelt dieses Plotters um die spezifizierten Werte.
     * @param	x,&nbsp;y,&nbsp;z	die Werte, um die verschoben werden soll.
     */
    public void move(double x, double y, double z) {
        world3D.objects[0].move(x, y, z);
        world3D.coordSystem.move(x, y, z);
        if (!(withinPaint)) repaint();
    }

    /**
     * Rotiert die Zeichenwelt dieses Plotters um die spezifizierten Winkel. Die Gradangaben
     * m&uuml;ssen zwischen 0 und 360 liegen.
     * @param x			der Winkel um wieviel die x-Achse rotiert werden soll.
     * @param x			der Winkel um wieviel die y-Achse rotiert werden soll.
     * @param x			der Winkel um wieviel die z-Achse rotiert werden soll.
     */
    public void rotate(int x, int y, int z) {
        world3D.rotate(0, x, y, z);
        if (!(withinPaint)) repaint();
    }

    /**
     * Ist das Raster sichtbar?
     * @returns	<code>true</code> wenn das Raster sichtbar ist, sonst <code>false</code>.
     */
    public boolean isGridVisible() {
        // AS return world3D.objects[0].outlineFaces;
        return world3D.objects[0].getOutlineFaces();
    }

    /**
     * Setzt die Sichtbarkeit des Rasters.
     * @param	visible	<code>true</code> wenn das Raster sichtbar sein soll, sonst <code>false</code>.
     */
    public void gridVisible(boolean visible) {
        // AS world3D.objects[0].outlineFaces = visible;
        world3D.objects[0].setOutlineFaces(visible);
        if (!(withinPaint)) repaint(1);
    }
    //
    // Animationsmethoden
    //

    /** Startet die Animation dieses 3D Plotters. */
    public void startAnim() {
        if (runner == null) {
            world3D.frames = 0;
            runner = new Thread(this);
            runner.setPriority(Thread.MIN_PRIORITY);
            runner.start();
        }
    }

    /** Stoppt die Animation dieses 3D Plotters. */
    public void stopAnim() {
        if (runner != null) {
            runner.interrupt();
            runner = null;
        }
    }

    public void initMouseRotatable() {
        this.addMouseListener(
            new MouseAdapter() {
                public void mousePressed(MouseEvent e) {
                    last_x = e.getX();
                    last_y = e.getY();
                    setCursor(new Cursor(Cursor.HAND_CURSOR));
                    mouseRotation = (e.getModifiers() & InputEvent.BUTTON1_MASK) > 0;
                }
                public void mouseReleased(MouseEvent e) {
                    setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
                }
            });
        this.addMouseMotionListener(
            new MouseMotionAdapter() {
                public void mouseDragged(MouseEvent e) {
                    int rangex = e.getX() - last_x;
                    int rangey = e.getY() - last_y;
                    int rangez = 0;
                    rangex = rangex / 2;
                    rangey = rangey / 2;
                    if (rangex < 0) {
                        if (rangex < -30) {
                            rangex = -30;
                        }
                        rangex = 360 + rangex;
                    }
                    else {
                        if (rangex > 30) {
                            rangex = 30;
                        }
                    }
                    if (rangey < 0) {
                        if (rangey < -30) {
                            rangey = -30;
                        }
                        rangey = 360 + rangey;
                    }
                    else {
                        if (rangey > 30) {
                            rangey = 30;
                        }
                    }
                    if (mouseRotation) rotate(rangey, rangex, rangez);
                    else
                        move(0, 0, last_y - e.getY());
                    last_x = e.getX();
                    last_y = e.getY();
                }
            });
    }

    /**
     * Diese Methode muss von einer abgeleiteten Klasse &uuml;berschrieben werden.
     * Sie spezifiziert wie die Animation ablaufen soll. In dieser Klasse hat diese Methode keine Effekte.
     */
    public void animate() {
    }

    /**
     * Wird automatisch aufgerufen und spezifiziert, dass bei einer Animation alle 10 ms neu
     * gezeichnet wird. Dies kann durch zus&auml;tzliche Verz&ouml;gerungen in der
     * <code>animate</code>-Methode verlangsamt werden.
     */
    public void run() {
        while (true) {
            doAnim = true;
            repaint();
            try { Thread.sleep(10); }
            catch (Exception e) {
                System.out.println("FLGPlotter3D.run(): " + e);
            }
        }
    }
    //
    // Paint Methods
    //

    /** Zeichnet diesen 3D Plotter. */
    public synchronized void paint(Graphics g) {
        this.g = g;
        withinPaint = true;
        int displaySize;
        if (getBounds().height < getBounds().width) displaySize = getBounds().height;
        else
            displaySize = getBounds().width;
        world3D.setScaleFactor(2d * displaySize / SIZE);
        if (doAnim) {
            doAnim = false;
            animate();
        }
        world3D.paint(g);
        withinPaint = false;
    }

    /** Zeichnet diesen 3D Plotter neu. */
    public void update(Graphics g) {
        paint(g);
    }

    /** Zeichnet diesen 3D Plotter neu. */
    public void updateUI() {
        paint(g);
    }

    /** Berechnet die Funktionen neu. */
    public void recalculateFunctions() {
        calcFunctions();
    }

    //
    // Support Methods
    //
    private void calcFunctions() {
        FLGPoint[] points = world3D.objects[0].points;
        int pointsOffset = 0;
        double fctMinX = functionGroup.getMinX();
        double fctMaxX = functionGroup.getMaxX();
        double fctMinY = functionGroup.getMinY();
        double fctMaxY = functionGroup.getMaxY();
        double fctMinZ = functionGroup.getMinZ();
        double fctMaxZ = functionGroup.getMaxZ();
        for (int f = 0; f < functionGroup.getNoFunctions(); f++) {
            double fctX, fctY, fctZ;
            double areaY;
            for (int z = 0; z < (res + 1); z++) {
                for (int x = 0; x < (res + 1); x++) {
                    fctX = fctMinX + x * (fctMaxX - fctMinX) / res;
                    fctZ = fctMinZ + z * (fctMaxZ - fctMinZ) / res;
                    fctY = functionGroup.getFunction(f).calculate(fctX, fctZ);
                    areaY = (fctY - fctMinY) * SIZE / (fctMaxY - fctMinY) - SIZE / 2;
                    points[pointsOffset + (z * (res + 1) + x)].y = areaY;
                }
            }
            pointsOffset += (res + 1) * (res + 1);
        }
    }
}
