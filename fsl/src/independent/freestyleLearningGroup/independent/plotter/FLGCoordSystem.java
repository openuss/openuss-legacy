/* Generated by Freestyle Learning Group */

package freestyleLearningGroup.independent.plotter;

import java.awt.Color;
import java.awt.FontMetrics;
import java.awt.Graphics;

import freestyleLearningGroup.independent.util.FLGObjectPool;
import freestyleLearningGroup.independent.world3D.FLGPoint;
import freestyleLearningGroup.independent.world3D.FLGWorld3D;

/**
 * <code>FLGCoordSystem</code> stellt ein allgemeines Koordinatensystem f&uuml;r die
 * Klasse <code>FLGPlotter3D</code> zur Verf&uuml;gung. Ein Koordinatensystem braucht immer einen
 * Bezug zu einer <code>FLGWorld3D</code>.
 * @see FLGPlotter3D
 */
public class FLGCoordSystem {
    //
    // Konstanten
    //
    private static final int MAX_NO_AXIS_LABELS = 21;
    private static final int MIN_INTER_LABEL_DIST = 3;
    private static final int XY_GRID = 0, YZ_GRID = 1, XZ_GRID = 2;
    private static final int X_AXIS = 0, Y_AXIS = 1, Z_AXIS = 2;
    //
    // Variablen
    //
    private FLGWorld3D world3D;
    private boolean firstPaint = true;
    private int trMatrixInd;
    private double[] [] trMatrix;
    private FLGPoint normVectorXY, normVectorYZ, normVectorXZ;
    private FLGPoint tNormVectorXY = new FLGPoint(0, 0, 0);
    private FLGPoint tNormVectorYZ = new FLGPoint(0, 0, 0);
    private FLGPoint tNormVectorXZ = new FLGPoint(0, 0, 0);
    private FLGPoint trOrigPoint = new FLGPoint(0, 0, 0); // transformed origin point
    private double addX, addY, addZ;
    private FLGPoint rotPnt = new FLGPoint(0, 0, 0);
    private FLGPoint viewPoint;
    private boolean paintXAxis, paintYAxis, paintZAxis;
    private boolean paintXYGrid, paintYZGrid, paintXZGrid;
    private double axisLength;
    private double axis2DLength;
    private int noGridSections;
    private double fgMinX, fgMaxX, fgMinZ, fgMaxZ, fgMinY, fgMaxY;
    private double fgRdMinX, fgRdMaxX, fgRdMinZ, fgRdMaxZ, fgRdMinY, fgRdMaxY;
    private int maxXLabelWidth, maxYLabelWidth, maxZLabelWidth;
    private double[] xAxisLabelsPos = new double[MAX_NO_AXIS_LABELS];
    private double[] yAxisLabelsPos = new double[MAX_NO_AXIS_LABELS];
    private double[] zAxisLabelsPos = new double[MAX_NO_AXIS_LABELS];
    private int noXAxisLabels = 0, noYAxisLabels = 0, noZAxisLabels = 0;
    private String xAxisName = "X", yAxisName = "Y", zAxisName = "Z";
    private FontMetrics fm = null;
    private int fontHeight;
    private int fontAscent;
    private FLGObjectPool pointPool;
    private int[] xArray = new int[10];
    private int[] yArray = new int[10];
    private FLGPoint tViewPoint = new FLGPoint(); // transformierter Viewpoint
    //
    // Konstruktoren
    //

    /**
     * Erzeugt ein Koordinatensystem und initialisert es mit den spezifizierten Parametern.
     * @param	axisLength			die L&auml;nge der Achsen.
     * @param	noGridSections	die Anzahl der Unterteilungen je Achse.
     * @param	trMatrixInd			der Index der zu benutzenden Transformationsmatrix.
     * @param	functionGroup		die Funktionsgruppe, f&uuml;r die dieses Koordinatensystem optimiert werden soll.
     * @param FLGWorld3D				die 3D Welt, die dieses Koordinatensystem benutzt.
     */
    public FLGCoordSystem(double axisLength, int noGridSections, int trMatrixInd,
        FLGFunctionGroup3D functionGroup, FLGWorld3D world3D) {
            pointPool = new FLGObjectPool(100) {
                public Object newInstance() {
                    return new FLGPoint(0, 0, 0);
                }
            };
            this.axisLength = axisLength;
            this.noGridSections = noGridSections;
            this.trMatrixInd = trMatrixInd;
            this.world3D = world3D;
            this.viewPoint = world3D.getViewPoint();
            this.trMatrix = world3D.getTrMatrix(trMatrixInd);
            normVectorXY = new FLGPoint(0, 0, 1024);
            normVectorYZ = new FLGPoint(1024, 0, 0);
            normVectorXZ = new FLGPoint(0, 1024, 0);
            addX = 0;
            addY = 0;
            addZ = 0;
            setFunctionGroup(functionGroup);
    }
    //
    // Methoden
    //

    /**
     * Setzt die spezifizierte <code>FLGFuntionGroup3D</code> für dieses Koordinatensystem. Es
     * wird benötigt, um das Koordinatensystem optimal auf die darzustellenden Funktionen abzustimmen.
     * @param	functionGroup	die Funktionsgruppe, f&uuml;r die dieses Koordinatensystem genutzt werden soll.
     */
    public void setFunctionGroup(FLGFunctionGroup3D functionGroup) {
        fgMinX = functionGroup.getMinX();
        fgMaxX = functionGroup.getMaxX();
        fgMinZ = functionGroup.getMinX();
        fgMaxZ = functionGroup.getMaxX();
        fgMinY = functionGroup.getMinY();
        fgMaxY = functionGroup.getMaxY();
        double range = fgMaxX - fgMinX;
        fgMinX = correctDouble(fgMinX, range);
        fgMaxX = correctDouble(fgMaxX, range);
        range = fgMaxZ - fgMinZ;
        fgMinZ = correctDouble(fgMinZ, range);
        fgMaxZ = correctDouble(fgMaxZ, range);
        range = fgMaxY - fgMinY;
        fgMinY = correctDouble(fgMinY, range);
        fgMaxY = correctDouble(fgMaxY, range);
        // Berechne fgRdMinX und fgRdMaxX
        int decPos = calcDecPos(fgMaxX - fgMinX);
        fgRdMinX = calcFloor(fgMinX, decPos);
        fgRdMaxX = calcCeil(fgMaxX, decPos);
        range = fgRdMaxX - fgRdMinX;
        fgRdMinX = correctDouble(fgRdMinX, range);
        fgRdMaxX = correctDouble(fgRdMaxX, range);
        // Berechne fgRdMinZ und fgRdMaxZ
        decPos = calcDecPos(fgMaxZ - fgMinZ);
        fgRdMinZ = calcFloor(fgMinZ, decPos);
        fgRdMaxZ = calcCeil(fgMaxZ, decPos);
        range = fgRdMaxZ - fgRdMinZ;
        fgRdMinZ = correctDouble(fgRdMinZ, range);
        fgRdMaxZ = correctDouble(fgRdMaxZ, range);
        // Berechne fgRdMinY und fgRdMaxY
        decPos = calcDecPos(fgMaxY - fgMinY);
        fgRdMinY = calcFloor(fgMinY, decPos);
        fgRdMaxY = calcCeil(fgMaxY, decPos);
        range = fgRdMaxY - fgRdMinY;
        fgRdMinY = correctDouble(fgRdMinY, range);
        fgRdMaxY = correctDouble(fgRdMaxY, range);
        firstPaint = true;
    }

    /**
     * Verschiebt das Koordinatensystem um die spezifizierten Werte.
     * @param	x	der Wert um den das Koordinatensystem entlang der <i>x</i>-Achse verschoben wird.
     * @param	y	der Wert um den das Koordinatensystem entlang der <i>y</i>-Achse verschoben wird.
     * @param	z	der Wert um den das Koordinatensystem entlang der <i>z</i>-Achse verschoben wird.
     */
    public void move(double x, double y, double z) {
        addX += x;
        addY += y;
        addZ += z;
    }

    /**
     * Setzt den Rotationspunkt dieses Koordinatensystems.
     * @param	x,&nbsp;y,&nbsp;z	die Koordinaten des Roationspunktes.
     */
    public void setRotPoint(double x, double y, double z) {
        rotPnt.x = x;
        rotPnt.y = y;
        rotPnt.z = z;
    }

    /**
     * Setzt die Beschriftung der X-Achse des Koordinatensystems.
     * @param	s  Beschriftung der X-Achse.
     */
    public void setXAxisName(String s) {
        this.xAxisName = s;
    }

    /**
     * Setzt die Beschriftung der Y-Achse des Koordinatensystems.
     * @param	s  Beschriftung der Y-Achse.
     */
    public void setYAxisName(String s) {
        this.yAxisName = s;
    }

    /**
     * Setzt die Beschriftung der Z-Achse des Koordinatensystems.
     * @param	z  Beschriftung der Z-Achse.
     */
    public void setZAxisName(String s) {
        this.zAxisName = s;
    }
    //
    // Paint Methods
    //

    /**
     * Zeichnet die Raster dieses Koordinatensystems.
     * @param	g	der Grafikkontext in dem das Koordinatensystem gezeichnet werden soll.
     */
    private void drawGrid(int id, Graphics g) {
        FLGPoint p1 = (FLGPoint)pointPool.getNewObject();
        FLGPoint p2 = (FLGPoint)pointPool.getNewObject();
        if (id == XY_GRID) {
            for (int t = 1; t <= noGridSections; t++) {
                double areaPos = t * axisLength / noGridSections;
                calcPoint(areaPos, 0, 0, p1);
                calcPoint(areaPos, axisLength, 0, p2);
                g.drawLine((int)p1.x, (int)p1.y, (int)p2.x, (int)p2.y);
            }
            for (int t = 1; t <= noGridSections; t++) {
                double areaPos = t * axisLength / noGridSections;
                calcPoint(0, areaPos, 0, p1);
                calcPoint(axisLength, areaPos, 0, p2);
                g.drawLine((int)p1.x, (int)p1.y, (int)p2.x, (int)p2.y);
            }
        }
        else if (id == YZ_GRID) {
            for (int t = 1; t <= noGridSections; t++) {
                double areaPos = t * axisLength / noGridSections;
                calcPoint(0, 0, areaPos, p1);
                calcPoint(0, axisLength, areaPos, p2);
                g.drawLine((int)p1.x, (int)p1.y, (int)p2.x, (int)p2.y);
            }
            for (int t = 1; t <= noGridSections; t++) {
                double areaPos = t * axisLength / noGridSections;
                calcPoint(0, areaPos, 0, p1);
                calcPoint(0, areaPos, axisLength, p2);
                g.drawLine((int)p1.x, (int)p1.y, (int)p2.x, (int)p2.y);
            }
        }
        else {
            for (int t = 1; t <= noGridSections; t++) {
                double areaPos = t * axisLength / noGridSections;
                calcPoint(areaPos, 0, 0, p1);
                calcPoint(areaPos, 0, axisLength, p2);
                g.drawLine((int)p1.x, (int)p1.y, (int)p2.x, (int)p2.y);
            }
            for (int t = 1; t <= noGridSections; t++) {
                double areaPos = t * axisLength / noGridSections;
                calcPoint(0, 0, areaPos, p1);
                calcPoint(axisLength, 0, areaPos, p2);
                g.drawLine((int)p1.x, (int)p1.y, (int)p2.x, (int)p2.y);
            }
        }
        pointPool.releaseObject(p1);
        pointPool.releaseObject(p2);
    }

    /**
     * Zeichnet den Hintergrund des Koordinatensystems.
     * @param	g	der Grafikkontext in dem das Koordinatensystem gezeichnet werden soll.
     */
    public void paintBack(Graphics g) {
        if (firstPaint) whenFirstPainted(g);
        trOrigPoint.x = 0;
        trOrigPoint.y = 0;
        trOrigPoint.z = 0;
        transformPoint(trOrigPoint, rotPnt);
        calctNormVector(normVectorXY, tNormVectorXY);
        calctNormVector(normVectorYZ, tNormVectorYZ);
        calctNormVector(normVectorXZ, tNormVectorXZ);
        // calculate transformed viewpoint
        FLGPoint point = (FLGPoint)pointPool.getNewObject();
        point.x = viewPoint.x - addX;
        point.y = viewPoint.y - addY;
        point.z = viewPoint.z - addZ;
        transformPointBack(point, rotPnt);
        tViewPoint.x = point.x;
        tViewPoint.y = point.y;
        tViewPoint.z = point.z;
        pointPool.releaseObject(point);
        double distXY = normVectorXY.x * tViewPoint.x + normVectorXY.y * tViewPoint.y + normVectorXY.z * tViewPoint.z;
        double distYZ = normVectorYZ.x * tViewPoint.x + normVectorYZ.y * tViewPoint.y + normVectorYZ.z * tViewPoint.z;
        double distXZ = normVectorXZ.x * tViewPoint.x + normVectorXZ.y * tViewPoint.y + normVectorXZ.z * tViewPoint.z;
        paintXAxis = true;
        paintYAxis = true;
        paintZAxis = true;
        paintXYGrid = true;
        paintYZGrid = true;
        paintXZGrid = true;
        if (distXY > 0) {
            g.setColor(Color.black);
            drawAxis(X_AXIS, g);
            paintXAxis = false;
            drawAxis(Y_AXIS, g);
            paintYAxis = false;
            g.setColor(Color.gray);
            drawGrid(XY_GRID, g);
            paintXYGrid = false;
        }
        if (distYZ > 0) {
            g.setColor(Color.black);
            if (paintYAxis) {
                drawAxis(Y_AXIS, g);
                paintYAxis = false;
            }
            if (paintZAxis) {
                drawAxis(Z_AXIS, g);
                paintZAxis = false;
            }
            g.setColor(Color.gray);
            drawGrid(YZ_GRID, g);
            paintYZGrid = false;
        }
        if (distXZ > 0) {
            g.setColor(Color.black);
            if (paintXAxis) {
                drawAxis(X_AXIS, g);
                paintXAxis = false;
            }
            if (paintZAxis) {
                drawAxis(Z_AXIS, g);
                paintZAxis = false;
            }
            g.setColor(Color.gray);
            drawGrid(XZ_GRID, g);
            paintXZGrid = false;
        }
    }

    /**
     * Zeichnet den Vordergrund des Koordinatensystems.
     * @param	g	der Grafikkontext in dem das Koordinatensystem gezeichnet werden soll.
     */
    public void paintFront(Graphics g) {
        g.setColor(Color.black);
        if (paintXAxis) drawAxis(X_AXIS, g);
        if (paintYAxis) drawAxis(Y_AXIS, g);
        if (paintZAxis) drawAxis(Z_AXIS, g);
        g.setColor(Color.gray);
        if (paintXYGrid) drawGrid(XY_GRID, g);
        if (paintXZGrid) drawGrid(XZ_GRID, g);
        if (paintYZGrid) drawGrid(YZ_GRID, g);
        g.setColor(Color.black);
        drawAxisNumbers(X_AXIS, g);
        drawAxisNumbers(Y_AXIS, g);
        drawAxisNumbers(Z_AXIS, g);
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    // drawAxisNumbers
    ///////////////////////////////////////////////////////////////////////////////////////		
    private void drawAxisNumbers(int axis, Graphics g) {
        FLGPoint p1 = (FLGPoint)pointPool.getNewObject();
        FLGPoint axis2DStart = (FLGPoint)pointPool.getNewObject();
        FLGPoint axis2DStop = (FLGPoint)pointPool.getNewObject();
        int nInd = getAxisInd(axis);
        getAxis2DPoints(axis, nInd, axis2DStart, axis2DStop);
        double w = Math.abs(axis2DStop.x - axis2DStart.x);
        double h = Math.abs(axis2DStop.y - axis2DStart.y);
        double axis2DLength = Math.sqrt(w * w + h * h);
        FLGPoint labelDir = getLabelDir(axis, nInd);
        calculateAxisLabelsPos(axis, axis2DLength, w, h);
        double[] axisLabelsPos;
        int noAxisLabels;
        if (axis == X_AXIS) { noAxisLabels = noXAxisLabels; }
        else if (axis == Y_AXIS) { noAxisLabels = noYAxisLabels; }
        else { noAxisLabels = noZAxisLabels; }
        for (int t = 0; t < noAxisLabels; t++) {
            String fctPosString;
            if (axis == X_AXIS) {
                double areaPosX = (xAxisLabelsPos[t] - fgMinX) / (fgMaxX - fgMinX) * axisLength;
                if (nInd == 1) { calcPoint(areaPosX, 0, 0, p1); }
                if (nInd == 2) { calcPoint(areaPosX, 0, axisLength, p1); }
                if (nInd == 3) { calcPoint(areaPosX, axisLength, 0, p1); }
                fctPosString = createString(xAxisLabelsPos[t]);
            }
            else if (axis == Y_AXIS) {
                double areaPosY = (yAxisLabelsPos[t] - fgMinY) / (fgMaxY - fgMinY) * axisLength;
                if (nInd == 1) { calcPoint(0, areaPosY, 0, p1); }
                if (nInd == 2) { calcPoint(axisLength, areaPosY, 0, p1); }
                if (nInd == 3) { calcPoint(0, areaPosY, axisLength, p1); }
                fctPosString = createString(yAxisLabelsPos[t]);
            }
            else {
                double areaPosZ = (zAxisLabelsPos[t] - fgMinZ) / (fgMaxZ - fgMinZ) * axisLength;
                if (nInd == 1) { calcPoint(0, 0, areaPosZ, p1); }
                if (nInd == 2) { calcPoint(axisLength, 0, areaPosZ, p1); }
                if (nInd == 3) { calcPoint(0, axisLength, areaPosZ, p1); }
                fctPosString = createString(zAxisLabelsPos[t]);
            }
            int labelWidth = fm.stringWidth(fctPosString);
            int labelHeight = fontHeight;
            int addX = -(labelWidth / 2) + (int)((labelDir.x * labelWidth) / 2) + (int)(labelDir.x * 10);
            int addY = fontAscent - (labelHeight / 2) + (int)((labelDir.y * labelHeight) / 2) + (int)(labelDir.y * 10);
            g.drawLine((int)p1.x, (int)p1.y, (int)p1.x + (int)(labelDir.x * 8), (int)p1.y + (int)(labelDir.y * 8));
            g.drawString(fctPosString, (int)(p1.x + addX), (int)(p1.y + addY));
        }
        pointPool.releaseObject(p1);
        pointPool.releaseObject(labelDir);
        pointPool.releaseObject(axis2DStart);
        pointPool.releaseObject(axis2DStop);
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    // drawAxis
    ///////////////////////////////////////////////////////////////////////////////////////		
    private void drawAxis(int axis, Graphics g) {
        FLGPoint p1 = (FLGPoint)pointPool.getNewObject();
        FLGPoint p2 = (FLGPoint)pointPool.getNewObject();
        String label;
        if (axis == X_AXIS) {
            calcPoint(0, 0, 0, p1);
            calcPoint(axisLength, 0, 0, p2);
            label = xAxisName;
        }
        else if (axis == Y_AXIS) {
            calcPoint(0, 0, 0, p1);
            calcPoint(0, axisLength, 0, p2);
            label = yAxisName;
        }
        else {
            calcPoint(0, 0, 0, p1);
            calcPoint(0, 0, axisLength, p2);
            label = zAxisName;
        }
        double dx = p2.x - p1.x;
        double dy = p2.y - p1.y;
        if ((dx == 0) && (dy == 0)) {
            dx = 1;
            dy = 1;
        }
        double l = Math.sqrt(dx * dx + dy * dy);
        dx = dx / l;
        dy = dy / l;
        int lw = fm.stringWidth(label);
        int lh = fontHeight;
        double offsX = 20 * dx;
        double offsY = 20 * dy;
        g.drawLine((int)p1.x, (int)p1.y, (int)p2.x + (int)(0.75 * offsX), (int)p2.y + (int)(0.75 * offsY));
        g.drawString(label, (int)p2.x + (int)offsX - (lw / 2) + (int)(lw * dx / 2d),
            (int)p2.y + (int)offsY + (lh / 2) + (int)(lh * dy / 2d));
        pointPool.releaseObject(p1);
        pointPool.releaseObject(p2);
    }

    //
    // Support Methods
    //
    private void whenFirstPainted(Graphics g) {
        firstPaint = false;
        fm = g.getFontMetrics();
        fontAscent = fm.getAscent();
        fontHeight = fontAscent + fm.getDescent();
        // Berechne maxXLabelWidth
        int w1 = fm.stringWidth(createString(fgRdMinX) + ".99");
        int w2 = fm.stringWidth(createString(fgRdMaxX) + ".99");
        if (w1 > w2) maxXLabelWidth = w1;
        else
            maxXLabelWidth = w2;
        // Berechne maxYLabelWidth
        w1 = fm.stringWidth(createString(fgRdMinY) + ".99");
        w2 = fm.stringWidth(createString(fgRdMaxY) + ".99");
        if (w1 > w2) maxYLabelWidth = w1;
        else
            maxYLabelWidth = w2;
        // Berechne maxZLabelWidth
        w1 = fm.stringWidth(createString(fgRdMinZ) + ".99");
        w2 = fm.stringWidth(createString(fgRdMaxZ) + ".99");
        if (w1 > w2) maxZLabelWidth = w1;
        else
            maxZLabelWidth = w2;
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    // 3D transformation (normally rotation)
    ///////////////////////////////////////////////////////////////////////////////////////		
    private void transformPoint(FLGPoint point, FLGPoint rotPnt) {
        double x, y, z;
        x = point.x;
        y = point.y;
        z = point.z;
        x -= rotPnt.x;
        y -= rotPnt.y;
        z -= rotPnt.z;
        point.x = trMatrix[0] [0] * x + trMatrix[0] [1] * y + trMatrix[0] [2] * z;
        point.y = trMatrix[1] [0] * x + trMatrix[1] [1] * y + trMatrix[1] [2] * z;
        point.z = trMatrix[2] [0] * x + trMatrix[2] [1] * y + trMatrix[2] [2] * z;
        point.x += rotPnt.x;
        point.y += rotPnt.y;
        point.z += rotPnt.z;
    }

    private final void transformPointBack(FLGPoint point, FLGPoint rotPnt) {
        double x, y, z;
        x = point.x;
        y = point.y;
        z = point.z;
        x -= rotPnt.x;
        y -= rotPnt.y;
        z -= rotPnt.z;
        point.x = trMatrix[0] [0] * x + trMatrix[1] [0] * y + trMatrix[2] [0] * z;
        point.y = trMatrix[0] [1] * x + trMatrix[1] [1] * y + trMatrix[2] [1] * z;
        point.z = trMatrix[0] [2] * x + trMatrix[1] [2] * y + trMatrix[2] [2] * z;
        point.x += rotPnt.x;
        point.y += rotPnt.y;
        point.z += rotPnt.z;
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    // 3D to 2D transformation routines
    ///////////////////////////////////////////////////////////////////////////////////////		
    private double projectXCoord(double x, double z) {
        return world3D.getScaleFactor() * (viewPoint.z * x) / (viewPoint.z - z) + world3D.getDisplayAreaOffsX();
    }

    private double projectYCoord(double y, double z) {
        return world3D.getScaleFactor() * -((viewPoint.z * y) / (viewPoint.z - z)) + world3D.getDisplayAreaOffsY();
    }

    private void projPoint(double x, double y, double z, FLGPoint point2D) {
        point2D.x = projectXCoord(x + addX, z + addZ);
        point2D.y = projectYCoord(y + addY, z + addZ);
    }

    private void calcPoint(double px, double py, double pz, FLGPoint point2D) {
        FLGPoint point = (FLGPoint)pointPool.getNewObject();
        point.x = px;
        point.y = py;
        point.z = pz;
        transformPoint(point, rotPnt);
        projPoint(point.x, point.y, point.z, point2D);
        pointPool.releaseObject(point);
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    // calctNormVector
    ///////////////////////////////////////////////////////////////////////////////////////		
    private void calctNormVector(FLGPoint normVector, FLGPoint tNormVector) {
        FLGPoint point = (FLGPoint)pointPool.getNewObject();
        point.x = 0;
        point.y = 0;
        point.z = 0;
        tNormVector.x = normVector.x;
        tNormVector.y = normVector.y;
        tNormVector.z = normVector.z;
        transformPoint(tNormVector, point); // rotation-vector is here (0,0,0)
        pointPool.releaseObject(point);
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    // rotatePointZ
    ///////////////////////////////////////////////////////////////////////////////////////		
    private final double rotatePointZ(double x, double y, double z, FLGPoint rotPnt) {
        x -= rotPnt.x;
        y -= rotPnt.y;
        z -= rotPnt.z;
        return trMatrix[2] [0] * x + trMatrix[2] [1] * y + trMatrix[2] [2] * z + rotPnt.z;
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    // getAxisInd
    ///////////////////////////////////////////////////////////////////////////////////////		
    private int getAxisInd(int axis) {
        double z1 = 0, z2 = 0, z3 = 0, nz;
        int nInd;
        if (axis == X_AXIS) {
            z1 = rotatePointZ(axisLength / 2, 0, 0, rotPnt);
            z2 = rotatePointZ(axisLength / 2, 0, axisLength / 2, rotPnt); // --> z
            z3 = rotatePointZ(axisLength / 2, axisLength / 2, 0, rotPnt); // --> y
        }
        else if (axis == Y_AXIS) {
            z1 = rotatePointZ(0, axisLength / 2, 0, rotPnt);
            z2 = rotatePointZ(axisLength / 2, axisLength / 2, 0, rotPnt); // --> x
            z3 = rotatePointZ(0, axisLength / 2, axisLength / 2, rotPnt); // --> z
        }
        else if (axis == Z_AXIS) {
            z1 = rotatePointZ(0, 0, axisLength / 2, rotPnt);
            z2 = rotatePointZ(axisLength / 2, 0, axisLength / 2, rotPnt); // --> x
            z3 = rotatePointZ(0, axisLength / 2, axisLength / 2, rotPnt); // --> y
        }
        nInd = 1;
        nz = z1;
        if (z2 > z1) {
            nInd = 2;
            nz = z2;
        }
        if (z3 > nz) { nInd = 3; }
        return nInd;
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    // getAxis2DPoints
    ///////////////////////////////////////////////////////////////////////////////////////		
    private void getAxis2DPoints(int axis, int nInd, FLGPoint start, FLGPoint end) {
        if (axis == X_AXIS) {
            if (nInd == 1) {
                calcPoint(0, 0, 0, start);
                calcPoint(axisLength, 0, 0, end);
            }
            else if (nInd == 2) {
                calcPoint(0, 0, axisLength, start);
                calcPoint(axisLength, 0, axisLength, end);
            }
            else if (nInd == 3) {
                calcPoint(0, axisLength, 0, start);
                calcPoint(axisLength, axisLength, 0, end);
            }
        }
        if (axis == Y_AXIS) {
            if (nInd == 1) {
                calcPoint(0, 0, 0, start);
                calcPoint(0, axisLength, 0, end);
            }
            else if (nInd == 2) {
                calcPoint(axisLength, 0, 0, start);
                calcPoint(axisLength, axisLength, 0, end);
            }
            else if (nInd == 3) {
                calcPoint(0, 0, axisLength, start);
                calcPoint(0, axisLength, axisLength, end);
            }
        }
        if (axis == Z_AXIS) {
            if (nInd == 1) {
                calcPoint(0, 0, 0, start);
                calcPoint(0, 0, axisLength, end);
            }
            else if (nInd == 2) {
                calcPoint(axisLength, 0, 0, start);
                calcPoint(axisLength, 0, axisLength, end);
            }
            else if (nInd == 3) {
                calcPoint(0, axisLength, 0, start);
                calcPoint(0, axisLength, axisLength, end);
            }
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    // getLabelDir
    ///////////////////////////////////////////////////////////////////////////////////////		
    private FLGPoint getLabelDir(int axis, int nInd) {
        double dx = 0, dy = 0;
        double dist1, dist2;
        double l;
        FLGPoint p1 = (FLGPoint)pointPool.getNewObject();
        FLGPoint p2 = (FLGPoint)pointPool.getNewObject();
        FLGPoint p3 = (FLGPoint)pointPool.getNewObject();
        FLGPoint p4 = (FLGPoint)pointPool.getNewObject();
        FLGPoint dir = (FLGPoint)pointPool.getNewObject();
        calcPoint(axisLength / 2, axisLength / 2, axisLength / 2, p3);
        getAxis2DPoints(axis, nInd, p1, p2);
        p4.x = p2.x - p1.x;
        p4.y = p2.y - p1.y;
        if ((p4.x == 0) && (p4.y == 0)) // hier ist die Achse eigentlich nicht sichtbar
                p4.x = 1;
        l = Math.sqrt(p4.x * p4.x + p4.y * p4.y);
        axis2DLength = l;
        dx = p4.y / l;
        dy = -p4.x / l;
        dist1 = (p3.x - (p2.x + dx)) * (p3.x - (p2.x + dx)) + (p3.y - (p2.y + dy)) * (p3.y - (p2.y + dy));
        dist2 = (p3.x - (p2.x - dx)) * (p3.x - (p2.x - dx)) + (p3.y - (p2.y - dy)) * (p3.y - (p2.y - dy));
        if (dist2 > dist1) {
            dx = -dx;
            dy = -dy;
        }
        dir.x = dx;
        dir.y = dy;
        pointPool.releaseObject(p1);
        pointPool.releaseObject(p2);
        pointPool.releaseObject(p3);
        pointPool.releaseObject(p4);
        return dir;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	calcDecPos
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private int calcDecPos(double d) {
        int decPos = 0;
        if (d >= 1) {
            while (d > 1) {
                d /= 10f;
                decPos++;
            }
            decPos--;
        }
        else
            while (d < 1) {
                d *= 10f;
                decPos--;
            }
        return decPos;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	correctDouble
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private double correctDouble(double d, double range) {
        int genauigkeit = 3;
        int decPos = calcDecPos(range);
        if (decPos < 0) genauigkeit += -decPos;
        return Math.round(d * Math.pow(10d, genauigkeit)) / Math.pow(10d, genauigkeit);
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	calcFloor
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private double calcFloor(double d, int decPos) {
        double verySmall = 0.0001;
        double floor = Math.floor(verySmall + d * Math.pow(10d, (double) - decPos)) * Math.pow(10d, (double)decPos);
        return floor;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	calcCeil
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private double calcCeil(double d, int decPos) {
        double verySmall = 0.0001;
        double floor = Math.ceil(d * Math.pow(10d, (double) - decPos) - verySmall) * Math.pow(10d, (double)decPos);
        return floor;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	createString
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private String createString(double d) {
        String s = String.valueOf(d);
        int l = s.length();
        if (s.charAt(l - 2) == '.' && s.charAt(l - 1) == '0') s = s.substring(0, l - 2);
        return s;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	calculateAxisLabelsPos
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private void calculateAxisLabelsPos(int axis, double axis2DLength, double axis2DWidth, double axis2DHeight) {
        if (axis == X_AXIS) {
            noXAxisLabels = 0;
            double stepXSize = calcOptStepSize(X_AXIS, axis2DLength, axis2DWidth, axis2DHeight);
            for (double fctX = fgRdMinX; fctX <= fgRdMaxX; fctX += stepXSize) {
                fctX = correctDouble(fctX, fgRdMaxX - fgRdMinX);
                if (fgMinX <= fctX && fctX <= fgMaxX) xAxisLabelsPos[noXAxisLabels++] = fctX;
            }
        }
        else if (axis == Y_AXIS) {
            noYAxisLabels = 0;
            double stepYSize = calcOptStepSize(Y_AXIS, axis2DLength, axis2DWidth, axis2DHeight);
            for (double fctY = fgRdMinY; fctY <= fgRdMaxY; fctY += stepYSize) {
                fctY = correctDouble(fctY, fgRdMaxY - fgRdMinY);
                if (fgMinY <= fctY && fctY <= fgMaxY) yAxisLabelsPos[noYAxisLabels++] = fctY;
            }
        }
        else {
            noZAxisLabels = 0;
            double stepZSize = calcOptStepSize(Z_AXIS, axis2DLength, axis2DWidth, axis2DHeight);
            for (double fctZ = fgRdMinZ; fctZ <= fgRdMaxZ; fctZ += stepZSize) {
                fctZ = correctDouble(fctZ, fgRdMaxZ - fgRdMinZ);
                if (fgMinZ <= fctZ && fctZ <= fgMaxZ) zAxisLabelsPos[noZAxisLabels++] = fctZ;
            }
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	calcOptStepSize
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private double calcOptStepSize(int axis, double axis2DLength, double axis2DWidth, double axis2DHeight) {
        double[] sectionSizes = {40,20,10,5,4,2};
        double fgRdMinPos, fgRdMaxPos, fgMinPos, fgMaxPos;
        int maxLabelWidth;
        if (axis == X_AXIS) {
            fgRdMinPos = fgRdMinX;
            fgRdMaxPos = fgRdMaxX;
            fgMinPos = fgMinX;
            fgMaxPos = fgMaxX;
            maxLabelWidth = maxXLabelWidth;
        }
        else if (axis == Y_AXIS) {
            fgRdMinPos = fgRdMinY;
            fgRdMaxPos = fgRdMaxY;
            fgMinPos = fgMinY;
            fgMaxPos = fgMaxY;
            maxLabelWidth = maxYLabelWidth;
        }
        else {
            fgRdMinPos = fgRdMinZ;
            fgRdMaxPos = fgRdMaxZ;
            fgMinPos = fgMinZ;
            fgMaxPos = fgMaxZ;
            maxLabelWidth = maxZLabelWidth;
        }
        for (int s = 0; s < sectionSizes.length; s++) {
            double stepSize = (fgRdMaxPos - fgRdMinPos) / sectionSizes[s];
            int noLabelsInDomain = 0;
            for (double fctPos = fgRdMinPos; fctPos <= fgRdMaxPos; fctPos += stepSize)
                if (fgMinPos <= fctPos && fctPos <= fgMaxPos) noLabelsInDomain++;
            if (noLabelsInDomain <= MAX_NO_AXIS_LABELS) {
                if (noLabelsInDomain * fontHeight <= axis2DHeight) return stepSize;
                if (noLabelsInDomain * (maxLabelWidth + MIN_INTER_LABEL_DIST) <= axis2DWidth)
                    return stepSize;
            }
        }
        return (fgRdMaxPos - fgRdMinPos) / 2;
    }
}
