/* Generated by Freestyle Learning Group */

package freestyleLearningGroup.independent.plotter;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.JComponent;
import javax.swing.JFrame;

import freestyleLearningGroup.independent.gui.FLGBorderFactory;
import freestyleLearningGroup.independent.util.FLGBlackAndWhite;
import freestyleLearningGroup.independent.util.FLGGraphics;

/**
 * Stellt ein Balkendiagramm zur Verf&uuml;gung, in dem die einzelnen Balken aus gestapeltelten
 * Teilbalken bestehen.<p> In Erweiterung zu dem <code>FLGBarChart2D</code> wird ein Array von
 * Datengruppen benutzt, um die Daten dieses gestapelten Balkendiagrammes zu &uuml;bergeben. Dabei beschreibt eine
 * <code>FLGDataGroup2D</code> einen Teilbalken aller Balken. So k&ouml;nnte bspw. die erste Datengruppe die Tilgung in einem
 * betrachteten Zeitraum von 3 Jahren beschreiben und die zweite
 * Datengruppe die Zinsen in diesem Zeitraum bei konstanter Zahlungsh&ouml;he
 * (s. Beispiel 1).<p> Die Namen die in den Datenelementen der ersten Datengruppe definiert sind,
 * werden als x-Achsenbezeichnungen genutzt. Die Namen der folgenden Datengruppen werden
 * ignoriert, da sie f&uuml;r eine sinnvolle Datensituation gleich sein sollten.<p> Bei der
 * Definition der Datengruppen ist zu beachten, da&szlig; es m&ouml;glich
 * ist negative Werte anzugeben, aber dann auch alle Werte eines Balkens (und nicht(!) einer
 * Datengruppe) <i>negativ</i> sein m&uuml;ssen. Siehe dazu Beispiel 3.<p> Die f&uuml;r die
 * Teilbalken gew&uuml;nschten Farben m&uuml;ssen als <code>Color</code>-Array &uuml;bergeben werden.<p> Soll eine Legende zu
 * dem Balkendiagramm gezeichnet werden, m&uuml;ssen die Beschreibungen der Teilbalken als <code>String</code>-Array
 * angegeben werden. Dieses Array muss analog zu den Datengruppen im Datengruppen-Array geordnet
 * sein.<p> Sollen die Balken prozentual dargestellt werden, muss der Benutzer selbst daf&uuml;r
 * sorgen, dass die Summen der Balkenteile der Datengruppen jeweils den gleichen Wert ergeben, um
 * auf 100 Prozent zu kommen, falls dies gew&uuml;nscht wird. Die gr&ouml;sste Summe von Balkenteilen einer Datengruppe sind
 * 100 Prozent.<p> <p> <b>Beispiel 1</b>: Erzeugt das am Anfang beschriebene Balkendiagramm.<p> Die Werte werden nicht
 * in die Balkenst&uuml;cke geschrieben. Da das Zeichnen in schwarz-wei&szlig; eingeschaltet ist,
 * wird die Einstellung mit Farbverl&auml;fen zu f&uuml;llen ignoriert. <p><pre>
 *		FLGDataGroup2D[] data = new FLGDataGroup2D [2];
 *		
 *		data[0]= new FLGDataGroup2D();
 * 		data[0].add(new FLGData2D("1997", 3000));
 *		data[0].add(new FLGData2D("1998", 4000));
 *		data[0].add(new FLGData2D("1999", 5000));
 *		
 *		data[1]= new FLGDataGroup2D();
 *		data[1].add(new FLGData2D("egal", 7000));
 *		data[1].add(new FLGData2D("egal", 6000));
 *		data[1].add(new FLGData2D("egal", 5000));
 *
 *		Color[] farben = {Color.yellow, Color.lightGray};
 *		String[] namen = {"Tilgung", "Zinsen"};
 *
 * 		FLGBarChartPiled2D barchart = new FLGBarChartPiled2D(data, farben, namen, "Jahr", "GE");
 *		barchart.setPaintWithGradient(true);
 *		barchart.setBlackAndWhite(true);
 *
 *		<img src="../../../../../images/BarChartPiled2D.gif" width="600" height="400">
 * </pre><p> <p> <b>Beispiel 2</b>: Erzeugt ein Balkendiagramm, dass die Ausgaben der Jahre nach
 * verschiedenen Kostenarten prozentual aufschl&uuml;sselt.<p> Die Legende wird angezeigt, die
 * Balken werden mit Farbverl&auml;fen gef&uuml;llt und die Werte in die Balken geschrieben. <p><pre>
 *		FLGDataGroup2D[] data = new FLGDataGroup2D [4];
 *		
 *		data[0]= new FLGDataGroup2D();
 *		data[0].add(new FLGData2D("1997", 10));
 *		data[0].add(new FLGData2D("1998", 15));
 *		data[0].add(new FLGData2D("1999", 15));
 *		
 *		data[1]= new FLGDataGroup2D();
 *		data[1].add(new FLGData2D("egal", 30));
 *		data[1].add(new FLGData2D("egal", 30));
 *		data[1].add(new FLGData2D("egal", 25));
 *
 *		data[2]= new FLGDataGroup2D();
 *		data[2].add(new FLGData2D("egal", 20));
 *		data[2].add(new FLGData2D("egal", 25));
 *		data[2].add(new FLGData2D("egal", 20));
 *
 *		data[3]= new FLGDataGroup2D();
 *		data[3].add(new FLGData2D("egal", 40));
 *		data[3].add(new FLGData2D("egal", 30));
 *		data[3].add(new FLGData2D("egal", 40));
 *
 *		Color[] farben = {Color.yellow, Color.lightGray, Color.blue, Color.green};
 *		String[] namen = {"Studium", "Vergnügen", "Reisen", "Leben"};
 *
 *		FLGBarChartPiled2D barchart = new FLGBarChartPiled2D(data, farben, namen, "Jahr", "Ausgaben", false, true, true);
 *		barchart.setPaintWithGradient(true);
 *		barchart.setRelativeValues(true);
 *
 *		<img src="../../../../../images/BarChartPiled2D-2.gif" width="600" height="400">
 * </pre></p> <b>Beispiel 3</b>: Erzeugt ein Balkendiagramm, da&szlig; veranschaulicht wie
 * positive und negative Werte kombiniert werden k&ouml;nnen.<p> Nicht erlaubt w&auml;re es bspw.
 * alle Werte von <code>data[0]</code> negativ zu gestalten und die der Anderen positiv.<p> <p><pre>
 *		FLGDataGroup2D[] data = new FLGDataGroup2D [3];
 *		
 *		data[0]= new FLGDataGroup2D();
 *		data[0].add(new FLGData2D("1997", -1000));
 *		data[0].add(new FLGData2D("1998", 2000));
 *		data[0].add(new FLGData2D("1999", 4000));
 *		
 *		data[1]= new FLGDataGroup2D();
 *		data[1].add(new FLGData2D("egal", -1000));
 *		data[1].add(new FLGData2D("egal", 1000));
 *		data[1].add(new FLGData2D("egal", 1000));
 *
 *		data[2]= new FLGDataGroup2D();
 *		data[2].add(new FLGData2D("egal", -800));
 *		data[2].add(new FLGData2D("egal", 1800));
 *		data[2].add(new FLGData2D("egal", 2500));
 *
 *		Color[] farben = {Color.yellow, Color.lightGray, Color.blue};
 *		String[] namen = {"Teil 1", "Teil 2", "Teil 3"};
 *
 *		FLGBarChartPiled2D barchart = new FLGBarChartPiled2D(data, farben, namen, "Jahr", "Einheiten");
 *		barchart.setShowValues(true);
 *
 *		<img src="../../../../../images/BarChartPiled2D-3.gif" width="600" height="400">
 * </pre></p> Wird nicht mit der Methode <code>setMaxNoAxisLabels</code> eine maximale
 * Anzahl der <i>y</i>-Achsenbeschriftungen gesetzt, werden maximal <code>21</code>
 * <i>y</i>-Achsenbeschriftungen gesetzt. Bei zu kleiner Anzeigefl&auml;che wird die Anzahl der
 * Beschriftungen dynamisch reduziert.<p> Werden mit der Methode
 * <code>setYAxisLabelsPos</code> die <i>y</i>-Achsenbeschriftungen
 * vom Benutzer vorgegeben, werden Diese immer, unabh&auml;ngig von der Anzeigefl&auml;che benutzt.<p>
 * @see FLGData2D
 * @see FLGDataGroup2D
 */
public class FLGBarChartPiled2D extends JComponent implements FLGBlackAndWhite {
    //
    // Konstanten
    //
    private final static int AXIS_ARROWTOP_LENGTH = 12;
    private final static int AXIS_ARROWTOP_WIDTH = 12;
    private final static int AXISNAME_DIST_FROM_ARROW = 5;
    private final static int LABEL_DIST_FROM_AXIS = 3;
    private final static int MIN_INTER_LABEL_DIST = 3;
    private final static Color GRID_COLOR = new Color(196, 196, 196);
    private final static Color BG_COLOR = new Color(255, 255, 255);
    //
    // Variablen
    //

    /** @serial <i>y</i>-Achse automatisch beschriften? */
    private boolean automatedYAxisLabeling = true;

    /** @serial Schwarze Linien um Balken zeichnen? */
    private boolean drawBarBorders = false;

    /** @serial Maximale Anzahl der <i>y</i>-Achsenbeschriftungen. */
    private int maxNoAxisLabels = 21;

    /** @serial Die Breite des Balkens im Bezug auf die Fl&auml;che, die der Balken benutzen k&ouml;nnte. */
    private double relBarWidth = 0.5d;

    /** Die L&auml;nge der Pfeile an <i>x</i>- und <i>y</i>-Achse.. */
    private transient int axis_arrow_totallength = 24;

    /** @serial Die Standardfarbe f&uuml;r Balken, deren Datenelement keine Farbe zugeordnet ist. */
    private Color defaultBarColor = Color.blue;

    /** @serial Die Datengruppen, die dieses Balkendiagramm ausmacht. */
    private FLGDataGroup2D[] dataGroups;

    /** @serial Min und Max der Datengruppe dieses Balkendiagrammes. */
    private double dgMinValue, dgMaxValue;

    /** @serial Gerundetes Min und Max der Datengruppe dieses Balkendiagrammes. */
    private double dgRdMinValue, dgRdMaxValue;

    /** @serial Die Farben der verschiedenen Datengruppen. */
    private Color[] groupColors;

    /** @serial	Die Namen der verschiedenen Datengruppen. */
    private String[] groupNames;

    /** @serial Komponente schwarz-weiss zeichnen? */
    private boolean bw = false;

    /** @serial Sollen die Balken mit ihren Werten beschriftet werden ? */
    private boolean writeValues = false;

    /** @serial	Sollen die Balkenwerte in % angegeben werden. */
    private boolean relativeValues = false;

    /** @serial Komponente mit Farbverl&auml;fen zeichnen? */
    private boolean gradient = false;

    /** Die R&auml;nder der Zeichnefl&auml;che. */
    private transient int leftMargin, rightMargin, topMargin, bottomMargin;

    /** Die Schrifteigenschaften. */
    private transient int fontHeight, fontAscent, maxXLabelWidth, maxYLabelWidth;

    /** Ist das Balkendiagramm bereits berechnet / initialisiert. */
    private transient boolean initialized = false;

    /** @serial Soll ein Grid gezeichnet werden ? */
    private boolean paintGrid = true;

    /** @serial Soll die Legende gezeichnet werden ? */
    private boolean showLegend = false;

    /** Die Breite der Legendenbox. */
    transient private Dimension legendBoxSize = new Dimension();

    /** @serial Beschriftung der <i>x</i>-Achse. */
    private String xAxisName = "Produktionsmenge";

    /** @serial Beschriftung der <i>y</i>-Achse. */
    private String yAxisName = "Preis";

    /** Die Breite der Achsenbeschriftungen. */
    private transient int xAxisNameWidth, yAxisNameWidth;
    private transient int xAxisEndWidth, yAxisEndHeight;

    /** @serial	Die <i>y</i>-Achsenbeschriftungen. */
    private double[] yAxisLabelsPos = new double[100];

    /** @serial Die Anzahl der <i>y</i>-Achsenbeschriftungen. */
    private int noYAxisLabels = 0;

    /**
     * Die Anzahl der ben&ouml;tigten Zeilen f&uuml;r die x-Achsen Labels. Ist die
     * Zeichenfl&auml;che kleiner als <b>ein</b> halbes Label, wird <code>xLabelRows<code> auf
     * <code>0</code> gesetzt und die x-Achsenbeschriftungen nicht mehr gezeichnet.
     */
    private transient int xLabelRows;
    private transient FontMetrics fm;
    //
    // Konstruktoren
    //

    /**
     * Erzeugt ein Balkendiagramm mit den spezifizierten Daten, Namen, Farben und mit den
     * spezifizierten <i>x</i>- und <i>y</i>-Achsenbeschriftungen.
     * @param	dataGroups	die Daten dieses Balkendiagramms.
     * @param groupColors	die Farben der Datengruppen.
     * @param groupNames	die Namen der Datengruppen.
     * @param	xAxisName		die Bezeichnung der <i>x</i>-Achse.
     * @param	yAxisName		die Bezeichnung der <i>y</i>-Achse.
     * @param	writeValues	sollen die Werte der Balken in sie hineingeschrieben werden ?
     * @param	relativeValues		sollen die Angaben prozentual erfolgen?
     * @param	showLegend			soll eine Legende angezeigt werden?
     */
    public FLGBarChartPiled2D(FLGDataGroup2D[] dataGroups, Color[] groupColors, String[] groupNames, String xAxisName,
        String yAxisName, boolean writeValues, boolean relativeValues, boolean showLegend) {
            setDataGroups(dataGroups);
            this.groupColors = groupColors;
            this.groupNames = groupNames;
            this.xAxisName = xAxisName;
            this.yAxisName = yAxisName;
            this.writeValues = writeValues;
            this.relativeValues = relativeValues;
            this.showLegend = showLegend;
            setBorder(FLGBorderFactory.emptyLoweredBevel10);
    }

    /**
     * Erzeugt ein Balkendiagramm ohne Legende und mit den spezifizierten Eigenschaften.
     * @param	dataGroups	die Daten dieses Balkendiagramms.
     * @param groupColors	die Farben der Datengruppen.
     * @param	xAxisName		die Bezeichnung der <i>x</i>-Achse.
     * @param	yAxisName		die Bezeichnung der <i>y</i>-Achse.
     * @param	writeValues	sollen die Werte der Balken in sie hineingeschrieben werden ?
     * @param	relativeValues		sollen die Angaben prozentual erfolgen?
     */
    public FLGBarChartPiled2D(FLGDataGroup2D[] dataGroups, Color[] groupColors, String xAxisName, String yAxisName,
        boolean writeValues, boolean relativeValues) {
            this(dataGroups, groupColors, null, xAxisName, yAxisName, writeValues, relativeValues, false);
    }

    /**
     * Erzeugt ein Balkendiagramm mit Legende und den spezifizierten Daten, Namen,
     * Farben und mit den spezifizierten <i>x</i>- und <i>y</i>-Achsenbeschriftungen.
     * @param	dataGroups	die Daten dieses Balkendiagramms.
     * @param groupColors	die Farben der Datengruppen.
     * @param groupNames	die Namen der Datengruppen.
     * @param	xAxisName		die Bezeichnung der <i>x</i>-Achse.
     * @param	yAxisName		die Bezeichnung der <i>y</i>-Achse.
     */
    public FLGBarChartPiled2D(FLGDataGroup2D[] dataGroups, Color[] groupColors, String[] groupNames,
        String xAxisName, String yAxisName) {
            setDataGroups(dataGroups);
            this.groupColors = groupColors;
            this.groupNames = groupNames;
            this.xAxisName = xAxisName;
            this.yAxisName = yAxisName;
            this.showLegend = true;
            setBorder(FLGBorderFactory.emptyLoweredBevel10);
    }

    /**
     * Erzeugt ein absolutes Balkendiagramm ohne Legende. Die Werte werden nicht in die Balkenteile geschrieben.
     * @param	dataGroups	die Daten dieses Balkendiagramms.
     * @param groupColors	die Farben der Datengruppen.
     * @param	xAxisName		die Bezeichnung der <i>x</i>-Achse.
     * @param	yAxisName		die Bezeichnung der <i>y</i>-Achse.
     */
    public FLGBarChartPiled2D(FLGDataGroup2D[] dataGroups, Color[] groupColors, String xAxisName, String yAxisName) {
        this(dataGroups, groupColors, null, xAxisName, yAxisName, false, false, false);
    }
    //
    // Methoden
    //

    /**
     * Setzt die Daten dieses Balkendiagrammes auf die spezifizierte <code>FLGDataGroup2D</code>-Objekte.
     * @param	dataGroups	die neuen Werte dieses Balkendiagrammes.
     * @see	FLGDataGroup2D
     */
    public void setDataGroups(FLGDataGroup2D[] dataGroups) {
        initialized = false;
        this.dataGroups = dataGroups;
        dgMinValue = Double.POSITIVE_INFINITY;
        dgMaxValue = Double.NEGATIVE_INFINITY;
        for (int dataNo = 0; dataNo < dataGroups[0].size(); dataNo++) {
            double sum = dataGroups[0].get(dataNo).getValue();
            for (int groupNo = 1; groupNo < dataGroups.length; groupNo++) {
                sum += dataGroups[groupNo].get(dataNo).getValue();
            }
            if (sum < dgMinValue) this.dgMinValue = sum;
            if (sum > dgMaxValue) this.dgMaxValue = sum;
        }
        if (dgMinValue > 0) dgMinValue = 0;
        if (dgMaxValue < 0) dgMaxValue = 0;
        double range = dgMaxValue - dgMinValue;
        this.dgMinValue = correctDouble(this.dgMinValue, range);
        this.dgMaxValue = correctDouble(this.dgMaxValue, range);
    }

    /**
     * Liefert die Daten dieses Balkendiagrammes.
     * @return die Daten dieses Tortendiagrammes.
     * @see	FLGDataGroup2D
     */
    public FLGDataGroup2D[] getDataGroups() {
        return dataGroups;
    }

    /**
     * Setzt die vom Balkendiagramm benutzten Farben und Bezeichnungen der Datengruppen neu.
     * @param groupColors   die neuen Farben der Datengruppen
     * @param groupNames    die neuen Namen der Datengruppen
     */
    public void setColorsAndNames(Color[] groupColors, String[] groupNames) {
        this.groupColors = groupColors;
        this.groupNames = groupNames;
    }

    /**
     * Setzt die maximale Anzahl der <i>y</i>-Achsenbeschriftungen auf den spezifizierten Wert.
     * Ist die Anzeigenfl&auml;che zu klein wird die Anzahl der Achsenbeschriftungen dynamisch reduziert.
     * @param	no	die maximale Anzahl der Achsenbeschriftungen.
     */
    public void setMaxNoAxisLabels(int no) {
        maxNoAxisLabels = no;
    }

    /**
     * Setzt die spezifizierten Werte als <i>y</i>-Achsenbeschriftungen. Diese Werte und nur diese
     * Werte werden dann unabh&auml;ngig von der Gr&ouml;sse der Anzeigefl&auml;che an der <i>y</i>-Achse angezeigt.
     * @param	yAxisLabelsPos	die Werte, die an der <i>y</i>-Achse angezeigt werden sollen.
     */
    public void setYAxisLabelsPos(double[] yAxisLabelsPos) {
        automatedYAxisLabeling = false;
        this.yAxisLabelsPos = yAxisLabelsPos;
        noYAxisLabels = yAxisLabelsPos.length;
    }

    /**
     * Schaltet das F&uuml;llen der Balkenst&uuml;cke mit Farbverläufen ein oder aus.
     * @param	gradient	<code>true</code>, wenn mit Farbverl&auml;fen gef&uuml;llt werden soll. Sonst <code> false</code>.
     */
    public void setPaintWithGradient(boolean gradient) {
        this.gradient = gradient;
        repaint();
    }

    /**
     * Bestimmt, ob die Balkenst&uuml;cke gerade mit Farbverl&auml;fen gef&uuml;llt werden, oder
     * nicht. Kann durch <code>setPaintWithGradient()</code> ein- und ausgeschaltet werden.
     * @return	<code>true</code>, wenn mit Farbverl&auml;fen gef&uuml;llt werden soll. Sonst <code>false</code>.
     * @see #setPaintWithGradient(boolean)
     */
    public boolean isPaintWithGradient() {
        return gradient;
    }

    /**
     * Schaltet das Schreiben der Werte in die Balkenst&uuml;cke ein bzw. aus.
     * @param	writeValues	sollen die Werte in die Balkenst&uuml;cke geschrieben werden?
     */
    public void setShowValues(boolean writeValues) {
        this.writeValues = writeValues;
    }

    /**
     * Bestimmt, ob die Werte der einzelnen Balkenst&uuml;cke in sie hineingeschrieben werden oder
     * nicht. Kann durch <code>setWriteValue()</code> ein- und ausgeschaltet werden.
     * @return	<code>true</code>, wenn Werte geschrieben werden. Sonst <code>false</code>.
     * @see #setShowValues(boolean)
     */
    public boolean isShowValues() {
        return writeValues;
    }

    /**
     * Schaltet das Anzeigen der Legende ein bzw. aus.
     * @param	showLegend	soll die Legende angezeigt werden?
     */
    public void setShowLegend(boolean showLegend) {
        this.showLegend = showLegend;
        initialized = false;
    }

    /**
     * Bestimmt, ob die Legende angezeigt wird oder nicht. Kann durch <code>setShowLegend()</code>
     * ein- und ausgeschaltet werden.
     * @return	<code>true</code>, wenn die Legende angezeigt wird. Sonst <code>false</code>.
     * @see #setShowLegend(boolean)
     */
    public boolean isShowLegend() {
        return showLegend;
    }

    /**
     * Schaltet das Angeben der Werte in Prozent ein bzw. aus. Wird das Angeben der Werte in
     * Prozent eingeschaltet, wird auch das Schreiben der Werte in die Tortenst&uuml;cke automatisch aktiviert.
     * @param	relativeValues	sollen die Werte in die Tortenst&uuml;cke geschrieben werden?
     */
    public void setRelativeValues(boolean relativeValues) {
        this.relativeValues = relativeValues;
        if (relativeValues) setShowValues(true);
    }

    /**
     * Bestimmt, ob die Werte der einzelnen Tortenst&uuml;cke in Prozent angegeben werden sollen
     * oder nicht. Kann durch <code>setRelativeValues()</code> ein- und ausgeschaltet werden.
     * @return	<code>true</code>, wenn Werte in Prozent angegeben werden. Sonst <code>false</code>.
     * @see #setRelativeValues(boolean)
     */
    public boolean isRelativeValues() {
        return relativeValues;
    }

    /**
     * Methode des Interfaces <code>FLGBlackAndWhite</code>. Spezifiziert, ob die Komponente
     * farbig oder in Graut&ouml;nen gezeichnet werden soll.
     * @param	bw	soll die Komponente schwarz-weiss gezeichnet werden?
     */
    public void setBlackAndWhite(boolean bw) {
        this.bw = bw;
    }

    /**
     * Bestimmt, ob das Balkendiagramm schwarz-wei&szlig; gezeichnet wird, oder nicht. Kann durch
     * <code>setBlackAndWhite()</code> ein- und ausgeschaltet werden.
     * @return	<code>true</code>, wenn schwarz-wei&szlig; gezeichnet wird. Sonst <code>false</code>.
     * @see #setBlackAndWhite(boolean)
     */
    public boolean isBlackAndWhite() {
        return bw;
    }

    /**
     * Bestimmt, ob um die farbigen Balken herum zusätzlich Linien gezeichnet werden sollen.
     * @param	drawBarBorders	sollen Balken gezeichnet werden?
     */
    public void setDrawBarBorders(boolean drawBarBorders) {
        this.drawBarBorders = drawBarBorders;
    }
    //
    // Paint Methods
    //

    /** Zeichnet dieses Balkendiagramm. */
    public void paint(Graphics g) {
        Graphics2D g2 = (Graphics2D)g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        super.paint(g);
        g.translate(getInsets().left, getInsets().top);
        init(g);
        int height = getBounds().height - getInsets().top - getInsets().bottom;
        int width = getBounds().width - getInsets().right - getInsets().left;
        calculateMargins(width, height);
        int areaWidth = width - leftMargin - rightMargin;
        int areaHeight = height - bottomMargin - topMargin;
        if (automatedYAxisLabeling) calculateYAxisLabelsPos(areaHeight);
        if (bw) g.setColor(Color.white); // schwarz weiss: weisser Hintergrund
        else
            g.setColor(BG_COLOR);
        g.fillRect(0, 0, width, height);
        if (paintGrid) {
            g.setColor(GRID_COLOR);
            paintGrid(g);
        }
        paintBars(g);
        g.setColor(FLGGraphics.standardOutlineColor);
        paintCoordSystem(g);
    }

    /** Zeichnet das Raster dieses Balkendiagrammes. */
    private void paintGrid(Graphics g) {
        int height = getBounds().height - getInsets().top - getInsets().bottom;
        int width = getBounds().width - getInsets().right - getInsets().left;
        int areaWidth = width - leftMargin - rightMargin;
        int areaHeight = height - bottomMargin - topMargin;
        g.drawRect(leftMargin, topMargin, areaWidth - 1, areaHeight - 1);
        for (int p = 0; p < noYAxisLabels; p++) {
            double fctY = yAxisLabelsPos[p];
            int areaPosY = areaHeight - 1 - (int)Math.round((fctY - dgMinValue) /
                (dgMaxValue - dgMinValue) * (areaHeight - 1));
            g.drawLine(leftMargin, areaPosY + topMargin, width - 1 - rightMargin, areaPosY + topMargin);
        }
    }

    /** Zeichnet das Koordinatensystem dieses Balkendiagrammes. */
    private void paintCoordSystem(Graphics g) {
        int height = getBounds().height - getInsets().top - getInsets().bottom;
        int width = getBounds().width - getInsets().right - getInsets().left;
        int areaWidth = width - leftMargin - rightMargin;
        int areaHeight = height - bottomMargin - topMargin;
        int x1, x2, y1, y2;
        int[] x = new int[3];
        int[] y = new int[3];
        Point xAxisEndPnt = new Point();
        Point yAxisEndPnt = new Point();
        int dirX = 1;
        int dirY = xAxisIsBottom() ? 1 : -1;
        // paint X-Axis-Line
        x1 = leftMargin;
        x2 = width - 1 - rightMargin;
        if (xAxisIsTotalTop()) {
            y1 = topMargin;
            y2 = y1;
        }
        else if (xAxisIsTotalBottom()) {
            y1 = height - 1 - bottomMargin;
            y2 = y1;
        }
        else {
            y1 = topMargin + areaHeight - 1 - (int)Math.round((-dgMinValue) / (dgMaxValue - dgMinValue) * (areaHeight - 1));
            y2 = y1;
        }
        xAxisEndPnt.x = x2;
        xAxisEndPnt.y = y2;
        g.drawLine(x1, y1, x2, y2);
        // paint X-Arrow
        x[0] = xAxisEndPnt.x + axis_arrow_totallength - 1;
        y[0] = xAxisEndPnt.y;
        x[1] = x[0] - (AXIS_ARROWTOP_LENGTH - 1);
        y[1] = y[0] - ((AXIS_ARROWTOP_WIDTH - 1) >> 1);
        x[2] = x[1];
        y[2] = y[0] + ((AXIS_ARROWTOP_WIDTH - 1) >> 1);
        g.drawLine(xAxisEndPnt.x, xAxisEndPnt.y, x[0] - 1, y[0]);
        g.fillPolygon(x, y, 3);
        // paint X-Name
        y1 = xAxisEndPnt.y - (fontHeight >> 1) + fontAscent;
        g.drawString(xAxisName, xAxisEndPnt.x + axis_arrow_totallength + AXISNAME_DIST_FROM_ARROW, y1);
        // paint Y-Axis-Line
        y1 = topMargin;
        y2 = height - 1 - bottomMargin;
        x1 = leftMargin;
        x2 = x1;
        g.drawLine(x1, y1, x2, y2);
        yAxisEndPnt.x = x1;
        yAxisEndPnt.y = y1;
        // paint Y-Arrow
        x[0] = yAxisEndPnt.x;
        y[0] = yAxisEndPnt.y - (axis_arrow_totallength - 1);
        x[1] = x[0] - ((AXIS_ARROWTOP_WIDTH - 1) >> 1);
        y[1] = y[0] + (AXIS_ARROWTOP_LENGTH - 1);
        x[2] = x[0] + ((AXIS_ARROWTOP_WIDTH - 1) >> 1);
        y[2] = y[1];
        g.drawLine(yAxisEndPnt.x, yAxisEndPnt.y, x[0], y[0] + 1);
        g.fillPolygon(x, y, 3);
        // paint Y-NAME
        x1 = yAxisEndPnt.x - (yAxisNameWidth >> 1);
        g.drawString(yAxisName, x1, yAxisEndPnt.y - axis_arrow_totallength - AXISNAME_DIST_FROM_ARROW -
            fontHeight + fontAscent);
        if (xLabelRows > 0) {
            // paint X-Axis Labels
            int noData = dataGroups[0].size();
            int yOffset; // für versetzte x-Labels.
            for (int d = 0; d < noData; d++) {
                String label = dataGroups[0].get(d).getName();
                int areaPosX = (int)((d + 0.5d) * ((areaWidth - 1) / (double)noData));
                // Den y Offset für dieses Label berechnen
                yOffset = (d % xLabelRows) * (LABEL_DIST_FROM_AXIS + fontHeight);
                g.drawLine(areaPosX + leftMargin, xAxisEndPnt.y, areaPosX + leftMargin,
                    xAxisEndPnt.y - dirY * LABEL_DIST_FROM_AXIS);
                int labelWidth = fm.stringWidth(label);
                // Die x-Achsenlabel werden jetzt abhängig von neg. od. pos. Werten
                // über oder unter der x-Achse geschrieben.
                if (dataGroups[0].get(d).getValue() > 0)
                    g.drawString(label, areaPosX + leftMargin - (labelWidth >> 1),
                        xAxisEndPnt.y + LABEL_DIST_FROM_AXIS + fontAscent + yOffset);
                else
                    g.drawString(label, areaPosX + leftMargin - (labelWidth >> 1),
                        xAxisEndPnt.y - LABEL_DIST_FROM_AXIS - fontHeight + fontAscent - yOffset);
            }
        }
        // paint Y-Axis Labels
        for (int p = 0; p < noYAxisLabels; p++) {
            double fctY = yAxisLabelsPos[p];
            int areaPosY = areaHeight - 1 - (int)Math.round((fctY - dgMinValue) /
                (dgMaxValue - dgMinValue) * (areaHeight - 1));
            g.drawLine(yAxisEndPnt.x, areaPosY + topMargin, yAxisEndPnt.x + dirX * LABEL_DIST_FROM_AXIS, areaPosY + topMargin);
            String label;
            // Wenn die Balken relativ dargestellt werden, muß die Skala von 0 bis 100 laufen.
            if (relativeValues) {
                double relY = fctY / dgMaxValue * 100;
                label = createString(Math.round(relY));
            }
            else
                label = createString(fctY);
            int labelWidth = fm.stringWidth(label);
            g.drawString(label, yAxisEndPnt.x - LABEL_DIST_FROM_AXIS - labelWidth,
                areaPosY + topMargin + fontAscent - (fontHeight >> 1));
        }
    }

    /** Zeichnet die Balken dieses Balkendiagrammes. */
    private void paintBars(Graphics g) {
        // Die Anzahl der Balken des Balkendiagrammes, da für alle gleich, wird die
        // erste Gruppe betrachtet.
        int noBars = dataGroups[0].size();
        // Der Graphic2D Kontext für Texture Filling
        Graphics2D g2 = (Graphics2D)g;
        // Die Höhe, die für das Balkendiagramm zur Verfügung steht.
        int height = getBounds().height - getInsets().top - getInsets().bottom;
        // Die Breite, die für das Balkendiagramm zur Verfügung steht.
        int width = getBounds().width - getInsets().right - getInsets().left;
        // Die Höhe, die für die Balken zur Verfügung steht.
        int areaHeight = height - bottomMargin - topMargin;
        // Die Breite, die für die Balken zur Verfügung steht.
        int areaWidth = width - leftMargin - rightMargin;
        // Die Breite, die ein Balken zur Verfügung hat.
        double barAreaWidth = (areaWidth - 1) / (double)noBars;
        // Die Breite eines Balkens.
        double barWidth = barAreaWidth * relBarWidth;
        // Die y-Koordinate der gezeichneten x-Achse.
        double xAxisYPos;
        if (xAxisIsTotalTop()) xAxisYPos = topMargin;
        else if (xAxisIsTotalBottom()) xAxisYPos = height - 1 - bottomMargin;
        else
            xAxisYPos = topMargin + areaHeight - 1 - Math.round((-dgMinValue) / (dgMaxValue - dgMinValue) * (areaHeight - 1));
        for (int b = 0; b < noBars; b++) {
            double areaPosX1 = (b + 0.5d) * barAreaWidth - 0.5d * barWidth + leftMargin;
            double areaPosX2 = areaPosX1 + barWidth;
            // Die Verschiebung um auf das vorherigen Balkenstück aufzusetzen.
            double yOffset = 0;
            // erster y Wert ist die y-Pos der x-Achse
            double areaPosY1 = xAxisYPos;
            // zweiter y-Wert wird für die Summe der Balkenstücke berechnet
            double sumBarValue = 0;
            for (int groupNo = 0; groupNo < dataGroups.length; groupNo++)
                sumBarValue += dataGroups[groupNo].get(b).getValue();
            double sumAreaPosY2 = topMargin + areaHeight - 1 -
                Math.round((sumBarValue - dgMinValue) / (dgMaxValue - dgMinValue) * (areaHeight - 1));
            for (int groupNo = 0; groupNo < dataGroups.length; groupNo++) {
                // Nimm das aktuelle Balkenteilstück...
                FLGData2D barData = dataGroups[groupNo].get(b);
                // ... und lies dessen Wert aus.
                double barValue = barData.getValue();
                // Bestimmt den zweiten y-Wert ausgehend von der y-Position bei Aufsummieren
                // der Balkenstücke und des Verhältnisses des Teilstücks zum Ganzen.
                double areaPosY2 = areaPosY1 - (areaPosY1 - sumAreaPosY2) * barValue / sumBarValue;
                // Die Höhe diese Balkenteilstückes.
                double barPieceHeight = Math.abs(areaPosY1 - areaPosY2);
                // Wenn der Wert positiv ist, muß die Verschiebung "nach oben" erfolgen.
                if (barValue >= 0) yOffset = -yOffset;
                // Erzeuge das Balkenstück.
                Rectangle2D.Double bar;
                Point2D.Double start, end;
                if (barValue >= 0) {
                    end = new Point2D.Double(areaPosX1, areaPosY2 + yOffset);
                    start = new Point2D.Double(areaPosX1 + areaPosX2 - areaPosX1, areaPosY2 + yOffset + barPieceHeight);
                    bar = new Rectangle2D.Double(areaPosX1, areaPosY2 + yOffset, areaPosX2 - areaPosX1, barPieceHeight);
                }
                else {
                    start = new Point2D.Double(areaPosX1, areaPosY1 + yOffset);
                    end = new Point2D.Double(areaPosX1 + areaPosX2 - areaPosX1, areaPosY1 + yOffset + barPieceHeight);
                    bar = new Rectangle2D.Double(areaPosX1, areaPosY1 + yOffset, areaPosX2 - areaPosX1, barPieceHeight);
                }
                // Zeichne das Balkenstück
                // setPaint in Abhängigkeit von den folgenden Einstellungen:
                // - hat das Datum eine zugewiesene Farbe
                // - soll in schwarz-weiß gezeichnet werden
                // - sollen Farbverläufe benutzt werden.
                //
                if (groupColors[groupNo] != null) { // Datum hat Farbe
                    if (bw) { // schwarz-weiss
                        if (FLGGraphics.isStandardColor(groupColors[groupNo]) > -1)
                            g2.setPaint(FLGGraphics.getTextureForStandardColor(groupColors[groupNo]));
                        else
                            g2.setPaint(FLGGraphics.getTexture(groupNo));
                    }
                    else { // bunt
                        if (gradient) // mit Farbverlauf
                                g2.setPaint(FLGGraphics.getGradient(groupColors[groupNo], start, end));
                        else // ohne Farbverlauf
                                g2.setPaint(groupColors[groupNo]);
                    }
                }
                else { // Datum ist keine Farbe zugewiesen
                    if (bw) { // schwarz-weiss
                        g2.setPaint(FLGGraphics.getTextureForStandardColor(FLGGraphics.getStandardColor(groupNo)));
                    }
                    else { // bunt
                        if (gradient) // mit Farbverlauf
                                g2.setPaint(FLGGraphics.getGradient(FLGGraphics.getStandardColor(groupNo), start, end));
                        else // ohne Farbverlauf
                                g2.setPaint(FLGGraphics.getStandardColor(groupNo));
                    }
                }
                g2.fill(bar);
                // Zeichne den Balkenrahmen.
                if (drawBarBorders) {
                    g2.setPaint(FLGGraphics.standardOutlineColor);
                    g2.draw(bar);
                }
                // Zeichne den Wert in den Balken.
                if (writeValues) {
                    String wert;
                    if (relativeValues) {
                        double relativeValue = 100 * barValue / dgMaxValue;
                        wert = createString(freestyleLearningGroup.independent.util.FLGMathExtension.roundDouble(relativeValue,
                            2)) + "%";
                    }
                    else
                        wert = createString(barValue);
                    int wertWidth = fm.stringWidth(wert);
                    int xPos = (int)(areaPosX1 + (areaPosX2 - areaPosX1) / 2 - wertWidth / 2);
                    int yPos;
                    if (barValue >= 0)
                        yPos = (int)(areaPosY2 + yOffset + barPieceHeight / 2 + fontHeight / 2);
                    else
                        yPos = (int)(areaPosY1 + yOffset + barPieceHeight / 2 + fontHeight / 2);
                    if (bw) { // wenn bw, dann hinter Text weiß machen.
                        g.setColor(Color.white);
                        g.fillRect(xPos - 1, yPos - (fontHeight + fontAscent) / 2, wertWidth + 2, fontHeight + 2);
                        g.setColor(Color.black);
                    }
                    else {
                        if (groupColors[groupNo] != null)
                            // Farbe ist spezifiziert: suche passende Textfarbe für diese Farbe
                                g2.setColor(FLGGraphics.getTextColorFor(groupColors[groupNo]));
                        else
                            // Farbe nicht spezifiziert: suche passende Textfarbe für den Index dieses Datums
                                g2.setColor(FLGGraphics.getTextColorFor(groupNo));
                    }
                    g.drawString(wert, xPos, yPos);
                }
                // Aktualisiere den y Offset.
                yOffset = Math.abs(yOffset) + barPieceHeight;
            }
        }
        // Zeichne die Legende.	
        if (showLegend) {
            Point legendBoxOffset = new Point();
            legendBoxOffset.x = width - legendBoxSize.width - 5;
            legendBoxOffset.y = topMargin;
            for (int groupNo = (dataGroups.length - 1); groupNo >= 0; groupNo--) {
                g2.setPaint(FLGGraphics.standardOutlineColor);
                g2.drawRect(legendBoxOffset.x, legendBoxOffset.y + 5, 10, 10);
                g2.drawString(groupNames[groupNo], legendBoxOffset.x + 15, legendBoxOffset.y + 15);
                if (groupColors[groupNo] != null) { // Datum hat Farbe
                    if (bw) { // schwarz-weiss
                        if (FLGGraphics.isStandardColor(groupColors[groupNo]) > -1)
                            g2.setPaint(FLGGraphics.getTextureForStandardColor(groupColors[groupNo]));
                        else
                            g2.setPaint(FLGGraphics.getTexture(groupNo));
                    }
                    else { // bunt
                        g2.setPaint(groupColors[groupNo]);
                    }
                }
                else { // Datum ist keine Farbe zugewiesen
                    if (bw) { // schwarz-weiss
                        g2.setPaint(FLGGraphics.getTextureForStandardColor(FLGGraphics.getStandardColor(groupNo)));
                    }
                    else { // bunt
                        g2.setPaint(FLGGraphics.getStandardColor(groupNo));
                    }
                }
                g2.fillRect(legendBoxOffset.x, legendBoxOffset.y + 5, 10, 10);
                legendBoxOffset.y += legendBoxSize.height;
            }
        }
    }
    //
    // Support Methods
    //

    /** Initialisiert dieses Balkendiagramm. */
    private void init(Graphics g) {
        if (!(initialized)) {
            initialized = true;
            fm = g.getFontMetrics();
            fontAscent = fm.getAscent();
            fontHeight = fontAscent + fm.getDescent();
            // Berechne dgRdMinValue und dgRdMaxValue
            int decPos = calcDecPos(dgMaxValue - dgMinValue);
            dgRdMinValue = calcFloor(dgMinValue, decPos);
            dgRdMaxValue = calcCeil(dgMaxValue, decPos);
            double range = dgRdMaxValue - dgRdMinValue;
            dgRdMinValue = correctDouble(dgRdMinValue, range);
            dgRdMaxValue = correctDouble(dgRdMaxValue, range);
            // Berechne maxXLabelWidth
            maxXLabelWidth = 0;
            for (int d = 0; d < dataGroups[0].size(); d++) {
                int w = fm.stringWidth(dataGroups[0].get(d).getName());
                if (w > maxXLabelWidth) maxXLabelWidth = w;
            }
            // Berechne maxYLabelWidth
            int w1 = fm.stringWidth(createString(dgRdMinValue) + ".99");
            int w2 = fm.stringWidth(createString(dgRdMaxValue) + ".99");
            if (w1 > w2) maxYLabelWidth = w1;
            else
                maxYLabelWidth = w2;
            // Berechne xAxisNameWidth, yAxisNameWidth, ...
            xAxisNameWidth = fm.stringWidth(xAxisName);
            yAxisNameWidth = fm.stringWidth(yAxisName);
            xAxisEndWidth = xAxisNameWidth + axis_arrow_totallength + AXISNAME_DIST_FROM_ARROW;
            yAxisEndHeight = fontHeight + axis_arrow_totallength + AXISNAME_DIST_FROM_ARROW;
            // Die Größe der Legendenbox wird festgelegt.
            if (showLegend) {
                int maxLegendTextWidth = 0;
                int legendTextWidth;
                for (int groupNo = 0; groupNo < dataGroups.length; groupNo++) {
                    legendTextWidth = fm.stringWidth(groupNames[groupNo]);
                    if (legendTextWidth > maxLegendTextWidth) maxLegendTextWidth = legendTextWidth;
                }
                legendBoxSize.width = maxLegendTextWidth + 20;
                legendBoxSize.height = fontHeight * 3 / 2;
            }
        }
    }

    /** Berechnet die R&auml;nder f&uuml;r die spezifizierte Zeichenfl&auml;chengr&ouml;sse. */
    private void calculateMargins(int width, int height) {
        if (showLegend) {
            rightMargin = xAxisEndWidth + legendBoxSize.width + 4 + 10;
        }
        else
            rightMargin = xAxisEndWidth;
        leftMargin = Math.max(yAxisNameWidth / 2, Math.max(maxXLabelWidth / 2, LABEL_DIST_FROM_AXIS + maxYLabelWidth));
        //AS: Berechnung Anzahl der ben&ouml;tigten Zeilen f&uuml;r die x-Achsen Labels.
        int areaWidth = width - leftMargin - rightMargin;
        if (dataGroups[0].size() * maxXLabelWidth <= areaWidth) xLabelRows = 1;
        else if (maxXLabelWidth / 2 > areaWidth) xLabelRows = 0;
        else
            xLabelRows = (int)Math.ceil((double)(maxXLabelWidth * dataGroups[0].size()) / areaWidth);
        if (xLabelRows > dataGroups[0].size()) xLabelRows = dataGroups[0].size();
        int xLabelHeight = xLabelRows * (fontHeight + LABEL_DIST_FROM_AXIS);
        topMargin = yAxisEndHeight;
        if (xAxisIsTop()) {
            bottomMargin = fontHeight >> 1;
            if (yAxisEndHeight < xLabelHeight) // evtl. top margin vergrössern.
                    topMargin = xLabelHeight;
        }
        else {
            if (xLabelRows > 0) bottomMargin = xLabelHeight;
            else
                bottomMargin = fontHeight >> 1;
            if (!(xAxisIsTotalBottom())) {
                int areaHeight = height - topMargin - bottomMargin;
                int yAreaPosXAxis = (int)(-dgMinValue / (dgMaxValue - dgMinValue) * (double)areaHeight);
                bottomMargin = Math.max(fontHeight >> 1, xLabelHeight - yAreaPosXAxis);
            }
        }
    }

    /** Berechnet die Positionen der <i>y</i>-Achsenbeschriftungen. */
    private void calculateYAxisLabelsPos(int areaHeight) {
        noYAxisLabels = 0;
        double stepYSize = calcOptYStepSize(areaHeight);
        for (double fctY = dgRdMinValue; fctY <= dgRdMaxValue; fctY += stepYSize) {
            fctY = correctDouble(fctY, dgRdMaxValue - dgRdMinValue);
            if (dgMinValue <= fctY && fctY <= dgMaxValue) yAxisLabelsPos[noYAxisLabels++] = fctY;
        }
    }

    /**
     * Korrigiert die Genauigkeit der spezifizierten <code>double</code>-Zahl <i>d</i>.
     * Normalerweise wird auf 3 Nachkommastellen gerundet. Liegt range zwischen 0.1 und 1, dann
     * wird auf 4 Stellen gerundet. Liegt range zwischen 0.01 und 0.1, dann wird auf 5 Stellen gerundet, etc.
     */
    private double correctDouble(double d, double range) {
        int genauigkeit = 3;
        int decPos = calcDecPos(range);
        if (decPos < 0) genauigkeit += -decPos;
        return Math.round(d * Math.pow(10d, genauigkeit)) / Math.pow(10d, genauigkeit);
    }

    /**
     * Berechnet die optimale Schrittweite der <i>y</i>-Achse f&uum;r die spezifizierte Anzeigeh&ouml;he.
     * @param	areaHeight	die Anzeigeh&ouml;he.
     * @return						die optimale Schrittweite.
     */
    private double calcOptYStepSize(int areaHeight) {
        double[] sectionSizes = {40,20,10,5,4,2};
        for (int s = 0; s < sectionSizes.length; s++) {
            double stepSize = (dgRdMaxValue - dgRdMinValue) / sectionSizes[s];
            int noLabelsInDomain = 0;
            for (double fctY = dgRdMinValue; fctY <= dgRdMaxValue; fctY += stepSize)
                if (dgMinValue <= fctY && fctY <= dgMaxValue) noLabelsInDomain++;
            if (fontHeight * noLabelsInDomain < areaHeight && noLabelsInDomain <= maxNoAxisLabels)
                return stepSize;
        }
        return (dgRdMaxValue - dgRdMinValue);
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	calcDecPos
    // 100 --> 2; 10 --> 1; 1 --> 0; 0 --> 0; 0.1 --> -1; 0.01 --> -2;
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private int calcDecPos(double d) {
        double absD = Math.abs(d);
        if (absD == 0) return 0;
        int decPos = 0;
        if (absD >= 1) {
            while (absD >= 0.999999999999) {
                absD /= 10f;
                decPos++;
            }
            decPos--;
        }
        else {
            while (absD <= 0.999999999999) {
                absD *= 10f;
                decPos--;
            }
        }
        return decPos;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	calcFloor
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private double calcFloor(double d, int decPos) {
        double verySmall = 0.0001;
        double floor = Math.floor(verySmall + d * Math.pow(10d, (double) - decPos)) * Math.pow(10d, (double)decPos);
        return floor;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	calcCeil
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private double calcCeil(double d, int decPos) {
        double verySmall = 0.0001;
        double floor = Math.ceil(d * Math.pow(10d, (double) - decPos) - verySmall) * Math.pow(10d, (double)decPos);
        return floor;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	createString
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private String createString(double d) {
        String s = String.valueOf(d);
        int l = s.length();
        if (s.charAt(l - 2) == '.' && s.charAt(l - 1) == '0') s = s.substring(0, l - 2);
        return s;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	axis position
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private boolean xAxisIsBottom() { return (dgMinValue + dgMaxValue) / 2 >= 0; }

    private boolean xAxisIsTop() { return (dgMinValue + dgMaxValue) / 2 < 0; }

    private boolean xAxisIsTotalBottom() { return dgMinValue >= 0; }

    private boolean xAxisIsTotalTop() { return dgMaxValue <= 0; }

    public static void main(String[] args) {
        JFrame frame = new JFrame("Beispiel 3");
        FLGDataGroup2D[] data = new FLGDataGroup2D[4];
        data[0] = new FLGDataGroup2D();
        data[0].add(new FLGData2D("1997", -1000));
        data[0].add(new FLGData2D("1998", 1000));
        data[0].add(new FLGData2D("1999", 4000));
        data[0].add(new FLGData2D("2000", 4000));
        data[0].add(new FLGData2D("2001", 3000));
        data[1] = new FLGDataGroup2D();
        data[1].add(new FLGData2D("egal", -1000));
        data[1].add(new FLGData2D("egal", 1000));
        data[1].add(new FLGData2D("egal", 1000));
        data[1].add(new FLGData2D("egal", 1000));
        data[1].add(new FLGData2D("egal", 1000));
        data[2] = new FLGDataGroup2D();
        data[2].add(new FLGData2D("egal", -800));
        data[2].add(new FLGData2D("egal", 1800));
        data[2].add(new FLGData2D("egal", 2500));
        data[2].add(new FLGData2D("egal", 1800));
        data[2].add(new FLGData2D("egal", 2500));
        data[3] = new FLGDataGroup2D();
        data[3].add(new FLGData2D("egal", -800));
        data[3].add(new FLGData2D("egal", 1800));
        data[3].add(new FLGData2D("egal", 2500));
        data[3].add(new FLGData2D("egal", 1800));
        data[3].add(new FLGData2D("egal", 2500));
        Color[] farben = {Color.yellow, Color.lightGray, Color.blue, Color.red};
        String[] namen = {"Teil 1", "Teil 2", "Teil 3", "Teil 4"};
        FLGBarChartPiled2D barchart = new FLGBarChartPiled2D(data, farben, namen, "Jahr", "Einheiten");
        barchart.setShowValues(true);
        barchart.setPaintWithGradient(true);
        frame.getContentPane().add(barchart);
        frame.setSize(600, 400);
        frame.setVisible(true);
    }
}
