/* Generated by Freestyle Learning Group */

package freestyleLearningGroup.independent.plotter;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.Point;
import java.util.Locale;
import java.util.ResourceBundle;
import java.util.Vector;

import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JLabel;

import freestyleLearningGroup.independent.gui.FLGBorderFactory;
import freestyleLearningGroup.independent.util.FLGGraphics;

/**
 * Stellt einen Plotter zur Verf&uuml;gung der sowohl Funktionen als auch Polygone zeichnen kann. <p>
 * Per default gibt der Plotter auch eine Legende aus, die eine textuelle Beschreibung der
 * Funktionen und/oder Polygone enth&auml;lt. Wird keine Legende gew&uuml;nscht, muss sie durch
 * <code>showLegend(false)</code> deaktiviert werden.<p> Sollen Polygone und Funktionen gezeichnet werden, ist darauf zu
 * achten, dass die Polygonen- und die Funktionengruppe in etwa denselben Wertebereich abdecken, da es sonst zu unsch&ouml;nen
 * Ergebnissen kommen kann. W&auml;re bspw. in Beispiel drei die Funktionsgruppe nur von 0 bis 4 definiert, w&uuml;rde der
 * negative Zeichenbereich nicht bis 1 gehen und die Sinuskurve &uuml;ber den Rand des Plotters gezeichnet. <p>
 * <b>Beispiel 1</b>: Erstellt einen reinen Funktionsplotter. Gezeichnet wird eine Sinus-Funktion. <p> <pre>
 *  FLGFunction2D functionA = new FLGFunction2D(Double.NEGATIVE_INFINITY,
 *                                            Double.POSITIVE_INFINITY,
 *																						"Sinus") {
 *    public double calculate(double x) {
 *      return Math.sin(x);
 *    }
 *  };
 *  functionA.setColor(Color.red);
 *
 *  FLGFunctionGroup2D functionGroup = new FLGFunctionGroup2D(-6.29, 6.29);
 *  functionGroup.addFunction(functionA);
 *
 *  FLGPlotter2D plotter = new FLGPlotter2D(functionGroup, null, "X-Achse", "Y-Achse");
 *
 *		<img src="../../../../../images/Plotter2D.gif" width="600" height="400">
 *  </pre> </p> <b>Beispiel 2</b>: Erzeugt einen reinen Polygon-Plotter. Hier wird die durchschn.
 * Kapitalbindung einer Investition dargestellt. <p> <pre>
 *  FLGPolygon2D polygonA = new FLGPolygon2D();
 *  polygonA.setColor(Color.red);
 *  polygonA.add(new FLGPoint2D(0,100000));
 *  polygonA.add(new FLGPoint2D(1,100000));		
 *  polygonA.add(new FLGPoint2D(1,80000));
 *  polygonA.add(new FLGPoint2D(2,80000));		
 *  polygonA.add(new FLGPoint2D(2,60000));
 *  polygonA.add(new FLGPoint2D(3,60000));		
 *  polygonA.add(new FLGPoint2D(3,40000));
 *  polygonA.add(new FLGPoint2D(4,40000));
 *  polygonA.add(new FLGPoint2D(4,0));
 *
 *  FLGPolygon2D polygonB = new FLGPolygon2D();
 *  polygonB.setColor(Color.blue);
 *  polygonB.add(new FLGPoint2D(0,20000));
 *  polygonB.add(new FLGPoint2D(4,20000));
 *
 *  FLGPolygonGroup2D polygonGroup = new FLGPolygonGroup2D();
 *  polygonGroup.add(polygonA);
 *  polygonGroup.add(polygonB);
 *
 *  FLGPlotter2D plotter = new FLGPlotter2D(polygonGroup, "Periode", "Kapitalbindung");
 *  plotter.setMaxNoYAxisLabels(11);
 *  double[] xAxisLabelsPos = {0, 1, 2, 3, 4 };
 *  plotter.setXAxisLabelsPos(xAxisLabelsPos);
 *  plotter.showLegend(false);
 *
 *		<img src="../../../../../images/Plotter2D-2.gif" width="600" height="400">
 *  </pre> </p> <b>Beispiel 3</b>:	Erstellt einen kombinierten Funktions- und Polygonplotter <p> <pre>
 *  FLGFunction2D functionA = new FLGFunction2D(Double.NEGATIVE_INFINITY,
 *                                            Double.POSITIVE_INFINITY,
 *																						"Sinus") {
 *    public double calculate(double x) {
 *      return Math.sin(x);
 *    }
 *  };
 *  functionA.setColor(Color.red);
 *
 *  FLGFunctionGroup2D functionGroup = new FLGFunctionGroup2D(-6.29, 6.29);
 *    functionGroup.addFunction(functionA);
 *
 *  FLGPolygon2D polygonA = new FLGPolygon2D("Obergrenze");
 *  polygonA.setColor(Color.blue);
 *  polygonA.add(new FLGPoint2D(-6.29,0.5));
 *  polygonA.add(new FLGPoint2D(6.29,0.5));
 *
 *  FLGPolygonGroup2D polygonGroup = new FLGPolygonGroup2D();
 *  polygonGroup.add(polygonA);
 *
 *  FLGPlotter2D plotter = new FLGPlotter2D(functionGroup, polygonGroup, "X-Achse", "Y-Achse");
 *
 *		<img src="../../../../../images/Plotter2D-3.gif" width="600" height="400">
 *  </pre> </p> <b>Beispiel 4</b>: Die Benutzung von <code>FLGGraphics</code>. <p> <pre>
 *	FLGPolygon2D polygonA = new FLGPolygon2D("Hirsch");
 *	polygonA.setColor(Color.red);
 *	polygonA.add(new FLGPoint2D(0,0));
 *	polygonA.add(new FLGPoint2D(3,0));
 *	polygonA.add(new FLGPoint2D(3,5000));
 *	polygonA.add(new FLGPoint2D(5,5000));
 *	polygonA.add(new FLGPoint2D(5,20000));
 *	polygonA.add(new FLGPoint2D(5,25000));
 *	polygonA.add(new FLGPoint2D(10,25000));
 *	polygonA.setStroke(FLGGraphics.getStroke(FLGGraphics.STROKE_DASHED));
 *	FLGPolygon2D polygonB = new FLGPolygon2D("Fuchs");
 *	polygonB.setColor(Color.blue);
 *	polygonB.add(new FLGPoint2D(0,10000));
 *	polygonB.add(new FLGPoint2D(10,10000));
 *	polygonB.setStroke(FLGGraphics.getStroke(FLGGraphics.STROKE_DASH_DOUBLE_DOTTED));
 *	FLGPolygonGroup2D polygonGroup = new FLGPolygonGroup2D();
 *	polygonGroup.add(polygonA);
 *	polygonGroup.add(polygonB);
 *	FLGPlotter2D plotter = new FLGPlotter2D(polygonGroup, "Periode", "Kapitalbindung");
 *	plotter.setMaxNoYAxisLabels(11);
 *
 *		<img src="../../../../../images/Plotter2D-4.gif" width="600" height="400">
 *  </pre> </p> Werden nicht mit der Methode <code>setMaxNoXAxisLabels</code> bzw.
 * <code>setMaxNoYAxisLabels</code> eine maximale Anzahl der Achsenbeschriftungen gesetzt, werden maximal <code>21</code>
 * Beschriftungen je Achse gesetzt. Bei zu kleiner Anzeigefl&auml;che wird die Anzahl der Beschriftungen dynamisch
 * reduziert.<p> Werden mit der Methode <code>setXAxisLabelsPos</code> die <i>x</i>-Achsenbeschriftungen bzw. mit
 * <code>setYAxisLabelsPos</code> die <i>y</i>-Achsenbeschriftungen
 * vom Benutzer vorgegeben, werden Diese immer, unabh&auml;ngig von der Anzeigefl&auml;che benutzt.<p>
 * @see	FLGFunction2D
 * @see	FLGFunctionGroup2D
 * @see	FLGPolygon2D
 * @see	FLGPolygonGroup2D
 */
public class FLGPlotter2D extends JComponent implements Runnable {
    //
    // Konstanten
    //
    private static final int AXIS_ARROWTOP_LENGTH = 12;
    private static final int AXIS_ARROWTOP_WIDTH = 12;
    private static final int AXISNAME_DIST_FROM_ARROW = 5;
    private static final int LABEL_DIST_FROM_AXIS = 3;
    private static final int MIN_INTER_LABEL_DIST = 3;
    private static final Color GRID_COLOR = new Color(196, 196, 196);
    private static final Color BG_COLOR = new Color(255, 255, 255);
    private static final Dimension PREFERRED_SIZE = new Dimension(500, 400);
    //
    // Variablen
    //

    /** Plotter, dessen Layout das Layout für diesen Plotter diktiert */
    private FLGPlotter2D referencePlotter = null;
    private Vector dependentPlotters = new Vector();
    private int alignmentMode = 0;
    private boolean leftAlignToReferencePlotter = false;
    private boolean rightAlignToReferencePlotter = false;
    private boolean topAlignToReferencePlotter = false;
    private boolean bottomAlignToReferencePlotter = false;

    /** Die Legende dieses Plotters. */
    private transient FLGLegend legend = null;

    /** @serial Soll eine Legende angezeigt werden ? */
    private boolean showLegend = true;

    /** Die x-Koordinate einer Legendennummer. */
    private transient int legendNumberX;

    /** Der Abstand zwischen den Legendennummern. */
    private transient int legendNumberDistance;

    /** @serial Die Nummer der als nächstes zu zeichnenden Legendnennummer. */
    private int legendNumber;

    /** @serial	Beschriftung der <i>x</i>-Achse automatisch ? */
    private boolean automatedXAxisLabeling = true;

    /** @serial	Beschriftung der <i>y</i>-Achse automatisch ? */
    private boolean automatedYAxisLabeling = true;

    /** Die L&auml;nge des Pfeils an <i>x</i>-Achse.. */
    private transient int xAxisArrowTotalLength = 24;

    /** Die L&auml;nge des Pfeils an <i>y</i>-Achse.. */
    private transient int yAxisArrowTotalLength = 24;

    /** @serial Maximale Anzahl der <i>x</i>-Achsenbeschriftungen. */
    private int maxNoXAxisLabels = 21;

    /** @serial Maximale Anzahl der <i>y</i>-Achsenbeschriftungen. */
    private int maxNoYAxisLabels = 21;

    /** @serial Mins und Maxs des Koordinatensystems. */
    private double csMinX, csMaxX, csMinY, csMaxY, absMaxY;

    /** @serial Gerundete Mins und Maxs des Koordinatensystems. */
    private double csRdMinX, csRdMinY, csRdMaxX, csRdMaxY;

    /** @serial Die Funktionengruppe dieses 2D-Plotters. */
    private FLGFunctionGroup2D functionGroup;

    /** @serial Die Polygonengruppe dieses 2D-Plotters. */
    private FLGPolygonGroup2D polygonGroup;

    /** @serial Die Component-Gruppe dieses 2D-Plotters. */
    private FLGComponentGroup2D componentGroup;

    /** Die R&auml;nder der Zeichnefl&auml;che. */
    private transient int leftMargin, rightMargin, topMargin, bottomMargin;

    /** Die Schrifteigenschaften. */
    private transient int fontHeight, fontAscent, maxXLabelWidth, maxYLabelWidth;
    private transient int maxXLabelHeight, maxYLabelHeight;

    /** Ist das Balkendiagramm bereits berechnet / initialisiert. */
    private transient boolean initialized = false;

    /** @serial Soll ein Grid gezeichnet werden ? */
    private boolean paintGrid = true;

    /** @serial Beschriftung der <i>x</i>-Achse. */
    private JLabel xAxisLabel;

    /** @serial Beschriftung der <i>y</i>-Achse. */
    private JLabel yAxisLabel;

    /** Die Breite der Achsenbeschriftungen. */
    private transient int xAxisNameWidth, yAxisNameWidth;
    private transient int yAxisNameHeight;
    private transient int xAxisEndWidth, yAxisEndHeight;

    /** @serial	Die <i>x</i>-Achsenbeschriftungen. */
    private double[] xAxisLabelsPos = new double[100];
    private JComponent[] xAxisLabels = new JComponent[100];

    /** @serial	Die <i>y</i>-Achsenbeschriftungen. */
    private double[] yAxisLabelsPos = new double[100];
    private JComponent[] yAxisLabels = new JComponent[100];

    /** @serial Die Anzahl der <i>x</i>-Achsenbeschriftungen. */
    private int noXAxisLabels = 0;

    /** @serial Die Anzahl der <i>y</i>-Achsenbeschriftungen. */
    private int noYAxisLabels = 0;
    private transient int[] scrXCoords = new int[4000];
    private transient int[] scrYCoords = new int[4000];
    private transient FontMetrics fm;
    private transient Thread runner = null;
    //
    // Konstruktoren
    //

    /**
     * Erzeugt einen 2D Plotter mit der spezifizierten Funktionsgruppe, der spezifizierten
     * Polygonengruppe und den spezifizierten Achsenbeschriftungen.
     * @param	functionGroup	die Funktionen dieses 2D Plotters.
     * @param	polygonGroup	die Polygone dieses 2D Plotters.
     * @param	xAxisName			die <i>x</i>-Achsenbezeichnung.
     * @param	yAxisName			die <i>y</i>-Achsenbezeichnung.
     */
    public FLGPlotter2D(FLGFunctionGroup2D functionGroup, FLGPolygonGroup2D polygonGroup, String xAxisName, String yAxisName) {
        setDataGroups(functionGroup, polygonGroup);
        this.xAxisLabel = new JLabel(xAxisName);
        this.xAxisLabel.setSize(this.xAxisLabel.getPreferredSize());
        this.yAxisLabel = new JLabel(yAxisName);
        this.yAxisLabel.setSize(this.yAxisLabel.getPreferredSize());
        setBorder(FLGBorderFactory.emptyLoweredBevel10);
    }

    /**
     * Erzeugt einen 2D Plotter mit der spezifizierten Funktionsgruppe und den
     * Standard-Achsenbeschriftungen <code>"x"</code> und <code>"y"</code>.
     * @param	functionGroup	die Funktionen dieses 2D Plotters.
     */
    public FLGPlotter2D(FLGFunctionGroup2D functionGroup) {
        this(functionGroup, null, "x", "y");
    }

    /**
     * Erzeugt einen 2D Plotter mit der spezifizierten Funktionsgruppe und den spezifizierten Achsenbeschriftungen.
     * @param	functionGroup	die Funktionen dieses 2D Plotters.
     * @param	xAxisName			die <i>x</i>-Achsenbezeichnung.
     * @param	yAxisName			die <i>y</i>-Achsenbezeichnung.
     */
    public FLGPlotter2D(FLGFunctionGroup2D functionGroup, String xAxisName, String yAxisName) {
        this(functionGroup, null, xAxisName, yAxisName);
    }

    /**
     * Erzeugt einen 2D Plotter mit der spezifizierten Polygonengruppe und den
     * Standard-Achsenbeschriftungen <code>"x"</code> und <code>"y"</code>.
     * @param	polygonGroup	die Polygone dieses 2D Plotters.
     */
    public FLGPlotter2D(FLGPolygonGroup2D polygonGroup) {
        this(null, polygonGroup, "x", "y");
    }

    /**
     * Erzeugt einen 2D Plotter mit der spezifizierten Polygonengruppe und den spezifizierten Achsenbeschriftungen.
     * @param	polygonGroup	die Polygone dieses 2D Plotters.
     * @param	xAxisName			die <i>x</i>-Achsenbezeichnung.
     * @param	yAxisName			die <i>y</i>-Achsenbezeichnung.
     */
    public FLGPlotter2D(FLGPolygonGroup2D polygonGroup, String xAxisName, String yAxisName) {
        this(null, polygonGroup, xAxisName, yAxisName);
    }

    //
    // Methoden
    //
    public void setReferencePlotter(FLGPlotter2D refPlotter, boolean left, boolean right, boolean top, boolean bottom) {
        this.referencePlotter = refPlotter;
        this.leftAlignToReferencePlotter = left;
        this.rightAlignToReferencePlotter = right;
        this.topAlignToReferencePlotter = top;
        this.bottomAlignToReferencePlotter = bottom;
        refPlotter.addDependentPlotter(this);
    }

    private void addDependentPlotter(FLGPlotter2D plotter) {
        dependentPlotters.add(plotter);
    }

    public void setComponentGroup(FLGComponentGroup2D componentGroup) {
        this.componentGroup = componentGroup;
    }

    /**
     * Setzt, ob eine Legende angezeigt werden soll oder nicht.
     * @param	showLegend	Legende anzeigen? Per default ja.
     */
    public void showLegend(boolean showLegend) {
        this.showLegend = showLegend;
    }

    /**
     * Setzt in diesem 2D Plotter die spezifizierten Funktionsgruppe und die spezifizierten
     * Polygonengruppe als neue Datenquelle.
     * @param	functionGroup	die neuen Funktionen dieses 2D Plotters.
     * @param	polygonGroup	die neuen Polygone dieses 2D Plotters.
     */
    public void setDataGroups(FLGFunctionGroup2D functionGroup, FLGPolygonGroup2D polygonGroup) {
        initialized = false;
        this.functionGroup = functionGroup;
        this.polygonGroup = polygonGroup;
        if ((functionGroup != null) && (polygonGroup != null)) {
            this.csMinX = Math.min(functionGroup.getMinX(), polygonGroup.getMinX());
            this.csMaxX = Math.max(functionGroup.getMaxX(), polygonGroup.getMaxX());
            this.csMinY = Math.min(functionGroup.getMinY(), polygonGroup.getMinY());
            this.csMaxY = Math.max(functionGroup.getMaxY(), polygonGroup.getMaxY());
        }
        else if (functionGroup != null) {
            this.csMinX = functionGroup.getMinX();
            this.csMaxX = functionGroup.getMaxX();
            this.csMinY = functionGroup.getMinY();
            this.csMaxY = functionGroup.getMaxY();
        }
        else if (polygonGroup != null) {
            this.csMinX = polygonGroup.getMinX();
            this.csMaxX = polygonGroup.getMaxX();
            this.csMinY = polygonGroup.getMinY();
            this.csMaxY = polygonGroup.getMaxY();
        }
        if (functionGroup != null || polygonGroup != null) {
            double range = csMaxX - csMinX;
            if (range == 0) {
                // Wenn minX und maxX = 0 sind, dann soll das Intervall von -10 bis 10 gehen
                if (csMaxX == 0) {
                    csMinX = -10;
                    csMaxX = 10;
                }
                else {
                    // wenn beide größer 0 sind, dann soll z.B. bei 3 das Intervall von 0 bis 10 gehen
                    if (csMaxX >= 0) {
                        csMinX = 0;
                        csMaxX = 10 * Math.pow(10d, calcDecPos(csMaxX));
                        // wenn beide kleiner 0 sind, dann soll z.B. bei -3 das Intervall von -10 bis 0 gehen
                    }
                    else {
                        csMinX = -10 * Math.pow(10d, calcDecPos(csMinX));
                        csMaxX = 0;
                    }
                }
                range = csMaxX - csMinX;
            }
            this.csMinX = correctDouble(this.csMinX, range);
            this.csMaxX = correctDouble(this.csMaxX, range);
            range = csMaxY - csMinY;
            if (range == 0) {
                if (csMaxY == 0) {
                    csMinY = -10;
                    csMaxY = 10;
                }
                else {
                    if (csMaxY >= 0) {
                        csMinY = 0;
                        csMaxY = 10 * Math.pow(10d, calcDecPos(csMaxY));
                    }
                    else {
                        csMinY = -10 * Math.pow(10d, calcDecPos(csMinY));
                        csMaxY = 0;
                    }
                }
                range = csMaxY - csMinY;
            }
            this.csMinY = correctDouble(this.csMinY, range);
            this.csMaxY = correctDouble(this.csMaxY, range);
        }
    }

    /**
     * Setzt in diesem 2D Plotter die spezifizierten Funktionsgruppe als neue Datenquelle.
     * @param	functionGroup	die neuen Funktionen dieses 2D Plotters.
     */
    public void setFunctionGroup(FLGFunctionGroup2D functionGroup) {
        setDataGroups(functionGroup, null);
    }

    /**
     * Setzt in diesem 2D Plotter die spezifizierten Polygonengruppe als neue Datenquelle.
     * @param	functionGroup	die neuen Funktionen dieses 2D Plotters.
     */
    public void setPolygonGroup(FLGPolygonGroup2D polygonGroup) {
        setDataGroups(null, polygonGroup);
    }

    /**
     * Setzt in diesem 2D Plotter die Beschriftung der x-Achse
     * @param	labelText	neuer Beschriftungstext
     */
    public void setXAxisLabel(String labelText) {
        this.xAxisLabel.setText(labelText);
    }
    
    /**
     * Setzt in diesem 2D Plotter die Beschriftung der x-Achse
     * @param	labelText	neuer Beschriftungstext
     */
    public void setYAxisLabel(String labelText) {
        this.yAxisLabel.setText(labelText);
    }
    
    /**
     * Setzt die maximale Anzahl der <i>x</i>-Achsenbeschriftungen auf den spezifizierten Wert.
     * Ist die Anzeigenfl&auml;che zu klein wird die Anzahl der Achsenbeschriftungen dynamisch reduziert.
     * @param	no	die maximale Anzahl der <i>x</i>-Achsenbeschriftungen.
     */
    public void setMaxNoXAxisLabels(int no) {
        maxNoXAxisLabels = no;
    }

    /**
     * Setzt die maximale Anzahl der <i>y</i>-Achsenbeschriftungen auf den spezifizierten Wert.
     * Ist die Anzeigenfl&auml;che zu klein wird die Anzahl der Achsenbeschriftungen dynamisch reduziert.
     * @param	no	die maximale Anzahl der <i>y</i>-Achsenbeschriftungen.
     */
    public void setMaxNoYAxisLabels(int no) {
        maxNoYAxisLabels = no;
    }

    /**
     * Setzt die spezifizierten Werte als <i>x</i>-Achsenbeschriftungen. Diese Werte und nur diese
     * Werte werden dann unabh&auml;ngig von der Gr&ouml;sse der Anzeigefl&auml;che an der <i>x</i>-Achse angezeigt.
     * @param	xAxisLabelsPos	die Werte, die an der <i>x</i>-Achse angezeigt werden sollen.
     */
    public void setXAxisLabelsPos(double[] xAxisLabelsPos) {
        xAxisLabels = new JComponent[xAxisLabelsPos.length];
        for (int i = 0; i < xAxisLabels.length; i++) {
            JLabel label = new JLabel(createString(xAxisLabelsPos[i]));
            label.setSize(label.getPreferredSize());
            xAxisLabels[i] = label;
        }
        setXAxisLabels(xAxisLabelsPos, xAxisLabels);
    }

    /**
     * Setzt die spezifizierten JComponents als <i>x</i>-Achsenbeschriftungen.
     * Diese Objekte und nur diese Objekte werden dann unabh&auml;ngig von der Gr&ouml;sse der
     * Anzeigefl&auml;che an der <i>x</i>-Achse angezeigt.
     * @param	xAxisLabelsPos	die x-Koordinaten, an der die JComponents angezeigt werden sollen.
     * @param	xAxisLabels			die JComponents.
     */
    public void setXAxisLabels(double[] xAxisLabelsPos, JComponent[] xAxisLabels) {
        automatedXAxisLabeling = false;
        this.xAxisLabelsPos = xAxisLabelsPos;
        noXAxisLabels = xAxisLabelsPos.length;
        this.xAxisLabels = xAxisLabels;
        for (int i = 0; i < noXAxisLabels; i++)
            xAxisLabels[i].setSize(xAxisLabels[i].getPreferredSize());
    }

    /**
     * Setzt die spezifizierten Werte als <i>y</i>-Achsenbeschriftungen. Diese Werte und nur diese
     * Werte werden dann unabh&auml;ngig von der Gr&ouml;sse der Anzeigefl&auml;che an der <i>y</i>-Achse angezeigt.
     * @param	yAxisLabelsPos	die Werte, die an der <i>y</i>-Achse angezeigt werden sollen.
     */
    public void setYAxisLabelsPos(double[] yAxisLabelsPos) {
        yAxisLabels = new JComponent[yAxisLabelsPos.length];
        for (int i = 0; i < yAxisLabels.length; i++) {
            JLabel label = new JLabel(createString(yAxisLabelsPos[i]));
            label.setSize(label.getPreferredSize());
            yAxisLabels[i] = label;
        }
        setYAxisLabels(yAxisLabelsPos, yAxisLabels);
    }

    /**
     * Setzt die spezifizierten JComponents als <i>y</i>-Achsenbeschriftungen.
     * Diese Objekte und nur diese Objekte werden dann unabh&auml;ngig von der Gr&ouml;sse der
     * Anzeigefl&auml;che an der <i>y</i>-Achse angezeigt.
     * @param	yAxisLabelsPos	die y-Koordinaten, an der die JComponents angezeigt werden sollen.
     * @param	yAxisLabels			die JComponents.
     */
    public void setYAxisLabels(double[] yAxisLabelsPos, JComponent[] yAxisLabels) {
        automatedYAxisLabeling = false;
        this.yAxisLabelsPos = yAxisLabelsPos;
        noYAxisLabels = yAxisLabelsPos.length;
        this.yAxisLabels = yAxisLabels;
        for (int i = 0; i < noYAxisLabels; i++)
            yAxisLabels[i].setSize(yAxisLabels[i].getPreferredSize());
    }
    //
    // Paint Methods
    //

    /** Zeichnet diesen 2D Plotter. */
    public void paint(Graphics g) {
        super.paint(g);
        g.translate(getInsets().left, getInsets().top);
        int height = getBounds().height - getInsets().top - getInsets().bottom;
        int width = getBounds().width - getInsets().right - getInsets().left;
        init(g);
        calculateMargins(width, height);
        int areaWidth = width - leftMargin - rightMargin;
        int areaHeight = height - bottomMargin - topMargin;
        if (automatedXAxisLabeling) createXAxisLabels(areaWidth);
        if (automatedYAxisLabeling) createYAxisLabels(areaHeight);
        g.setColor(BG_COLOR);
        g.fillRect(0, 0, width, height);
        if (paintGrid) {
            g.setColor(GRID_COLOR);
            paintGrid(g);
        }
        g.setColor(Color.black);
        paintCoordSystem(g);
        if (functionGroup != null) paintFunctions(g);
        if (polygonGroup != null) paintPolygons(g);
        if (componentGroup != null) paintComponents2D(g);
        // AS: Legende zeichnen
        if (showLegend) {
            legend.paint(g, width - legend.getPreferredSize().width, topMargin);
        }
    }

    private void paintComponents2D(Graphics g) {
        int height = getBounds().height - getInsets().top - getInsets().bottom;
        int width = getBounds().width - getInsets().right - getInsets().left;
        int areaWidth = width - leftMargin - rightMargin;
        int areaHeight = height - bottomMargin - topMargin;
        for (int i = 0; i < componentGroup.size(); i++) {
            FLGComponent2D component2D = componentGroup.get(i);
            JComponent component = component2D.getComponent();
            component.setSize(component.getPreferredSize());
            double fctX = component2D.getPosX();
            double fctY = component2D.getPosY();
            int areaPosX = (int)Math.round((fctX - csMinX) / (csMaxX - csMinX) * (areaWidth - 1));
            int areaPosY = areaHeight - 1 - (int)Math.round((fctY - csMinY) / (csMaxY - csMinY) * (areaHeight - 1));
            areaPosX += leftMargin;
            areaPosY += topMargin;
            // Ausrichtungen berücksichtigen
            if (component2D.getHorizontalAlignment() == FLGComponent2D.CENTER)
                areaPosX -= component.getSize().width / 2;
            if (component2D.getHorizontalAlignment() == FLGComponent2D.RIGHT)
                areaPosX -= component.getSize().width;
            if (component2D.getVerticalAlignment() == FLGComponent2D.CENTER)
                areaPosY -= component.getSize().height / 2;
            if (component2D.getVerticalAlignment() == FLGComponent2D.BOTTOM)
                areaPosY -= component.getSize().height;
            g.translate(areaPosX, areaPosY);
            component.paint(g);
            g.translate(-areaPosX, -areaPosY);
        }
    }

    /** Zeichnet die Funktionen dieses 2D Plotters. */
    private void paintFunctions(Graphics g) {
        int noFunctions = functionGroup.getNoFunctions();
        int height = getBounds().height - getInsets().top - getInsets().bottom;
        int width = getBounds().width - getInsets().right - getInsets().left;
        int areaWidth = width - leftMargin - rightMargin;
        int areaHeight = height - bottomMargin - topMargin;
        g.setClip(leftMargin, topMargin, areaWidth, areaHeight);
        // AS: muss hier definiert werden, sonst error.
        FLGLegendNumber[] legendNumbers = null;
        // AS: Offset für Legendennummern initialisieren.
        if (showLegend) {
            legendNumber = 0;
            legendNumbers = legend.getFunctionLegendNumbers();
            legendNumberX = leftMargin + legendNumberDistance / 2;
        }
        for (int f = 0; f < noFunctions; f++) {
            FLGFunction2D function = functionGroup.getFunction(f);
            int pc = 0;
            for (int areaPosX = 0; areaPosX < areaWidth; areaPosX++) {
                double fctX = (areaPosX + 0.5d) / areaWidth * (csMaxX - csMinX) + csMinX;
                double fctX_LB = (areaPosX + 0.0d) / areaWidth * (csMaxX - csMinX) + csMinX;
                double fctX_UB = (areaPosX + 1.0d) / areaWidth * (csMaxX - csMinX) + csMinX;
                fctX_LB = correctDouble(fctX_LB, csRdMaxX - csRdMinX);
                fctX_UB = correctDouble(fctX_UB, csRdMaxX - csRdMinX);
                if (function.getMinX() <= fctX_UB && fctX_LB <= function.getMaxX()) {
                    // Funktionsgrenzen überprüfen
                    if (fctX_LB <= function.getMinX() && function.getMinX() <= fctX_UB)
                        fctX = function.getMinX();
                    if (fctX_LB <= function.getMaxX() && function.getMaxX() <= fctX_UB)
                        fctX = function.getMaxX();
                    // Darstellungsgrenzen überprüfen
                    if (areaPosX == 0) fctX = csMinX;
                    if (areaPosX == areaWidth - 1) fctX = csMaxX;
                    double fctY = function.calculate(fctX);
                    int areaPosY = areaHeight - 1 - (int)Math.round((fctY - csMinY) / (csMaxY - csMinY) * (areaHeight - 1));
                    scrXCoords[pc] = leftMargin + areaPosX;
                    scrYCoords[pc++] = topMargin + areaPosY;
                }
            }
            if (pc > 1) {
                if (function.getStroke() == null) {
                    g.setColor(function.getColor());
                    g.drawPolyline(scrXCoords, scrYCoords, pc);
                    g.drawLine(scrXCoords[pc - 2], scrYCoords[pc - 2], scrXCoords[pc - 1], scrYCoords[pc - 1]);
                }
                else { // ein stroke wurde fuer die Funktion definiert.
                    Graphics2D g2 = (Graphics2D)g;
                    g2.setStroke(function.getStroke());
                    g2.setColor(function.getColor());
                    g2.drawPolyline(scrXCoords, scrYCoords, pc);
                    g2.drawLine(scrXCoords[pc - 2], scrYCoords[pc - 2], scrXCoords[pc - 1], scrYCoords[pc - 1]);
                    g2.setStroke(FLGGraphics.STROKE_DEFAULT);
                }
            }
            if (showLegend) {
                int legendNumberY = 0;
                int abweichung = Integer.MAX_VALUE;
                // AS: Die beste Koordinate suchen
                int correctedX = legendNumberX + legendNumbers[legendNumber].getPreferredSize().width / 2;
                for (int i = 0; i < pc; i++)
                    if (Math.abs(scrXCoords[i] - correctedX) < abweichung) {
                        abweichung = Math.abs(scrXCoords[i] - correctedX);
                        legendNumberY = scrYCoords[i];
                    }
                legendNumbers[legendNumber].paint(g, legendNumberX, legendNumberY);
                // AS: legendOffset weitersetzen.
                legendNumberX += legendNumberDistance;
                legendNumber++;
            }
        }
        g.setClip(0, 0, width, height);
    }

    /** Zeichnet die Polygone dieses 2D Plotters. */
    private void paintPolygons(Graphics g) {
        int height = getBounds().height - getInsets().top - getInsets().bottom;
        int width = getBounds().width - getInsets().right - getInsets().left;
        int areaWidth = width - leftMargin - rightMargin;
        int areaHeight = height - bottomMargin - topMargin;
        // AS: muss hier definiert werden, sonst error.
        FLGLegendNumber[] legendNumbers = null;
        // AS: Offset für Legendennummern initialisieren.
        if (showLegend) {
            if (functionGroup == null) {
                legendNumberX = leftMargin + legendNumberDistance / 2;
            }
            legendNumber = 0;
            legendNumbers = legend.getPolygonLegendNumbers();
        }
        for (int pg = 0; pg < polygonGroup.getNoPolygons(); pg++) {
            FLGPolygon2D polygon = polygonGroup.get(pg);
            for (int p = 0; p < polygon.size(); p++) {
                double csX = polygon.get(p).getX();
                double csY = polygon.get(p).getY();
                int areaPosX = (int)Math.round((csX - csMinX) / (csMaxX - csMinX) * (areaWidth - 1));
                int areaPosY = areaHeight - 1 - (int)Math.round((csY - csMinY) / (csMaxY - csMinY) * (areaHeight - 1));
                scrXCoords[p] = areaPosX + leftMargin;
                scrYCoords[p] = areaPosY + topMargin;
            }
            if (polygon.getStroke() == null) {
                g.setColor(polygon.getColor());
                g.drawPolyline(scrXCoords, scrYCoords, polygon.size());
            }
            else { // ein stroke wurde fuer die Funktion definiert.
                Graphics2D g2 = (Graphics2D)g;
                g2.setColor(polygon.getColor());
                g2.setStroke(polygon.getStroke());
                g2.drawPolyline(scrXCoords, scrYCoords, polygon.size());
                g2.setStroke(FLGGraphics.STROKE_DEFAULT);
            }
            if (showLegend) {
                // AS: Die beste Koordinate für Legendennummer suchen
                int correctedX = legendNumberX + legendNumbers[legendNumber].getPreferredSize().width / 2;
                // Welche Position ist die letzte an der der x-Wert des
                // Polygons (am Bildschirm) kleiner als der der Legendennummer.
                int posInScrCoords = 0;
                while ((posInScrCoords < polygon.size() - 1) && (scrXCoords[posInScrCoords + 1] < correctedX))
                    posInScrCoords++;
                int legendNumberY = scrYCoords[posInScrCoords];
                if ((polygon.size() > 1) && (posInScrCoords < polygon.size() - 1)) {
                    // berechne den Punkt auf der Geraden zwischen den beiden
                    // Punkten des Polygons auf der die Legendennummer liegt.
                    double b = (scrYCoords[posInScrCoords + 1] - scrYCoords[posInScrCoords]) /
                        (double)(scrXCoords[posInScrCoords + 1] - scrXCoords[posInScrCoords]);
                    legendNumberY += (int)((correctedX - scrXCoords[posInScrCoords]) * b);
                }
                legendNumbers[legendNumber].paint(g, legendNumberX, legendNumberY);
                // AS: legendOffset weitersetzen.
                legendNumberX += legendNumberDistance;
                legendNumber++;
            }
        }
    }

    /** Zeichnet das Raster dieses 2D Plotters. */
    private void paintGrid(Graphics g) {
        int height = getBounds().height - getInsets().top - getInsets().bottom;
        int width = getBounds().width - getInsets().right - getInsets().left;
        int areaWidth = width - leftMargin - rightMargin;
        int areaHeight = height - bottomMargin - topMargin;
        g.drawRect(leftMargin, topMargin, areaWidth - 1, areaHeight - 1);
        for (int p = 0; p < noXAxisLabels; p++) {
            double fctX = xAxisLabelsPos[p];
            int areaPosX = (int)Math.round((fctX - csMinX) / (csMaxX - csMinX) * (areaWidth - 1));
            g.drawLine(areaPosX + leftMargin, topMargin, areaPosX + leftMargin, height - 1 - bottomMargin);
        }
        for (int p = 0; p < noYAxisLabels; p++) {
            double fctY = yAxisLabelsPos[p];
            int areaPosY = areaHeight - 1 - (int)Math.round((fctY - csMinY) / (csMaxY - csMinY) * (areaHeight - 1));
            g.drawLine(leftMargin, areaPosY + topMargin, width - 1 - rightMargin, areaPosY + topMargin);
        }
    }

    /** Zeichnet das Koordinatensystem dieses 2D Plotters. */
    private void paintCoordSystem(Graphics g) {
        int height = getBounds().height - getInsets().top - getInsets().bottom;
        int width = getBounds().width - getInsets().right - getInsets().left;
        int areaWidth = width - leftMargin - rightMargin;
        int areaHeight = height - bottomMargin - topMargin;
        int x1, x2, y1, y2;
        int[] x = new int[3];
        int[] y = new int[3];
        Point xAxisEndPnt = new Point();
        Point yAxisEndPnt = new Point();
        int dirX = yAxisIsLeft() ? 1 : -1;
        int dirY = xAxisIsBottom() ? 1 : -1;
        Color oldColor = g.getColor();
        // paint X-Axis-Line
        x1 = leftMargin;
        x2 = width - 1 - rightMargin;
        if (xAxisIsTotalTop()) {
            y1 = topMargin;
            y2 = y1;
        }
        else if (xAxisIsTotalBottom()) {
            y1 = height - 1 - bottomMargin;
            y2 = y1;
        }
        else {
            y1 = topMargin + areaHeight - 1 - (int)Math.round((-csMinY) / (csMaxY - csMinY) * (areaHeight - 1));
            y2 = y1;
        }
        xAxisEndPnt.x = x2;
        xAxisEndPnt.y = y2;
        g.drawLine(x1, y1, x2, y2);
        // paint X-Arrow
        x[0] = xAxisEndPnt.x + xAxisArrowTotalLength - 1;
        y[0] = xAxisEndPnt.y;
        x[1] = x[0] - (AXIS_ARROWTOP_LENGTH - 1);
        y[1] = y[0] - ((AXIS_ARROWTOP_WIDTH - 1) >> 1);
        x[2] = x[1];
        y[2] = y[0] + ((AXIS_ARROWTOP_WIDTH - 1) >> 1);
        g.drawLine(xAxisEndPnt.x, xAxisEndPnt.y, x[0] - 1, y[0]);
        g.fillPolygon(x, y, 3);
        // paint X-Axis Name
        int xAxisLabelPosY = xAxisEndPnt.y - (xAxisLabel.getSize().height) / 2;
        int xAxisLabelPosX = xAxisEndPnt.x + xAxisArrowTotalLength + AXISNAME_DIST_FROM_ARROW;
        g.translate(xAxisLabelPosX, xAxisLabelPosY);
        xAxisLabel.paint(g);
        g.translate(-xAxisLabelPosX, -xAxisLabelPosY);
        g.setColor(oldColor);
        // paint Y-Axis-Line
        y1 = topMargin;
        y2 = height - 1 - bottomMargin;
        if (yAxisIsTotalLeft()) {
            x1 = leftMargin;
            x2 = x1;
        }
        else if (yAxisIsTotalRight()) {
            x1 = width - 1 - rightMargin;
            x2 = x1;
        }
        else {
            x1 = leftMargin + (int)Math.round((-csMinX) / (csMaxX - csMinX) * (areaWidth - 1));
            x2 = x1;
        }
        g.drawLine(x1, y1, x2, y2);
        yAxisEndPnt.x = x1;
        yAxisEndPnt.y = y1;
        // paint Y-Arrow
        x[0] = yAxisEndPnt.x;
        y[0] = yAxisEndPnt.y - (yAxisArrowTotalLength - 1);
        x[1] = x[0] - ((AXIS_ARROWTOP_WIDTH - 1) >> 1);
        y[1] = y[0] + (AXIS_ARROWTOP_LENGTH - 1);
        x[2] = x[0] + ((AXIS_ARROWTOP_WIDTH - 1) >> 1);
        y[2] = y[1];
        g.drawLine(yAxisEndPnt.x, yAxisEndPnt.y, x[0], y[0] + 1);
        g.fillPolygon(x, y, 3);
        // paint Y-Axis NAME
        //		int yAxisLabelPosX = yAxisEndPnt.x - (yAxisLabel.getSize().width) / 2;
        int yAxisLabelPosX = (int)Math.max(yAxisEndPnt.x - (yAxisLabel.getSize().width) / 2, 5);
        int yAxisLabelPosY = yAxisEndPnt.y - yAxisArrowTotalLength - AXISNAME_DIST_FROM_ARROW - yAxisLabel.getSize().height;
        g.translate(yAxisLabelPosX, yAxisLabelPosY);
        yAxisLabel.paint(g);
        g.translate(-yAxisLabelPosX, -yAxisLabelPosY);
        g.setColor(oldColor);
        // paint X-Axis Labels
        for (int p = 0; p < noXAxisLabels; p++) {
            double fctX = xAxisLabelsPos[p];
            int areaPosX = (int)Math.round((fctX - csMinX) / (csMaxX - csMinX) * (areaWidth - 1));
            g.drawLine(areaPosX + leftMargin, xAxisEndPnt.y, areaPosX + leftMargin,
                xAxisEndPnt.y - dirY * LABEL_DIST_FROM_AXIS);
            int labelWidth = xAxisLabels[p].getPreferredSize().width;
            int labelHeight = xAxisLabels[p].getPreferredSize().height;
            int px, py;
            px = areaPosX + leftMargin - (labelWidth >> 1);
            if (xAxisIsBottom()) py = xAxisEndPnt.y + LABEL_DIST_FROM_AXIS;
            else
                py = xAxisEndPnt.y - LABEL_DIST_FROM_AXIS - labelHeight;
            g.translate(px, py);
            xAxisLabels[p].paint(g);
            g.translate(-px, -py);
            g.setColor(oldColor);
        }
        // paint Y-Axis Labels
        for (int p = 0; p < noYAxisLabels; p++) {
            double fctY = yAxisLabelsPos[p];
            int areaPosY = areaHeight - 1 - (int)Math.round((fctY - csMinY) / (csMaxY - csMinY) * (areaHeight - 1));
            g.drawLine(yAxisEndPnt.x, areaPosY + topMargin, yAxisEndPnt.x + dirX * LABEL_DIST_FROM_AXIS, areaPosY + topMargin);
            int labelWidth = yAxisLabels[p].getPreferredSize().width;
            int labelHeight = yAxisLabels[p].getPreferredSize().height;
            int px, py;
            py = areaPosY + topMargin - (labelHeight >> 1);
            if (yAxisIsLeft()) px = yAxisEndPnt.x - LABEL_DIST_FROM_AXIS - labelWidth;
            else
                px = yAxisEndPnt.x + LABEL_DIST_FROM_AXIS;
            g.translate(px, py);
            yAxisLabels[p].paint(g);
            g.translate(-px, -py);
            g.setColor(oldColor);
        }
    }
    //
    // Support Methods
    //

    /** Initialisiert diesen Plotter. */
    private void init(Graphics g) {
        if (!(initialized)) {
            initialized = true;
            // Legende erzeugen, wenn erwünscht.
            if (showLegend) legend = new FLGLegend(g);
            fm = g.getFontMetrics();
            fontAscent = fm.getAscent();
            fontHeight = fontAscent + fm.getDescent();
            // Berechne csRdMinX und csRdMaxX
            int decPos = calcDecPos(csMaxX - csMinX);
            csRdMinX = calcFloor(csMinX, decPos);
            csRdMaxX = calcCeil(csMaxX, decPos);
            double range = csRdMaxX - csRdMinX;
            csRdMinX = correctDouble(csRdMinX, range);
            csRdMaxX = correctDouble(csRdMaxX, range);
            // Berechne csRdMinY und csRdMaxY
            decPos = calcDecPos(csMaxY - csMinY);
            csRdMinY = calcFloor(csMinY, decPos);
            csRdMaxY = calcCeil(csMaxY, decPos);
            range = csRdMaxY - csRdMinY;
            csRdMinY = correctDouble(csRdMinY, range);
            csRdMaxY = correctDouble(csRdMaxY, range);
            // Berechne maxXLabelWidth
            if (automatedXAxisLabeling) {
                int w1 = fm.stringWidth(createString(csRdMinX) + ".99");
                int w2 = fm.stringWidth(createString(csRdMaxX) + ".99");
                if (w1 > w2) maxXLabelWidth = w1;
                else
                    maxXLabelWidth = w2;
            }
            else {
                maxXLabelWidth = 0;
                for (int i = 0; i < noXAxisLabels; i++)
                    maxXLabelWidth = (int)Math.max(maxXLabelWidth, xAxisLabels[i].getPreferredSize().width);
            }
            // Berechne maxYLabelWidth
            if (automatedYAxisLabeling) {
                int w1 = fm.stringWidth(createString(csRdMinY) + ".99");
                int w2 = fm.stringWidth(createString(csRdMaxY) + ".99");
                if (w1 > w2) maxYLabelWidth = w1;
                else
                    maxYLabelWidth = w2;
            }
            else {
                maxYLabelWidth = 0;
                for (int i = 0; i < noYAxisLabels; i++)
                    maxYLabelWidth = (int)Math.max(maxYLabelWidth, yAxisLabels[i].getPreferredSize().width);
            }
            // Berechne maxXLabelHeight
            if (automatedXAxisLabeling) {
                maxXLabelHeight = fontHeight;
            }
            else {
                maxXLabelHeight = 0;
                for (int i = 0; i < noXAxisLabels; i++)
                    maxXLabelHeight = (int)Math.max(maxXLabelHeight, xAxisLabels[i].getPreferredSize().height);
            }
            // Berechne maxYLabelHeight
            if (automatedYAxisLabeling) {
                maxYLabelHeight = fontHeight;
            }
            else {
                maxYLabelHeight = 0;
                for (int i = 0; i < noYAxisLabels; i++)
                    maxYLabelHeight = (int)Math.max(maxYLabelHeight, yAxisLabels[i].getPreferredSize().height);
            }
            // Berechne xAxisNameWidth, yAxisNameWidth, ...
            xAxisNameWidth = xAxisLabel.getPreferredSize().width;
            yAxisNameWidth = yAxisLabel.getPreferredSize().width;
            yAxisNameHeight = yAxisLabel.getPreferredSize().height;
            //			xAxisNameWidth = fm.stringWidth(xAxisName);
            //			yAxisNameWidth = fm.stringWidth(yAxisName);
        }
    }

    /** Berechnet die R&auml;nder f&uuml;r die spezifizierte Zeichenfl&auml;chengr&ouml;sse. */
    private void calculateMargins(int width, int height) {
        int oldLeft = leftMargin;
        int oldRight = rightMargin;
        int oldTop = topMargin;
        int oldBottom = bottomMargin;
        leftMargin = rightMargin = topMargin = bottomMargin = 0;
        if (this.leftAlignToReferencePlotter) leftMargin = referencePlotter.leftMargin;
        if (this.rightAlignToReferencePlotter) rightMargin = referencePlotter.rightMargin;
        if (this.topAlignToReferencePlotter) topMargin = referencePlotter.topMargin;
        if (this.bottomAlignToReferencePlotter) bottomMargin = referencePlotter.bottomMargin;
        // wegen der simultanen Abhängigkeiten der Margin-Werte werden mehrere Durchläufe benötigt
        for (int iteration = 0; iteration < 3; iteration++) {
            // Berechne xAxisArrowTotalLength und xAxisEndWidth
            xAxisArrowTotalLength = AXIS_ARROWTOP_LENGTH + Math.max(AXIS_ARROWTOP_LENGTH, maxXLabelWidth >> 1);
            if (yAxisIsRight()) {
                xAxisArrowTotalLength = Math.max(xAxisArrowTotalLength,
                    maxYLabelWidth + 2 * LABEL_DIST_FROM_AXIS + AXIS_ARROWTOP_LENGTH);
                if (!(yAxisIsTotalRight())) {
                    int areaWidth = width - leftMargin - rightMargin;
                    int xAreaPosYAxis = (int)(-csMinX / (csMaxX - csMinX) * areaWidth);
                    xAxisArrowTotalLength = Math.max(xAxisArrowTotalLength - (areaWidth - xAreaPosYAxis), 24);
                }
            }
            xAxisEndWidth = xAxisNameWidth + xAxisArrowTotalLength + AXISNAME_DIST_FROM_ARROW;
            // Berechne yAxisArrowTotalLength und yAxisEndHeight
            yAxisArrowTotalLength = AXIS_ARROWTOP_LENGTH + Math.max(AXIS_ARROWTOP_LENGTH, maxYLabelHeight >> 1);
            if (xAxisIsTop()) {
                yAxisArrowTotalLength = Math.max(yAxisArrowTotalLength,
                    maxXLabelHeight + 2 * LABEL_DIST_FROM_AXIS + AXIS_ARROWTOP_LENGTH);
                if (!(xAxisIsTotalTop())) {
                    int areaHeight = height - topMargin - bottomMargin;
                    int yAreaPosXAxis = (int)(-csMinY / (csMaxY - csMinY) * (double)areaHeight);
                    yAxisArrowTotalLength = Math.max(yAxisArrowTotalLength - (areaHeight - yAreaPosXAxis), 24);
                }
            }
            yAxisEndHeight = yAxisNameHeight + yAxisArrowTotalLength + AXISNAME_DIST_FROM_ARROW;
            // topMargin und bottomMargin berechnen
            if (!topAlignToReferencePlotter) topMargin = yAxisEndHeight;
            if (!bottomAlignToReferencePlotter) {
                if (xAxisIsTop()) {
                    bottomMargin = maxYLabelHeight >> 1;
                }
                else {
                    bottomMargin = maxXLabelHeight + LABEL_DIST_FROM_AXIS;
                    if (!(xAxisIsTotalBottom())) {
                        int areaHeight = height - topMargin - bottomMargin;
                        int yAreaPosXAxis = (int)(-csMinY / (csMaxY - csMinY) * (double)areaHeight);
                        bottomMargin = Math.max(maxYLabelHeight >> 1, maxXLabelHeight + LABEL_DIST_FROM_AXIS - yAreaPosXAxis);
                    }
                }
            }
            // rightMargin und leftMargin berechnen
            if (!rightAlignToReferencePlotter) rightMargin = xAxisEndWidth;
            if (!leftAlignToReferencePlotter) {
                if (yAxisIsRight()) {
                    leftMargin = maxXLabelWidth / 2;
                }
                else {
                    //				leftMargin = Math.max(yAxisNameWidth / 2,
                    //						Math.max(maxXLabelWidth/2, LABEL_DIST_FROM_AXIS + maxYLabelWidth));
                    // NL: 29.11.2000
                    leftMargin = Math.max(maxXLabelWidth / 2, LABEL_DIST_FROM_AXIS + maxYLabelWidth);
                    if (!(yAxisIsTotalLeft())) {
                        int areaWidth = width - leftMargin - rightMargin;
                        int xAreaPosYAxis = (int)(-csMinX / (csMaxX - csMinX) * areaWidth);
                        //					leftMargin = Math.max(yAxisNameWidth / 2 - xAreaPosYAxis,
                        //						Math.max(maxXLabelWidth/2, LABEL_DIST_FROM_AXIS +
                        // maxYLabelWidth - xAreaPosYAxis));
                        // NL: 29.11.2000
                        leftMargin = Math.max(maxXLabelWidth / 2, LABEL_DIST_FROM_AXIS + maxYLabelWidth - xAreaPosYAxis);
                    }
                }
            }
            //AS: Legendenplatzberechnung
            if (showLegend) {
                int legendWidth = legend.getPreferredSize().width;
                if (!rightAlignToReferencePlotter) rightMargin += legendWidth + 5;
            }
        }
        // AS: Abstand zwischen den Legendennummern berechnen.
        if (showLegend && legend.countElements() > 0) {
            int areaWidth = width - leftMargin - rightMargin;
            legendNumberDistance = areaWidth / legend.countElements();
        }
        if (dependentPlotters.size() > 0) {
            if ((oldLeft != leftMargin) || (oldRight != rightMargin) || (oldTop != topMargin) || (oldBottom != bottomMargin)) {
                for (int i = 0; i < dependentPlotters.size(); i++) {
                    ((FLGPlotter2D)dependentPlotters.elementAt(i)).repaint();
                }
            }
        }
    }

    /** Berechnet die Positionen der <i>x</i>-Achsenbeschriftungen. */
    private void createXAxisLabels(int areaWidth) {
        noXAxisLabels = 0;
        double stepXSize = calcOptXStepSize(areaWidth);
        for (double fctX = csRdMinX; fctX <= csRdMaxX; fctX += stepXSize) {
            fctX = correctDouble(fctX, csRdMaxX - csRdMinX);
            if (csMinX <= fctX && fctX <= csMaxX) {
                xAxisLabelsPos[noXAxisLabels] = fctX;
                JLabel label = new JLabel(createString(fctX));
                label.setSize(label.getPreferredSize());
                xAxisLabels[noXAxisLabels] = label;
                noXAxisLabels++;
            }
        }
    }

    /** Berechnet die Positionen der <i>y</i>-Achsenbeschriftungen. */
    private void createYAxisLabels(int areaHeight) {
        noYAxisLabels = 0;
        double stepYSize = calcOptYStepSize(areaHeight);
        for (double fctY = csRdMinY; fctY <= csRdMaxY; fctY += stepYSize) {
            fctY = correctDouble(fctY, csRdMaxY - csRdMinY);
            if (csMinY <= fctY && fctY <= csMaxY) {
                yAxisLabelsPos[noYAxisLabels] = fctY;
                JLabel label = new JLabel(createString(fctY));
                label.setSize(label.getPreferredSize());
                yAxisLabels[noYAxisLabels] = label;
                noYAxisLabels++;
            }
        }
    }

    /**
     * Korrigiert die Genauigkeit der spezifizierten <code>double</code>-Zahl <i>d</i>.
     * Normalerweise wird auf 3 Nachkommastellen gerundet. Liegt range zwischen 0.1 und 1, dann
     * wird auf 4 Stellen gerundet. Liegt range zwischen 0.01 und 0.1, dann wird auf 5 Stellen gerundet, etc.
     */
    private double correctDouble(double d, double range) {
        int genauigkeit = 3;
        int decPos = calcDecPos(range);
        if (decPos < 0) genauigkeit += -decPos;
        return Math.round(d * Math.pow(10d, genauigkeit)) / Math.pow(10d, genauigkeit);
    }

    /**
     * Berechnet die optimale Schrittweite der <i>x</i>-Achse f&uum;r die spezifizierte Anzeigenbreite.
     * @param	areaWidth	die Anzeigenbreite.
     * @return					die optimale Schrittweite.
     */
    private double calcOptXStepSize(int areaWidth) {
        double[] sectionSizes = {40,20,10,5,4,2};
        for (int s = 0; s < sectionSizes.length; s++) {
            double stepSize = (csRdMaxX - csRdMinX) / sectionSizes[s];
            int noLabelsInDomain = 0;
            String biggestLabel = "";
            for (double fctX = csRdMinX; fctX <= csRdMaxX; fctX += stepSize) {
                fctX = correctDouble(fctX, csRdMaxX - csRdMinX);
                if (csMinX <= fctX && fctX <= csMaxX) {
                    noLabelsInDomain++;
                    String label = createString(fctX);
                    if (label.length() > biggestLabel.length()) biggestLabel = label;
                }
            }
            if (noLabelsInDomain > 0 && noLabelsInDomain <= maxNoXAxisLabels)
                if ((fm.stringWidth(biggestLabel) + MIN_INTER_LABEL_DIST) * noLabelsInDomain < areaWidth) return stepSize;
        }
        return (csRdMaxX - csRdMinX);
    }

    /**
     * Berechnet die optimale Schrittweite der <i>y</i>-Achse f&uum;r die spezifizierte Anzeigeh&ouml;he.
     * @param	areaHeight	die Anzeigeh&ouml;he.
     * @return						die optimale Schrittweite.
     */
    private double calcOptYStepSize(int areaHeight) {
        double[] sectionSizes = {40,20,10,5,4,2};
        for (int s = 0; s < sectionSizes.length; s++) {
            double stepSize = (csRdMaxY - csRdMinY) / sectionSizes[s];
            int noLabelsInDomain = 0;
            for (double fctY = csRdMinY; fctY <= csRdMaxY; fctY += stepSize)
                if (csMinY <= fctY && fctY <= csMaxY) noLabelsInDomain++;
            if (fontHeight * noLabelsInDomain < areaHeight && noLabelsInDomain <= maxNoYAxisLabels)
                return stepSize;
        }
        return (csRdMaxY - csRdMinY);
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	calcDecPos
    // 100 --> 2; 10 --> 1; 1 --> 0; 0 --> 0; 0.1 --> -1; 0.01 --> -2;
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private int calcDecPos(double d) {
        double absD = Math.abs(d);
        if (absD == 0) return 0;
        int decPos = 0;
        if (absD >= 1) {
            while (absD >= 0.999999999999) {
                absD /= 10f;
                decPos++;
            }
            decPos--;
        }
        else {
            while (absD <= 0.999999999999) {
                absD *= 10f;
                decPos--;
            }
        }
        return decPos;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	calcFloor
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private double calcFloor(double d, int decPos) {
        double verySmall = 0.0001;
        double floor = Math.floor(verySmall + d * Math.pow(10d, (double) - decPos)) * Math.pow(10d, (double)decPos);
        return floor;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	calcCeil
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private double calcCeil(double d, int decPos) {
        double verySmall = 0.0001;
        double floor = Math.ceil(d * Math.pow(10d, (double) - decPos) - verySmall) * Math.pow(10d, (double)decPos);
        return floor;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	createString
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private String createString(double d) {
        String s = String.valueOf(d);
        int l = s.length();
        if (s.charAt(l - 2) == '.' && s.charAt(l - 1) == '0') s = s.substring(0, l - 2);
        return s;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	axis position
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private boolean yAxisIsLeft() { return (csMinX + csMaxX) / 2 >= 0; }

    private boolean yAxisIsRight() { return (csMinX + csMaxX) / 2 < 0; }

    private boolean yAxisIsTotalLeft() { return csMinX >= 0; }

    private boolean yAxisIsTotalRight() { return csMaxX <= 0; }

    private boolean xAxisIsBottom() { return (csMinY + csMaxY) / 2 >= 0; }

    private boolean xAxisIsTop() { return (csMinY + csMaxY) / 2 < 0; }

    private boolean xAxisIsTotalBottom() { return csMinY >= 0; }

    private boolean xAxisIsTotalTop() { return csMaxY <= 0; }
    //
    // Animationsmethoden
    //

    /** Startet die Animation dieses 2D Plotters. */
    public void startAnim() {
        if (runner == null) {
            runner = new Thread(this);
            runner.setPriority(Thread.MIN_PRIORITY);
            runner.start();
        }
    }

    /** Stoppt die Animation dieses 2D Plotters. */
    public void stopAnim() {
        if (runner != null) {
            runner.interrupt();
            runner = null;
        }
    }

    /**
     * Diese Methode muss von einer abgeleiteten Klasse &uuml;berschrieben werden.
     * Sie spezifiziert wie die Animation ablaufen soll. In dieser Klasse hat diese Methode keine Effekte.
     */
    public void animate() { }

    /**
     * Wird automatisch aufgerufen und spezifiziert, dass bei einer Animation alle 10 ms neu
     * gezeichnet wird. Dies kann durch zus&auml;tzliche Verz&ouml;gerungen in der
     * <code>animate</code>-Methode verlangsamt werden.
     */
    public void run() {
        while (true) {
            animate();
            repaint();
            try { Thread.sleep(10); }
            catch (Exception e) {
                System.out.println("FLGPlotter2D.run(): " + e);
            }
        }
    }

    /**
     * @deprecated As of JDK version 1.1, replaced by <oced>getPreferredSize()</code>.
     * @see #getPreferredSize() / public Dimension preferredSize() { return PREFERRED_SIZE; } /**
     * Liefert die bevorzugte Gr&ouml;sse dieses 2D Plotter.
     * @return	eine Instanz von <code>Dimension</code>, welche die bevorzugte Gr&ouml;sse ist.
     */
    public Dimension getPreferredSize() {
        return PREFERRED_SIZE;
    }

    /** Eine Legende f&uuml;r einen 2D Plotter. */
    private class FLGLegend {
        /** Die bevorzugte Gr&ouml;sse der Legende. */
        private Dimension preferredSize;

        /** Die Groesse einer Legendennummer. */
        private int numberWidth;

        /** Der y-Offset für die Legendennamen. */
        private int nameOffsetY;

        /** Der Titel der Legende. */
        private final String title = ResourceBundle.getBundle("freestyleLearningGroup.independent.plotter.PlotterResource",
            Locale.getDefault()).getString("FLG_PLOTTER_LEGEND");

        /** Die Gr&ouml;sse des Legendentitels. */
        private int titleWidth, titleHeight;
        private final Font myFont = new Font("SansSerif", Font.BOLD, 10);
        private Font currentFont;

        /** Anzahl der Funktionen */
        private int noFunctions;

        /** Anzahl der Polygone */
        private int noPolygons;

        /** Anzahl der Legendeneintr&auml;ge. */
        private int noLegendEntries;

        /** Die Nummern der Legende. Groesse ist default 10. Mehr als 9 Legendenbeschriftungen sind eh nicht vorgesehen. */
        private java.util.Vector legendNumbers = new java.util.Vector();

        /** Die Namen der Legende. Groesse ist default 10. Mehr als 9 Legendenbeschriftungen sind eh nicht vorgesehen. */
        private java.util.Vector legendNames = new java.util.Vector();
        private java.util.Vector legendLabels = new java.util.Vector();
        //
        // Konstruktoren
        //

        /**
         * Erzeugt eine Legende f&uuml;r diesen Plotter. Der Grafikkontext muss f&uuml;r die
         * Berechnung der bevorzugten Gr&ouml;sse  &uuml;bergeben werden.
         */
        public FLGLegend(Graphics g) {
            if (functionGroup != null) noFunctions = functionGroup.getNoFunctions();
            else
                noFunctions = 0;
            if (polygonGroup != null) noPolygons = polygonGroup.getNoPolygons();
            else
                noPolygons = 0;
            noLegendEntries = noFunctions + noPolygons;
            FontMetrics fm = g.getFontMetrics(myFont);
            if (noLegendEntries > 0) {
                for (int i = 0; i < noLegendEntries; i++)
                    legendNumbers.add(new FLGLegendNumber(i + 1));
                int maxNameWidth = 0;
                int totalLabelsHeight = 0;
                nameOffsetY = 5;
                for (int i = 0; i < noFunctions; i++) {
                    String name = functionGroup.getFunction(i).getName();
                    legendNames.add(name);
                    JLabel label = new JLabel(name);
                    label.setSize(label.getPreferredSize());
                    legendLabels.add(label);
                    maxNameWidth = (int)Math.max(maxNameWidth, label.getSize().width);
                    totalLabelsHeight += label.getSize().height;
                }
                for (int i = 0; i < noPolygons; i++) {
                    String name = polygonGroup.get(i).getName();
                    legendNames.add(name);
                    JLabel label = new JLabel(name);
                    label.setSize(label.getPreferredSize());
                    legendLabels.add(label);
                    maxNameWidth = (int)Math.max(maxNameWidth, label.getSize().width);
                    totalLabelsHeight += label.getSize().height;
                }
                totalLabelsHeight += noLegendEntries * nameOffsetY;
                java.awt.geom.Rectangle2D stringBounds = g.getFontMetrics(g.getFont()).getStringBounds(title, g);
                titleHeight = (int)stringBounds.getHeight();
                titleWidth = (int)stringBounds.getWidth();
                if (titleWidth > maxNameWidth) maxNameWidth = titleWidth;
                numberWidth = ((FLGLegendNumber)legendNumbers.elementAt(0)).getPreferredSize().width;
                preferredSize = new Dimension(numberWidth + maxNameWidth + 6, titleHeight + 4 + totalLabelsHeight + 4);
                preferredSize.width += 5;
            }
            else
                preferredSize = new Dimension(0, 0);
        }
        //
        // Access methods
        //

        /**
         * Liefert die Anzahl der Legendenelemente.
         * @return	die Anzahl der Elemente.
         */
        public int countElements() {
            return noLegendEntries;
        }

        /**
         * Liefert die <code>FLGLegendNumber</code>s der Funktionen als Array. Diese k&ouml;nnen
         * dann in die Grafik gezeichnet werden.
         * @return	die Legendennummern.
         */
        public FLGLegendNumber[] getFunctionLegendNumbers() {
            if (noFunctions > 0) {
                FLGLegendNumber[] legendNumbersArray = new FLGLegendNumber[noFunctions];
                for (int i = 0; i < noFunctions; i++)
                    legendNumbersArray[i] = (FLGLegendNumber)legendNumbers.elementAt(i);
                return legendNumbersArray;
            }
            else
                return null;
        }

        /**
         * Liefert die <code>FLGLegendNumber</code>s der Polygone als Array. Diese k&ouml;nnen
         * dann in die Grafik gezeichnet werden.
         * @return	die Legendennummern.
         */
        public FLGLegendNumber[] getPolygonLegendNumbers() {
            if (noPolygons > 0) {
                FLGLegendNumber[] legendNumbersArray = new FLGLegendNumber[noPolygons];
                for (int i = noFunctions; i < noLegendEntries; i++)
                    legendNumbersArray[i - noFunctions] = (FLGLegendNumber)legendNumbers.elementAt(i);
                return legendNumbersArray;
            }
            else
                return null;
        }

        /**
         * Liefert die bevorzugte Gr&ouml;sse dieser Legende.
         * @return	 die bevorzugte Gr&ouml;sse dieser Legende als <code>Dimension</code>.
         */
        public Dimension getPreferredSize() {
            return preferredSize;
        }

        /**
         * Zeichnet die Legende an der spezifizierten Position.
         * @param x,&nbsp;y	die Koordinaten der oberes linken Ecke der Legende.
         */
        public void paint(Graphics g, int x, int y) {
            if (countElements() > 0) {
                g.setColor(Color.black);
                currentFont = g.getFont();
                g.drawString(title, x + 5, y + titleHeight);
                g.drawLine(x + 2, y, x + preferredSize.width - 6, y);
                g.drawLine(x + 2, y + preferredSize.height, x + preferredSize.width - 6, y + preferredSize.height);
                int offsX = 2;
                int offsY = titleHeight + 4 + numberWidth / 2;
                for (int i = 0; i < noLegendEntries; i++) {
                    g.setFont(myFont);
                    ((FLGLegendNumber)legendNumbers.elementAt(i)).paint(g, x + offsX, y + offsY);
                    Color currentColor = g.getColor();
                    g.translate(x + offsX + numberWidth, y + offsY);
                    ((JLabel)legendLabels.elementAt(i)).paint(g);
                    g.translate(-(x + offsX + numberWidth), -(y + offsY));
                    g.setColor(currentColor);
                    offsY += ((JLabel)legendLabels.elementAt(i)).getSize().height + nameOffsetY;
                }
                g.setFont(currentFont);
            }
        }
    }


    /**
     * Eine Nummer, die f&uuml;r die Legende selbst und auch f&uuml;r die Beschriftung der
     * Funktionen oder Polygonen benutzt wird.
     */
    private class FLGLegendNumber {
        //
        // Konstanten
        //
        private final Font myFont = new Font("SansSerif", Font.BOLD, 10);
        private final Color myColor = new Color(196, 196, 196);
        private final Dimension preferredSize = new Dimension(16, 16);
        //
        // Variablen
        //
        private Font currentFont;
        private Color currentColor;
        private int number;

        /**
         * Erzeugt die Legendennummer mit der spezifizerten Nummer.
         * @param	number	die Nummer die dieser Legendeneintrag hat.
         */
        public FLGLegendNumber(int number) {
            this.number = number;
        }

        /**
         * Liefert die bevorzugte Gr&ouml;sse dieser Nummer.
         * @return	 die bevorzugte Gr&ouml;sse dieser Nummer als <code>Dimension</code>.
         */
        public Dimension getPreferredSize() {
            return preferredSize;
        }

        /**
         * Zeichnet die Nummer im spezifizierten Grafikkontext an der spezifizierten Position.
         * Ausgerichtet wird links mittig an den spezifizierten Koordinaten.
         * @param	g					der Grafikkontext.
         * @param	x,&nbsp;y	die Koordinaten, an denen die Nummer gezeichnet werden soll.
         */
        public void paint(Graphics g, int x, int y) {
            currentFont = g.getFont();
            currentColor = g.getColor();
            g.setFont(myFont);
            java.awt.geom.Rectangle2D stringBounds = g.getFontMetrics(myFont).getStringBounds(Integer.toString(number), g);
            g.setColor(BG_COLOR);
            g.fillOval(x, y - preferredSize.height / 2, preferredSize.width, preferredSize.height);
            g.setColor(currentColor);
            g.drawString(Integer.toString(number),
                x + 5, y + preferredSize.height / 2 - (preferredSize.height - (int)stringBounds.getHeight()) / 2);
            g.setFont(currentFont);
        }
    }

    public static void main(String[] args) {
        JFrame frame = new JFrame();
        frame.getContentPane().setLayout(new GridLayout(2, 1));
        FLGPolygon2D polygonA = new FLGPolygon2D();
        polygonA.setColor(Color.red);
        polygonA.add(new FLGPoint2D(0, 100000));
        polygonA.add(new FLGPoint2D(1, 100000));
        polygonA.add(new FLGPoint2D(1, 80000));
        polygonA.add(new FLGPoint2D(2, 80000));
        polygonA.add(new FLGPoint2D(2, 60000));
        polygonA.add(new FLGPoint2D(3, 60000));
        polygonA.add(new FLGPoint2D(3, 40000));
        polygonA.add(new FLGPoint2D(4, 40000));
        polygonA.add(new FLGPoint2D(4, 0));
        FLGPolygon2D polygonB = new FLGPolygon2D();
        polygonB.setColor(Color.blue);
        polygonB.add(new FLGPoint2D(0, 20000));
        polygonB.add(new FLGPoint2D(4, 20000));
        FLGPolygonGroup2D polygonGroup = new FLGPolygonGroup2D();
        polygonGroup.add(polygonA);
        polygonGroup.add(polygonB);
        FLGPlotter2D plotter = new FLGPlotter2D(polygonGroup, "Periode", "Super tolle geniale Kapitalbindung");
        plotter.setMaxNoYAxisLabels(11);
        double[] xAxisLabelsPos = {0, 1, 2, 3, 4 };
        plotter.setXAxisLabelsPos(xAxisLabelsPos);
        plotter.showLegend(false);
        FLGFunction2D functionA = new FLGFunction2D(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, "Sinus") {
            public double calculate(double x) {
                return Math.sin(x);
            }
        };
        functionA.setColor(Color.red);
        FLGFunctionGroup2D functionGroup = new FLGFunctionGroup2D(1, 6.29);
        functionGroup.addFunction(functionA);
        FLGPlotter2D plotter2 = new FLGPlotter2D(functionGroup, null, "X-Achse", "Y-Achse");
        plotter2.setReferencePlotter(plotter, true, true, false, false);
        frame.getContentPane().add(plotter);
        frame.getContentPane().add(plotter2);
        frame.setSize(600, 400);
        frame.setVisible(true);
    }
}
