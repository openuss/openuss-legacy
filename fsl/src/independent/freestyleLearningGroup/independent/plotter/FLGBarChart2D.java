/* Generated by Freestyle Learning Group */

package freestyleLearningGroup.independent.plotter;

import java.awt.Color;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.JComponent;
import javax.swing.JFrame;

import freestyleLearningGroup.independent.gui.FLGBorderFactory;
import freestyleLearningGroup.independent.util.FLGBlackAndWhite;
import freestyleLearningGroup.independent.util.FLGGraphics;

/**
 * Ein Balkendiagramm mit intelligenter Bemusterung der <i>y</i>-Achse mit Beschriftungen. Auch
 * die Beschriftungen der <i>x</i>-Achse werden automatisch positioniert, so dass sie immer lesbar
 * bleiben.<p> <p> <b>Beispiel 1</b>: Erzeugt ein Standard-Balkendiagramm. <p><pre>
 *		FLGDataGroup2D data = new FLGDataGroup2D();
 *		
 *		data.add(new FLGData2D("Alex", 25, java.awt.Color.green));
 *		data.add(new FLGData2D("Andrea", 32, java.awt.Color.red));
 *		data.add(new FLGData2D("Daniel", 23));
 *		
 *		FLGBarChart2D barchart = new FLGBarChart2D(data, "Name", "Alter");
 *
 *		<img src="../../../../../images/BarChart2D.gif" width="600" height="400">
 * </pre><p> <p> <b>Beispiel 2</b>: Erzeugt obiges Balkendiagramm mit den vorgegebenen
 * <i>y</i>-Achsenbeschriftungen.<p> Das Balkendiagramm wird mit Farbverl&auml;ufen gezeichnet und
 * die Werte werden in die Balken geschrieben. <p><pre>
 *		FLGDataGroup2D data = new FLGDataGroup2D();
 *		
 *		data.add(new FLGData2D("Alex", 25, java.awt.Color.green));
 *		data.add(new FLGData2D("Andrea", 32, java.awt.Color.red));
 *		data.add(new FLGData2D("Daniel", 23, java.awt.Color.blue));
 *		
 *		FLGBarChart2D barchart = new FLGBarChart2D(data, "Name", "Alter");
 *		
 *		double[] labels = {0, 23, 25, 32};
 *		barchart.setYAxisLabelsPos(labels);
 *		barchart.setPaintWithGradient(true);
 *		barchart.setShowValues(true);
 *
 *		<img src="../../../../../images/BarChart2D-2.gif" width="600" height="500">
 * </pre><p> <p> <b>Beispiel 3</b>: Erzeugt obiges Balkendiagramm mit max. 4 <i>y</i>-Achsenbeschriftungen. <p><pre>
 *		FLGDataGroup2D data = new FLGDataGroup2D();
 *		
 *		data.add(new FLGData2D("Alex", 25, java.awt.Color.green));
 *		data.add(new FLGData2D("Andrea", 32, java.awt.Color.red));
 *		data.add(new FLGData2D("Daniel", 23));
 *		
 *		FLGBarChart2D barchart = new FLGBarChart2D(data, "Name", "Alter");
 *		barchart.setMaxNoAxisLabels(4);
 *
 *		<img src="../../../../../images/BarChart2D-3.gif" width="600" height="400">
 * </pre><p> Wird nicht mit der Methode <code>setMaxNoAxisLabels</code> eine maximale
 * Anzahl der <i>y</i>-Achsenbeschriftungen gesetzt, werden maximal <code>21</code>
 * <i>y</i>-Achsenbeschriftungen gesetzt. Bei zu kleiner Anzeigefl&auml;che wird die Anzahl der
 * Beschriftungen dynamisch reduziert.<p> Werden mit der Methode
 * <code>setYAxisLabelsPos</code> die <i>y</i>-Achsenbeschriftungen
 * vom Benutzer vorgegeben, werden Diese immer, unabh&auml;ngig von der Anzeigefl&auml;che benutzt.<p>
 * @see FLGData2D
 * @see	FLGDataGroup2D
 */
public class FLGBarChart2D extends JComponent implements FLGBlackAndWhite {
    //
    // Konstanten
    //
    private final static int AXIS_ARROWTOP_LENGTH = 12;
    private final static int AXIS_ARROWTOP_WIDTH = 12;
    private final static int AXISNAME_DIST_FROM_ARROW = 5;
    private final static int LABEL_DIST_FROM_AXIS = 3;
    private final static int MIN_INTER_LABEL_DIST = 3;
    private final static Color GRID_COLOR = new Color(196, 196, 196);
    private final static Color BG_COLOR = new Color(255, 255, 255);
    //
    // Variablen
    //

    /** @serial <i>y</i>-Achse automatisch beschriften? */
    private boolean automatedYAxisLabeling = true;

    /** @serial Maximale Anzahl der <i>y</i>-Achsenbeschriftungen. */
    private int maxNoAxisLabels = 21;

    /** @serial Die Breite des Balkens im Bezug auf die Fl&auml;che, die der Balken benutzen k&ouml;nnte. */
    private double relBarWidth = 0.5d;

    /** Die L&auml;nge der Pfeile an <i>x</i>- und <i>y</i>-Achse.. */
    private transient int axis_arrow_totallength = 24;

    /** @serial Die Standardfarbe f&uuml;r Balken, deren Datenelement keine Farbe zugeordnet ist. */
    private Color defaultBarColor = Color.blue;

    /** @serial Die Datengruppe, die dieses Balkendiagramm ausmacht. */
    private FLGDataGroup2D dataGroup;

    /** @serial Min und Max der Datengruppe dieses Balkendiagrammes. */
    private double dgMinValue, dgMaxValue;

    /** @serial Gerundetes Min und Max der Datengruppe dieses Balkendiagrammes. */
    private double dgRdMinValue, dgRdMaxValue;

    /** Die R&auml;nder der Zeichnefl&auml;che. */
    private transient int leftMargin, rightMargin, topMargin, bottomMargin;

    /** Die Schrifteigenschaften. */
    private transient int fontHeight, fontAscent, maxXLabelWidth, maxYLabelWidth;

    /** Ist das Balkendiagramm bereits berechnet / initialisiert. */
    private transient boolean initialized = false;

    /** @serial Komponente schwarz-weiss zeichnen? */
    private boolean bw = false;

    /** @serial Sollen die Balken mit ihren Werten beschriftet werden ? */
    private boolean writeValues = false;

    /** @serial Komponente mit Farbverl&auml;fen zeichnen? */
    private boolean gradient = false;

    /** @serial Soll ein Grid gezeichnet werden ? */
    private boolean paintGrid = true;

    /** @serial Beschriftung der <i>x</i>-Achse. */
    private String xAxisName = "Produktionsmenge";

    /** @serial Beschriftung der <i>y</i>-Achse. */
    private String yAxisName = "Preis";

    /** Die Breite der Achsenbeschriftungen. */
    private transient int xAxisNameWidth, yAxisNameWidth;
    private transient int xAxisEndWidth, yAxisEndHeight;

    /** @serial	Die <i>y</i>-Achsenbeschriftungen. */
    private double[] yAxisLabelsPos = new double[100];

    /** @serial Die Anzahl der <i>y</i>-Achsenbeschriftungen. */
    private int noYAxisLabels = 0;

    /**
     * Die Anzahl der ben&ouml;tigten Zeilen f&uuml;r die x-Achsen Labels. Ist die
     * Zeichenfl&auml;che kleiner als <b>ein</b> halbes Label, wird <code>xLabelRows<code> auf
     * <code>0</code> gesetzt und die x-Achsenbeschriftungen nicht mehr gezeichnet.
     */
    private transient int xLabelRows;
    private transient FontMetrics fm;
    //
    // Konstruktoren
    //

    /**
     * Erzeugt ein Balkendiagramm aus den spezifizierten Daten und mit den default
     * Achsenbeschriftungen "Produktionsmenge" f&uuml;r die <i>x</i>-Achse und "Preis" f&uuml;r die <i>y</i>-Achse.
     * @param	dataGroup	die Daten dieses Balkendiagramms.
     */
    public FLGBarChart2D(FLGDataGroup2D dataGroup) {
        setDataGroup(dataGroup);
        setBorder(FLGBorderFactory.emptyLoweredBevel10);
    }

    /**
     * Erzeugt ein Balkendiagramm aus den spezifizierten Daten und mit den spezifizierten <i>x</i>- und
     * <i>y</i>-Achsenbeschriftungen.
     * @param	dataGroup	die Daten dieses Balkendiagramms.
     * @param	xAxisName	die Bezeichnung der <i>x</i>-Achse.
     * @param	yAxisName	die Bezeichnung der <i>y</i>-Achse.
     */
    public FLGBarChart2D(FLGDataGroup2D dataGroup, String xAxisName, String yAxisName) {
        setDataGroup(dataGroup);
        this.xAxisName = xAxisName;
        this.yAxisName = yAxisName;
        setBorder(FLGBorderFactory.emptyLoweredBevel10);
    }
    //
    // Methoden
    //

    /**
     * Setzt die Daten dieses Balkendiagrammes auf die spezifizierte <code>FLGDataGroup2D</code>.
     * @param	dataGroup	die neuen Werte dieses Balkendiagrammes.
     * @see	FLGDataGroup2D
     */
    public void setDataGroup(FLGDataGroup2D dataGroup) {
        initialized = false;
        this.dataGroup = dataGroup;
        this.dgMinValue = dataGroup.getMinValue();
        this.dgMaxValue = dataGroup.getMaxValue();
        if (dgMinValue > 0) dgMinValue = 0;
        if (dgMaxValue < 0) dgMaxValue = 0;
        double range = dgMaxValue - dgMinValue;
        this.dgMinValue = correctDouble(this.dgMinValue, range);
        this.dgMaxValue = correctDouble(this.dgMaxValue, range);
    }

    /**
     * Liefert die Daten dieses Balkendiagrammes.
     * @return die Daten dieses Balkendiagrammes.
     * @see	FLGDataGroup2D
     */
    public FLGDataGroup2D getDataGroup() {
        return dataGroup;
    }

    /**
     * Setzt die maximale Anzahl der <i>y</i>-Achsenbeschriftungen auf den spezifizierten Wert.
     * Ist die Anzeigenfl&auml;che zu klein wird die Anzahl der Achsenbeschriftungen dynamisch reduziert.
     * @param	no	die maximale Anzahl der Achsenbeschriftungen.
     */
    public void setMaxNoAxisLabels(int no) {
        maxNoAxisLabels = no;
    }

    /**
     * Setzt die spezifizierten Werte als <i>y</i>-Achsenbeschriftungen. Diese Werte und nur diese
     * Werte werden dann unabh&auml;ngig von der Gr&ouml;sse der Anzeigefl&auml;che an der <i>y</i>-Achse angezeigt.
     * @param	yAxisLabelsPos	die Werte, die an der <i>y</i>-Achse angezeigt werden sollen.
     */
    public void setYAxisLabelsPos(double[] yAxisLabelsPos) {
        automatedYAxisLabeling = false;
        this.yAxisLabelsPos = yAxisLabelsPos;
        noYAxisLabels = yAxisLabelsPos.length;
    }

    /**
     * Schaltet das F&uuml;llen der Balkenst&uuml;cke mit Farbverläufen ein oder aus.
     * @param	gradient	<code>true</code>, wenn mit Farbverl&auml;fen gef&uuml;llt werden soll. Sonst <code> false</code>.
     */
    public void setPaintWithGradient(boolean gradient) {
        this.gradient = gradient;
        repaint();
    }

    /**
     * Bestimmt, ob die Balkenst&uuml;cke gerade mit Farbverl&auml;fen gef&uuml;llt werden, oder
     * nicht. Kann durch <code>setPaintWithGradient()</code> ein- und ausgeschaltet werden.
     * @return	<code>true</code>, wenn mit Farbverl&auml;fen gef&uuml;llt werden soll. Sonst <code>false</code>.
     * @see #setPaintWithGradient(boolean)
     */
    public boolean isPaintWithGradient() {
        return gradient;
    }

    /**
     * Schaltet das Schreiben der Werte in die Balkenst&uuml;cke ein bzw. aus.
     * @param	writeValues	sollen die Werte in die Balkenst&uuml;cke geschrieben werden?
     */
    public void setShowValues(boolean writeValues) {
        this.writeValues = writeValues;
    }

    /**
     * Bestimmt, ob die Werte der einzelnen Balkenst&uuml;cke in sie hineingeschrieben werden oder
     * nicht. Kann durch <code>setWriteValue()</code> ein- und ausgeschaltet werden.
     * @return	<code>true</code>, wenn Werte geschrieben werden. Sonst <code>false</code>.
     * @see #setShowValues(boolean)
     */
    public boolean isShowValues() {
        return writeValues;
    }

    /**
     * Methode des Interfaces <code>FLGBlackAndWhite</code>. Spezifiziert, ob die Komponente
     * farbig oder in Graut&ouml;nen gezeichnet werden soll.
     * @param	bw	soll die Komponente schwarz-weiss gezeichnet werden?
     */
    public void setBlackAndWhite(boolean bw) {
        this.bw = bw;
    }

    /**
     * Bestimmt, ob das Balkendiagramm schwarz-wei&szlig; gezeichnet wird, oder nicht. Kann durch
     * <code>setBlackAndWhite()</code> ein- und ausgeschaltet werden.
     * @return	<code>true</code>, wenn schwarz-wei&szlig; gezeichnet wird. Sonst <code>false</code>.
     * @see #setBlackAndWhite(boolean)
     */
    public boolean isBlackAndWhite() {
        return bw;
    }
    //
    // Paint Methods
    //

    /** Zeichnet dieses Balkendiagramm. */
    public void paint(Graphics g) {
        Graphics2D g2 = (Graphics2D)g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        super.paint(g);
        if (dataGroup.size() == 0) return;
        g.translate(getInsets().left, getInsets().top);
        init(g);
        int height = getBounds().height - getInsets().top - getInsets().bottom;
        int width = getBounds().width - getInsets().right - getInsets().left;
        calculateMargins(width, height);
        int areaWidth = width - leftMargin - rightMargin;
        int areaHeight = height - bottomMargin - topMargin;
        if (automatedYAxisLabeling) calculateYAxisLabelsPos(areaHeight);
        if (bw) g.setColor(Color.white); // schwarz weiss: weisser Hintergrund
        else
            g.setColor(BG_COLOR);
        g.fillRect(0, 0, width, height);
        if (paintGrid) {
            g.setColor(GRID_COLOR);
            paintGrid(g);
        }
        paintBars(g);
        g.setColor(Color.black);
        paintCoordSystem(g);
    }

    /** Zeichnet das Raster dieses Balkendiagrammes. */
    private void paintGrid(Graphics g) {
        int height = getBounds().height - getInsets().top - getInsets().bottom;
        int width = getBounds().width - getInsets().right - getInsets().left;
        int areaWidth = width - leftMargin - rightMargin;
        int areaHeight = height - bottomMargin - topMargin;
        g.drawRect(leftMargin, topMargin, areaWidth - 1, areaHeight - 1);
        for (int p = 0; p < noYAxisLabels; p++) {
            double fctY = yAxisLabelsPos[p];
            int areaPosY = areaHeight - 1 - (int)Math.round((fctY - dgMinValue) /
                (dgMaxValue - dgMinValue) * (areaHeight - 1));
            g.drawLine(leftMargin, areaPosY + topMargin, width - 1 - rightMargin, areaPosY + topMargin);
        }
    }

    /** Zeichnet das Koordinatensystem dieses Balkendiagrammes. */
    private void paintCoordSystem(Graphics g) {
        int height = getBounds().height - getInsets().top - getInsets().bottom;
        int width = getBounds().width - getInsets().right - getInsets().left;
        int areaWidth = width - leftMargin - rightMargin;
        int areaHeight = height - bottomMargin - topMargin;
        int x1, x2, y1, y2;
        int[] x = new int[3];
        int[] y = new int[3];
        Point xAxisEndPnt = new Point();
        Point yAxisEndPnt = new Point();
        int dirX = 1;
        int dirY = xAxisIsBottom() ? 1 : -1;
        // paint X-Axis-Line
        x1 = leftMargin;
        x2 = width - 1 - rightMargin;
        if (xAxisIsTotalTop()) {
            y1 = topMargin;
            y2 = y1;
        }
        else if (xAxisIsTotalBottom()) {
            y1 = height - 1 - bottomMargin;
            y2 = y1;
        }
        else {
            y1 = topMargin + areaHeight - 1 - (int)Math.round((-dgMinValue) / (dgMaxValue - dgMinValue) * (areaHeight - 1));
            y2 = y1;
        }
        xAxisEndPnt.x = x2;
        xAxisEndPnt.y = y2;
        g.drawLine(x1, y1, x2, y2);
        // paint X-Arrow
        x[0] = xAxisEndPnt.x + axis_arrow_totallength - 1;
        y[0] = xAxisEndPnt.y;
        x[1] = x[0] - (AXIS_ARROWTOP_LENGTH - 1);
        y[1] = y[0] - ((AXIS_ARROWTOP_WIDTH - 1) >> 1);
        x[2] = x[1];
        y[2] = y[0] + ((AXIS_ARROWTOP_WIDTH - 1) >> 1);
        g.drawLine(xAxisEndPnt.x, xAxisEndPnt.y, x[0] - 1, y[0]);
        g.fillPolygon(x, y, 3);
        // paint X-Name
        y1 = xAxisEndPnt.y - (fontHeight >> 1) + fontAscent;
        g.drawString(xAxisName, xAxisEndPnt.x + axis_arrow_totallength + AXISNAME_DIST_FROM_ARROW, y1);
        // paint Y-Axis-Line
        y1 = topMargin;
        y2 = height - 1 - bottomMargin;
        x1 = leftMargin;
        x2 = x1;
        g.drawLine(x1, y1, x2, y2);
        yAxisEndPnt.x = x1;
        yAxisEndPnt.y = y1;
        // paint Y-Arrow
        x[0] = yAxisEndPnt.x;
        y[0] = yAxisEndPnt.y - (axis_arrow_totallength - 1);
        x[1] = x[0] - ((AXIS_ARROWTOP_WIDTH - 1) >> 1);
        y[1] = y[0] + (AXIS_ARROWTOP_LENGTH - 1);
        x[2] = x[0] + ((AXIS_ARROWTOP_WIDTH - 1) >> 1);
        y[2] = y[1];
        g.drawLine(yAxisEndPnt.x, yAxisEndPnt.y, x[0], y[0] + 1);
        g.fillPolygon(x, y, 3);
        // paint Y-NAME
        x1 = yAxisEndPnt.x - (yAxisNameWidth >> 1);
        g.drawString(yAxisName, x1, yAxisEndPnt.y - axis_arrow_totallength - AXISNAME_DIST_FROM_ARROW -
            fontHeight + fontAscent);
        if (xLabelRows > 0) {
            // paint X-Axis Labels
            int yOffset; // für versetzte x-Labels.
            int noData = dataGroup.size();
            for (int d = 0; d < noData; d++) {
                String label = dataGroup.get(d).getName();
                int areaPosX = (int)((d + 0.5d) * ((areaWidth - 1) / (double)noData));
                // Den y Offset für dieses Label berechnen
                yOffset = (d % xLabelRows) * (LABEL_DIST_FROM_AXIS + fontHeight);
                g.drawLine(areaPosX + leftMargin, xAxisEndPnt.y, areaPosX + leftMargin,
                    xAxisEndPnt.y - dirY * LABEL_DIST_FROM_AXIS);
                int labelWidth = fm.stringWidth(label);
                // Die x-Achsenlabel werden jetzt abhängig von neg. od. pos. Werten
                // über oder unter der x-Achse geschrieben.
                if (dataGroup.get(d).getValue() > 0)
                    g.drawString(label, areaPosX + leftMargin - (labelWidth >> 1),
                        xAxisEndPnt.y + LABEL_DIST_FROM_AXIS + fontAscent + yOffset);
                else
                    g.drawString(label, areaPosX + leftMargin - (labelWidth >> 1),
                        xAxisEndPnt.y - LABEL_DIST_FROM_AXIS - fontHeight + fontAscent - yOffset);
            }
        }
        // paint Y-Axis Labels
        for (int p = 0; p < noYAxisLabels; p++) {
            double fctY = yAxisLabelsPos[p];
            int areaPosY = areaHeight - 1 - (int)Math.round((fctY - dgMinValue) /
                (dgMaxValue - dgMinValue) * (areaHeight - 1));
            g.drawLine(yAxisEndPnt.x, areaPosY + topMargin, yAxisEndPnt.x + dirX * LABEL_DIST_FROM_AXIS, areaPosY + topMargin);
            String label = createString(fctY);
            int labelWidth = fm.stringWidth(label);
            g.drawString(label, yAxisEndPnt.x - LABEL_DIST_FROM_AXIS - labelWidth,
                areaPosY + topMargin + fontAscent - (fontHeight >> 1));
        }
    }

    /** Zeichnet die Balken dieses Balkendiagrammes. */
    private void paintBars(Graphics g) {
        // Der Graphic2D Kontext für Texture Filling
        Graphics2D g2 = (Graphics2D)g;
        int noBars = dataGroup.size();
        int height = getBounds().height - getInsets().top - getInsets().bottom;
        int width = getBounds().width - getInsets().right - getInsets().left;
        int areaWidth = width - leftMargin - rightMargin;
        int areaHeight = height - bottomMargin - topMargin;
        double barAreaWidth = (areaWidth - 1) / (double)noBars;
        double barWidth = barAreaWidth * relBarWidth;
        int xAxisYPos;
        if (xAxisIsTotalTop()) xAxisYPos = topMargin;
        else if (xAxisIsTotalBottom()) xAxisYPos = height - 1 - bottomMargin;
        else
            xAxisYPos = topMargin + areaHeight - 1 -
                (int)Math.round((-dgMinValue) / (dgMaxValue - dgMinValue) * (areaHeight - 1));
        for (int b = 0; b < noBars; b++) {
            FLGData2D barData = dataGroup.get(b);
            double barValue = barData.getValue();
            int areaPosX1 = (int)((b + 0.5d) * barAreaWidth - 0.5d * barWidth + leftMargin);
            int areaPosX2 = (int)(areaPosX1 + barWidth);
            int areaPosY1 = xAxisYPos;
            int areaPosY2 = topMargin + areaHeight - 1 -
                (int)Math.round((barValue - dgMinValue) / (dgMaxValue - dgMinValue) * (areaHeight - 1));
            // Erzeuge das Balkenstück.
            Rectangle2D.Double bar;
            Point2D.Double start, end;
            if (areaPosY1 > areaPosY2) {
                start = new Point2D.Double(areaPosX1, areaPosY1);
                end = new Point2D.Double(areaPosX2, areaPosY2);
                bar = new Rectangle2D.Double(areaPosX1, areaPosY2, areaPosX2 - areaPosX1, areaPosY1 - areaPosY2);
            }
            else {
                start = new Point2D.Double(areaPosX1, areaPosY1);
                end = new Point2D.Double(areaPosX2, areaPosY2);
                bar = new Rectangle2D.Double(areaPosX1, areaPosY1, areaPosX2 - areaPosX1, areaPosY2 - areaPosY1);
            }
            // Zeichne das Balkenstück
            // setPaint in Abhängigkeit von den folgenden Einstellungen:
            // - hat das Datum eine zugewiesene Farbe
            // - soll in schwarz-weiß gezeichnet werden
            // - sollen Farbverläufe benutzt werden.
            //
            if (barData.getColor() != null) { // Datum hat Farbe
                if (bw) { // schwarz-weiss
                    if (FLGGraphics.isStandardColor(barData.getColor()) > -1)
                        g2.setPaint(FLGGraphics.getTextureForStandardColor(barData.getColor()));
                    else
                        g2.setPaint(FLGGraphics.getTexture(b));
                }
                else { // bunt
                    if (gradient) // mit Farbverlauf
                            g2.setPaint(FLGGraphics.getGradient(barData.getColor(), start, end));
                    else // ohne Farbverlauf
                            g2.setPaint(barData.getColor());
                }
            }
            else { // Datum ist keine Farbe zugewiesen
                if (bw) { // schwarz-weiss
                    g2.setPaint(FLGGraphics.getTextureForStandardColor(FLGGraphics.getStandardColor(b)));
                }
                else { // bunt
                    if (gradient) // mit Farbverlauf
                            g2.setPaint(FLGGraphics.getGradient(FLGGraphics.getStandardColor(b), start, end));
                    else // ohne Farbverlauf
                            g2.setPaint(FLGGraphics.getStandardColor(b));
                }
            }
            g2.fill(bar);
            // Zeichne den Balkenrahmen.
            g2.setPaint(FLGGraphics.standardOutlineColor);
            g2.draw(bar);
            // Zeichne den Wert in den Balken.
            if (writeValues) {
                String wert = createString(barValue);
                int wertWidth = fm.stringWidth(wert);
                int xPos = (int)(areaPosX1 + (areaPosX2 - areaPosX1) / 2 - wertWidth / 2);
                int yPos;
                if (barValue >= 0)
                    yPos = (int)(areaPosY2 + (areaPosY1 - areaPosY2) / 2 + fontHeight / 2);
                else
                    yPos = (int)(areaPosY1 + (areaPosY2 - areaPosY1) / 2 + fontHeight / 2);
                if (bw) { // wenn bw, dann hinter Text weiß machen.
                    g.setColor(Color.white);
                    g.fillRect(xPos - 1, yPos - (fontHeight + fontAscent) / 2, wertWidth + 2, fontHeight + 2);
                    g.setColor(Color.black);
                }
                else {
                    if (barData.getColor() != null)
                        // Farbe ist spezifiziert: suche passende Textfarbe für diese Farbe
                            g2.setColor(FLGGraphics.getTextColorFor(barData.getColor()));
                    else
                        // Farbe nicht spezifiziert: suche passende Textfarbe für den Index dieses Datums
                            g2.setColor(FLGGraphics.getTextColorFor(b));
                }
                g.drawString(wert, xPos, yPos);
            }
        }
    }
    //
    // Support Methods
    //

    /** Initialisiert dieses Balkendiagramm. */
    private void init(Graphics g) {
        if (!(initialized)) {
            initialized = true;
            fm = g.getFontMetrics();
            fontAscent = fm.getAscent();
            fontHeight = fontAscent + fm.getDescent();
            // Berechne dgRdMinValue und dgRdMaxValue
            int decPos = calcDecPos(dgMaxValue - dgMinValue);
            dgRdMinValue = calcFloor(dgMinValue, decPos);
            dgRdMaxValue = calcCeil(dgMaxValue, decPos);
            double range = dgRdMaxValue - dgRdMinValue;
            dgRdMinValue = correctDouble(dgRdMinValue, range);
            dgRdMaxValue = correctDouble(dgRdMaxValue, range);
            // Berechne maxXLabelWidth
            maxXLabelWidth = 0;
            for (int d = 0; d < dataGroup.size(); d++) {
                int w = fm.stringWidth(dataGroup.get(d).getName());
                if (w > maxXLabelWidth) maxXLabelWidth = w;
            }
            // Berechne maxYLabelWidth
            int w1 = fm.stringWidth(createString(dgRdMinValue) + ".99");
            int w2 = fm.stringWidth(createString(dgRdMaxValue) + ".99");
            if (w1 > w2) maxYLabelWidth = w1;
            else
                maxYLabelWidth = w2;
            // Berechne xAxisNameWidth, yAxisNameWidth, ...
            xAxisNameWidth = fm.stringWidth(xAxisName);
            yAxisNameWidth = fm.stringWidth(yAxisName);
            xAxisEndWidth = xAxisNameWidth + axis_arrow_totallength + AXISNAME_DIST_FROM_ARROW;
            yAxisEndHeight = fontHeight + axis_arrow_totallength + AXISNAME_DIST_FROM_ARROW;
        }
    }

    /** Berechnet die R&auml;nder f&uuml;r die spezifizierte Zeichenfl&auml;chengr&ouml;sse. */
    private void calculateMargins(int width, int height) {
        rightMargin = xAxisEndWidth;
        leftMargin = Math.max(yAxisNameWidth / 2, Math.max(maxXLabelWidth / 2, LABEL_DIST_FROM_AXIS + maxYLabelWidth));
        //AS: Berechnung Anzahl der ben&ouml;tigten Zeilen f&uuml;r die x-Achsen Labels.
        int areaWidth = width - leftMargin - rightMargin;
        if (dataGroup.size() * maxXLabelWidth <= areaWidth) xLabelRows = 1;
        else if (maxXLabelWidth / 2 > areaWidth) xLabelRows = 0;
        else
            xLabelRows = (int)Math.ceil((double)(maxXLabelWidth * dataGroup.size()) / areaWidth);
        if (xLabelRows > dataGroup.size()) xLabelRows = dataGroup.size();
        int xLabelHeight = xLabelRows * (fontHeight + LABEL_DIST_FROM_AXIS);
        topMargin = yAxisEndHeight;
        if (xAxisIsTop()) {
            bottomMargin = fontHeight >> 1;
            if (yAxisEndHeight < xLabelHeight) // evtl. top margin vergrössern.
                    topMargin = xLabelHeight;
        }
        else {
            if (xLabelRows > 0) bottomMargin = xLabelHeight;
            else
                bottomMargin = fontHeight >> 1;
            if (!(xAxisIsTotalBottom())) {
                int areaHeight = height - topMargin - bottomMargin;
                int yAreaPosXAxis = (int)(-dgMinValue / (dgMaxValue - dgMinValue) * (double)areaHeight);
                bottomMargin = Math.max(fontHeight >> 1, xLabelHeight - yAreaPosXAxis);
            }
        }
    }

    /** Berechnet die Positionen der <i>y</i>-Achsenbeschriftungen. */
    private void calculateYAxisLabelsPos(int areaHeight) {
        noYAxisLabels = 0;
        double stepYSize = calcOptYStepSize(areaHeight);
        for (double fctY = dgRdMinValue; fctY <= dgRdMaxValue; fctY += stepYSize) {
            fctY = correctDouble(fctY, dgRdMaxValue - dgRdMinValue);
            if (dgMinValue <= fctY && fctY <= dgMaxValue) yAxisLabelsPos[noYAxisLabels++] = fctY;
        }
    }

    /**
     * Korrigiert die Genauigkeit der spezifizierten <code>double</code>-Zahl <i>d</i>.
     * Normalerweise wird auf 3 Nachkommastellen gerundet. Liegt range zwischen 0.1 und 1, dann
     * wird auf 4 Stellen gerundet. Liegt range zwischen 0.01 und 0.1, dann wird auf 5 Stellen gerundet, etc.
     */
    private double correctDouble(double d, double range) {
        int genauigkeit = 3;
        int decPos = calcDecPos(range);
        if (decPos < 0) genauigkeit += -decPos;
        return Math.round(d * Math.pow(10d, genauigkeit)) / Math.pow(10d, genauigkeit);
    }

    /**
     * Berechnet die optimale Schrittweite der <i>y</i>-Achse f&uum;r die spezifizierte Anzeigeh&ouml;he.
     * @param	areaHeight	die Anzeigeh&ouml;he.
     * @return						die optimale Schrittweite.
     */
    private double calcOptYStepSize(int areaHeight) {
        double[] sectionSizes = {40,20,10,5,4,2};
        for (int s = 0; s < sectionSizes.length; s++) {
            double stepSize = (dgRdMaxValue - dgRdMinValue) / sectionSizes[s];
            int noLabelsInDomain = 0;
            for (double fctY = dgRdMinValue; fctY <= dgRdMaxValue; fctY += stepSize)
                if (dgMinValue <= fctY && fctY <= dgMaxValue) noLabelsInDomain++;
            if (fontHeight * noLabelsInDomain < areaHeight && noLabelsInDomain <= maxNoAxisLabels)
                return stepSize;
        }
        return (dgRdMaxValue - dgRdMinValue);
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	calcDecPos
    // 100 --> 2; 10 --> 1; 1 --> 0; 0 --> 0; 0.1 --> -1; 0.01 --> -2;
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private int calcDecPos(double d) {
        double absD = Math.abs(d);
        if (absD == 0) return 0;
        int decPos = 0;
        if (absD >= 1) {
            while (absD >= 0.999999999999) {
                absD /= 10f;
                decPos++;
            }
            decPos--;
        }
        else {
            while (absD <= 0.999999999999) {
                absD *= 10f;
                decPos--;
            }
        }
        return decPos;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	calcFloor
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private double calcFloor(double d, int decPos) {
        double verySmall = 0.0001;
        double floor = Math.floor(verySmall + d * Math.pow(10d, (double) - decPos)) * Math.pow(10d, (double)decPos);
        return floor;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	calcCeil
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private double calcCeil(double d, int decPos) {
        double verySmall = 0.0001;
        double floor = Math.ceil(d * Math.pow(10d, (double) - decPos) - verySmall) * Math.pow(10d, (double)decPos);
        return floor;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	createString
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private String createString(double d) {
        String s = String.valueOf(d);
        int l = s.length();
        if (s.charAt(l - 2) == '.' && s.charAt(l - 1) == '0') s = s.substring(0, l - 2);
        return s;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // SUPPORT:	axis position
    //////////////////////////////////////////////////////////////////////////////////////////////////
    private boolean xAxisIsBottom() { return (dgMinValue + dgMaxValue) / 2 >= 0; }

    private boolean xAxisIsTop() { return (dgMinValue + dgMaxValue) / 2 < 0; }

    private boolean xAxisIsTotalBottom() { return dgMinValue >= 0; }

    private boolean xAxisIsTotalTop() { return dgMaxValue <= 0; }

    public static void main(String[] args) {
        JFrame frame = new JFrame("Beispiel 2");
        FLGDataGroup2D data = new FLGDataGroup2D();
        data.add(new FLGData2D("Alex", 25, java.awt.Color.green));
        data.add(new FLGData2D("Andrea", 32, java.awt.Color.red));
        data.add(new FLGData2D("Daniel", 23, java.awt.Color.blue));
        FLGBarChart2D barchart = new FLGBarChart2D(data, "Name", "Alter");
        double[] labels = {0, 23, 25, 32};
        barchart.setYAxisLabelsPos(labels);
        barchart.setPaintWithGradient(true);
        barchart.setShowValues(true);
        frame.getContentPane().add(barchart);
        frame.setSize(600, 500);
        frame.setVisible(true);
    }
}
