/* Generated by Freestyle Learning Group */

package freestyleLearningGroup.independent.world3D;

import java.awt.Color;
import java.awt.Graphics;

/**
 * Ein dreidimensionales Objekt, das einer 3D Welt, die es enth&auml;lt, zugeordnet ist. Das
 * Objekt wird definiert durch seine Punkte, die zu Fl&aumlchen zusammengefasst werden.<p> Sind
 * einer oder mehrere Punkte indirekt definiert, sprich: durch einen anderen Punkt und einen Vektor, der die relative Position
 * zu diesem Punkt ausdr&uuml;ckt, muss neben dem <code>FLGPoint</code>-Punkte-Array auch ein
 * <code>FLGPoint</code>-Vektoren-Array &uuml;bergeben werden.<p> Die 3D Welt, der dieses Objekt zugeordnet werden soll, muss
 * vor den Objekten erzeugt werden, damit ein Verweis zu der Welt an den Konstruktor des Objektes
 * &uuml;bergeben werden kann. Nach Erzeugung der Objekte werden diese dann wiederum an die 3D
 * Welt durch deren Methode <code>setObjects</code> &uuml;bergeben.<p>
 * Weitere Optionen eines 3D Objektes sind die einzelnen Fl&auml;chen des Objektes
 * mit einer d&uuml;nnen Linie zu umranden, den Rotationspunkt zu ver&auml;ndern und das Objekt zu
 * verschieben.<p> <p> <b>Beispiel</b>: Erzeugt eine Pyramide. Diese Pyramide hat verschiedene
 * Farben f&uuml;r alle f&uuml;nf Fl&auml;chen. und kann durch nur f&uuml;nf Punkte definiert werden. <p> <pre>
 * 		javax.swing.JFrame frame = new javax.swing.JFrame("Test");
 *
 *		FLGWorld3D myWorld3d = new FLGWorld3D(frame);
 *		
 *		FLGFace[] faces  = new FLGFace[5];
 *
 *		FLGPoint[] points = new FLGPoint[5];
 *		points[0]  = new FLGPoint(0.0, 0.0, 0.0);
 *		points[1]  = new FLGPoint(0.0, 100.0, 0.0);
 *		points[2]  = new FLGPoint(100.0, 100.0, 0.0);
 *		points[3]  = new FLGPoint(100.0, 0.0, 0.0);
 *		points[4]  = new FLGPoint(50.0, 50.0, 100.0);
 *		
 *		int[] pointsInd = {0, 1, 2, 3};
 *		faces[0]  = new FLGFace(pointsInd, Color.yellow);
 *		faces[1]  = new FLGFace(0, 1, 4, Color.red);
 *		faces[2]  = new FLGFace(1, 2, 4, Color.magenta);
 *		faces[3]  = new FLGFace(2, 3, 4, Color.green);
 *		faces[4]  = new FLGFace(3, 0, 4, Color.blue);
 *		
 *		FLGObj3D[] objects = new FLGObj3D[1];
 *		
 *		objects[0] = new FLGObj3D(points, faces, null, 0, true, false, myWorld3d);
 *  </pre> </p>
 * @see FLGPoint
 * @see FLGFace
 * @see FLGWorld3D
 */
public class FLGObj3D {
    private final static int POINTS = 10000;

    /** Die Punkte dieses 3D Objektes. */
    public FLGPoint[] points;

    /** Die Fl&auml;chen dieses 3D Objektes. */
    public FLGFace[] faces;

    /** Die Vektoren dieses 3D Objektes. */
    public FLGPoint[] vectors;

    /** Die Tiefe des Objektes. */
    private double z;

    /**
     * Sollen die Fl&auml;chen mit einem Rand gezeichnet werden ? Als Standard werden die Fl&auml;chen ohne Rand gezeichnet.
     * @deprecated	Neue Programme sollten auf dieses Feld nicht mehr direkt zugreifen, sondern
     * die Methoden <code>setOutline</code> und <code>getOutline</code>benutzen.
     * @see					#setOutlineFaces(boolean outlineFaces)
     * @see					#getOutlineFaces()
     */
    private boolean outlineFaces = false;
    private FLGWorld3D world3D;
    private int trMatrixInd; // index for the transformation matrix
    private double[] [] trMatrix; // transformation matrix
    private double addX;
    private double addY;
    private double addZ;
    private FLGPoint rotPnt = new FLGPoint(0, 0, 0); // rotation point
    private boolean light = false;
    private boolean hideFaces = false;
    private FLGPoint viewPoint;
    // only for temporary calculat
    private static FLGPoint[] prPoints = new FLGPoint[POINTS]; // projected points 	(2D)
    private static FLGPoint[] trPoints = new FLGPoint[POINTS]; // transformed points	(3D)
    private static FLGPoint[] trVectors = new FLGPoint[POINTS];
    private static int[] [] prFacesX = new int[POINTS] [30];
    private static int[] [] prFacesY = new int[POINTS] [30];
    private static int[] prFacesZ = new int[POINTS];
    private static int[] facesInd = new int[POINTS];
    private static int[] prFacesInd = new int[POINTS];
    private static FLGPoint point = new FLGPoint();
    private static FLGFace face;
    private static FLGPoint trViewPoint = new FLGPoint(); // transformed viewpoint	
    private static int faceSize;
    private static double lightVectorX;
    private static double lightVectorY;
    private static double lightVectorZ;

    static {
        for (int p = 0; p < prPoints.length; p++) prPoints[p] = new FLGPoint();
        for (int p = 0; p < trPoints.length; p++) trPoints[p] = new FLGPoint();
        for (int v = 0; v < trVectors.length; v++) trVectors[v] = new FLGPoint();
    }

    /**
     * Erzeugt und initialisiert ein 3D Objekt mit den spezifizierten Parametern. Das 3D Objekt
     * ist nicht beleuchtet und ist durchscheinend.
     * @param	points			die Punkte dieses 3D Objektes.
     * @param faces				die Fl&auml;chen dieses 3D Objektes.
     * @param trMatrixInd	der Index f&uuml;r die Transformationsmatrix.
     * @param world3D			die 3D Welt, zu der dieses Objekt geh&ouml;rt.
     */
    public FLGObj3D(FLGPoint[] points, FLGFace[] faces, int trMatrixInd, FLGWorld3D world3D) {
        this(points, faces, null, trMatrixInd, false, false, world3D);
    }

    /**
     * Erzeugt und initialisiert ein 3D Objekt mit den spezifizierten Parametern.
     * @param	points			die Punkte dieses 3D Objektes.
     * @param faces				die Fl&auml;chen dieses 3D Objektes.
     * @param vectors			die Vektoren dieses 3D Objektes.
     * @param trMatrixInd	der Index f&uuml;r die Transformationsmatrix.
     * @param light				soll das Objekt beleuchtet werden?
     * @param hideFaces		sollen vorne liegende Fl&auml;chen dahinterliegende Fl&auml;chen
     * verdecken (<code>true</code>) oder soll das Modell durchscheinend (<code>false</code>)sein ?
     * @param world3D			die 3D Welt, zu der dieses Objekt geh&ouml;rt.
     */
    public FLGObj3D(FLGPoint[] points, FLGFace[] faces, FLGPoint[] vectors, int trMatrixInd, boolean light,
        boolean hideFaces, FLGWorld3D world3D) {
            // AS if (!(classInitialized))	initClass();
            this.points = points;
            this.faces = faces;
            this.vectors = vectors;
            this.trMatrixInd = trMatrixInd;
            this.light = light;
            this.hideFaces = hideFaces;
            this.world3D = world3D;
            this.viewPoint = world3D.getViewPoint();
            this.trMatrix = world3D.getTrMatrix(trMatrixInd);
            addX = 0;
            addY = 0;
            addZ = 0;
            // Initialisierung des z-Wertes des Objekts
            int i = 0;
            while (points[i].indirect) i++;
            z = points[i].z;
            for (int f = 0; f < faces.length; f++) faces[f].calculate(this);
    }

    /**
     * Je nach spezifiziertem Wert, werden die Fl&auml;chen des Objekts mit oder ohne Rand gezeichnet.
     * @param	outlineFaces	mit (<code>true</code>) oder ohne (<code>false</code>) Rand zeichnen?
     */
    public void setOutlineFaces(boolean outlineFaces) {
        this.outlineFaces = outlineFaces;
    }

    /**
     * Liefert <code>true</code> oder <code>false</code> je nachdem, ob die Fl&auml;chen mit oder ohne Rand gezeichnet werden.
     * @return	mit (<code>true</code>) oder ohne (<code>false</code>) Rand zeichnen.
     */
    public boolean getOutlineFaces() {
        return outlineFaces;
    }

    /**
     * Setzt den Rotationspunkt dieses 3D Objektes.
     * @param	x,&nbsp;y,&nbsp;z	die Koordinaten des Rotationspunktes.
     */
    public void setRotPoint(double x, double y, double z) {
        rotPnt.x = x;
        rotPnt.y = y;
        rotPnt.z = z;
    }

    /**
     * Verschiebt das 3D Objekt um die spezifizierten Werte.
     * @param	x	der Wert um den das 3D Objekt entlang der <i>x</i>-Achse verschoben wird.
     * @param	y	der Wert um den das 3D Objekt entlang der <i>y</i>-Achse verschoben wird.
     * @param	z	der Wert um den das 3D Objekt entlang der <i>z</i>-Achse verschoben wird.
     */
    public void move(double x, double y, double z) {
        addX += x;
        addY += y;
        addZ += z;
        this.z += z;
    }

    /**
     * Liefert die <i>z</i>-Koordinate des ersten Punktes dieses Objekts. Diese Methode dient der
     * Sortierung der Objekte in einer 3D Welt.
     * @return	der <i>z</i>-Wert dieses Objekts.
     */
    protected double getZ() {
        return z;
    }

    /** sortFaces */
    private void sortFaces(int left, int right) {
        int i, j, e, tempE;
        i = left;
        j = right;
        if (j > i) {
            e = prFacesZ[prFacesInd[(left + right) >> 1]];
            do {
                while (prFacesZ[prFacesInd[i]] < e) { i++; }
                while (prFacesZ[prFacesInd[j]] > e) { j--; }
                if (i <= j) {
                    tempE = prFacesInd[i];
                    prFacesInd[i] = prFacesInd[j];
                    prFacesInd[j] = tempE;
                    i++;
                    j--;
                }
            }
            while (i <= j);
            sortFaces(left, j);
            sortFaces(i, right);
        }
    }

	/*
	 * 3D transformation (normally rotation)
	 */

    private void transformPoint(FLGPoint point, FLGPoint rotPnt) {
        double x, y, z;
        x = point.x;
        y = point.y;
        z = point.z;
        x -= rotPnt.x;
        y -= rotPnt.y;
        z -= rotPnt.z;
        point.x = trMatrix[0] [0] * x + trMatrix[0] [1] * y + trMatrix[0] [2] * z;
        point.y = trMatrix[1] [0] * x + trMatrix[1] [1] * y + trMatrix[1] [2] * z;
        point.z = trMatrix[2] [0] * x + trMatrix[2] [1] * y + trMatrix[2] [2] * z;
        point.x += rotPnt.x;
        point.y += rotPnt.y;
        point.z += rotPnt.z;
    }

    private void transformPointBack(FLGPoint point, FLGPoint rotPnt) {
        double x, y, z;
        x = point.x;
        y = point.y;
        z = point.z;
        x -= rotPnt.x;
        y -= rotPnt.y;
        z -= rotPnt.z;
        point.x = trMatrix[0] [0] * x + trMatrix[1] [0] * y + trMatrix[2] [0] * z;
        point.y = trMatrix[0] [1] * x + trMatrix[1] [1] * y + trMatrix[2] [1] * z;
        point.z = trMatrix[0] [2] * x + trMatrix[1] [2] * y + trMatrix[2] [2] * z;
        point.x += rotPnt.x;
        point.y += rotPnt.y;
        point.z += rotPnt.z;
    }

    /** 3D to 2D transformation routines */
    private double projectXCoord(double x, double z) {
        return world3D.getScaleFactor() * (viewPoint.z * x) / (viewPoint.z - z) + world3D.getDisplayAreaOffsX();
    }

    private double projectYCoord(double y, double z) {
        return world3D.getScaleFactor() * -((viewPoint.z * y) / (viewPoint.z - z)) + world3D.getDisplayAreaOffsY();
    }

    /** Store Point. */
    private void storePoint(FLGPoint point, int ind) {
        double x = point.x, y = point.y, z = point.z;
        x += addX;
        y += addY;
        z += addZ;
        prPoints[ind].x = projectXCoord(x, z);
        prPoints[ind].y = projectYCoord(y, z);
        prPoints[ind].z = z;
        trPoints[ind].x = x;
        trPoints[ind].y = y;
        trPoints[ind].z = z;
    }

    /** Calculate Face. */
    private void calcFace(FLGFace face, int prFaceNo, int faceNo, FLGPoint rotPnt) {
        double x, y, z;
        double faceAvgZ = 0;
        int brightness = 0;
        FLGPoint vector;
        int pntInd;
        FLGPoint refPnt;
        int refPntInd;
        FLGPoint pntObjSpace;
        if (light) {
            brightness = (int)((face.normVect.x * lightVectorX + face.normVect.y * lightVectorY + face.normVect.z *
                lightVectorZ) * 127d);
            if (brightness > 127) face.brightness = 127;
            else if (brightness < 0) face.brightness = 0;
            else
                face.brightness = brightness;
        }
        for (int p = 0; p < face.getSize(); p++) {
            pntInd = face.points[p];
            if (!(prPoints[pntInd].calculated)) {
                prPoints[pntInd].calculated = true;
                pntObjSpace = points[pntInd];
                if (pntObjSpace.indirect) {
                    refPntInd = pntObjSpace.pntInd;
                    if (!(prPoints[refPntInd].calculated)) {
                        prPoints[refPntInd].calculated = true;
                        refPnt = points[refPntInd];
                        point.x = refPnt.x;
                        point.y = refPnt.y;
                        point.z = refPnt.z;
                        transformPoint(point, rotPnt);
                        storePoint(point, refPntInd);
                    }
                    vector = trVectors[pntObjSpace.vectInd];
                    refPnt = trPoints[refPntInd];
                    x = refPnt.x + vector.x;
                    y = refPnt.y + vector.y;
                    z = refPnt.z + vector.z;
                    prPoints[pntInd].x = projectXCoord(x, z);
                    prPoints[pntInd].y = projectYCoord(y, z);
                    prPoints[pntInd].z = z;
                }
                else {
                    point.x = pntObjSpace.x;
                    point.y = pntObjSpace.y;
                    point.z = pntObjSpace.z;
                    transformPoint(point, rotPnt);
                    storePoint(point, pntInd);
                }
            }
            prFacesX[prFaceNo] [p] = (int)prPoints[pntInd].x;
            prFacesY[prFaceNo] [p] = (int)prPoints[pntInd].y;
            faceAvgZ += prPoints[pntInd].z;
        }
        prFacesInd[prFaceNo] = prFaceNo;
        prFacesZ[prFaceNo] = (int)(faceAvgZ / face.getSize());
        facesInd[prFaceNo] = faceNo;
    }

    /**
     * Zeichnet das 3D Objekt. Muß nicht vom Benutzer aufgerufen werden, da es
     * bei Bedarf automatisch von der 3D Welt, die dieses Objekt enth&auml;lt aufgerufen wird.
     * @param	g	der Grafikkontext indem das Objekt gezeichnet werden soll.
     */
    synchronized public void paint(Graphics g) {
        FLGPoint vector;
        int prFaceNo = 0;
        for (int p = 0; p < points.length; p++) prPoints[p].calculated = false;
        // rotate all 'vectors'
        if (vectors != null) {
            for (int v = 0; v < vectors.length; v++) {
                vector = vectors[v];
                point.x = vector.x;
                point.y = vector.y;
                point.z = vector.z;
                transformPoint(point, rotPnt);
                vector = trVectors[v];
                vector.x = point.x;
                vector.y = point.y;
                vector.z = point.z;
            }
        }
        // calculate view-vector
        if (light | hideFaces) {
            point.x = viewPoint.x - addX;
            point.y = viewPoint.y - addY;
            point.z = viewPoint.z - addZ;
            transformPointBack(point, rotPnt);
            trViewPoint.x = point.x;
            trViewPoint.y = point.y;
            trViewPoint.z = point.z;
        }
        // calculate light-vector
        if (light) {
            double lx, ly, lz, ll;
            lx = trViewPoint.x;
            ly = trViewPoint.y;
            lz = trViewPoint.z;
            ll = Math.sqrt(lx * lx + ly * ly + lz * lz);
            lightVectorX = lx / ll;
            lightVectorY = ly / ll;
            lightVectorZ = lz / ll;
        }
        // calculate all faces
        for (int f = 0; f < faces.length; f++) {
            face = faces[f];
            if (hideFaces) {
                double dist = face.normVect.x * trViewPoint.x + face.normVect.y * trViewPoint.y + face.normVect.z *
                    trViewPoint.z + face.dist;
                if (dist > 0) {
                    calcFace(face, prFaceNo, f, rotPnt); // if face is visible
                    prFaceNo++;
                }
            }
            else {
                calcFace(face, prFaceNo, f, rotPnt);
                prFaceNo++;
            }
        }
        // Sort the faces of the current object by their depth
        sortFaces(0, prFaceNo - 1);
        // Draw the current object
        for (int f = 0; f < prFaceNo; f++) {
            face = faces[facesInd[prFacesInd[f]]];
            if (light) g.setColor(face.colors[face.brightness]);
            else
                g.setColor(face.color);
            g.fillPolygon(prFacesX[prFacesInd[f]], prFacesY[prFacesInd[f]], face.getSize());
            if (outlineFaces) {
                g.setColor(Color.darkGray);
                g.drawPolygon(prFacesX[prFacesInd[f]], prFacesY[prFacesInd[f]], face.getSize());
            }
        }
    }
}
