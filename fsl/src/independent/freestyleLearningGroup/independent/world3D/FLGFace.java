/* Generated by Freestyle Learning Group */

package freestyleLearningGroup.independent.world3D;

import java.awt.Color;

/**
 * <code>FLGFace</code> repr&auml;sentiert eine Fl&auml;che im dreidimensionalen Koordinatenraum,
 * spezifiziert durch eine Menge von Punkten und einer Farbe.<p> Die Punkte, deren Indizes hier
 * &uuml;bergeben werden und durch die diese Fl&aumlche
 * beschrieben wird, sind in dem 3D Objekt zu dem diese <code>FLGFace</code> geh&ouml;rt
 * gespeichert.<p> Dass die Indizes der Punkte, die an dieses <code>FLGFace</code> &uuml;bergeben
 * werden, in die an das 3D Objekt, zu dem diese Fl&auml;che geh&ouml;rt, &uuml;bergeben Punkte
 * passen, liegt in der Verantwortlichkeit des Benutzers.<p> Die spezifizierte Farbe wird zudem in
 * 128 dunkleren Schattierungen berechnet und in dem Feld <code>colors[]</code> gespeichert. Diese
 * Information kann f&uuml;r eine standardisierte Vorgehensweise bei
 * gew&uuml;nschtem Lichteinfall und abh&auml;ngig vom Standpunkt genutzt werden.<p>
 * <b>Beispiel</b>: Erzeugt eine <code>FLGFace</code>-Array, welches die Beschreibung einer
 * f&uuml;nfeckigen Fl&aumlche und eines Dreiecks enth&auml;lt. Das
 * passende <code>FLGPoint</code>-Array muss mit dem <code>FLGFace</code>-Array
 * an den Konstruktor eines <code>FLGObj3D</code> &uuml;bergeben werden. Denkbar ist hier ein
 * Array, dessen ersten 5 Punkte das Pentagon beschreiben und die Punkte 6 bis 8 das Dreieck. <p> <pre>
 *	FLGFace[] faces  = new FLGFace[2];
 *
 *	int[] points = {0, 1, 2, 3, 4};
 *
 *	faces[0]  = new FLGFace(points, Color.yellow);
 *	faces[1]  = new FLGFace(5, 6, 7, Color.red);
 *  </pre> </p>
 * @see FLGPoint
 * @see FLGObj3D
 */
public class FLGFace {
    /** Der Normalvektor dieses <code>FLGFace</code> */
    protected FLGPoint normVect;

    /** Die Punkte die diese Fl&auml;che bilden. */
    public int[] points;

    /** Die Distanz dieses <code>FLGFace</code>. */
    public double dist;

    /** Die Farbe dieses <code>FLGFace</code>. */
    protected Color color;

    /** Die Farbe dieses <code>FLGFace</code> als <code>Array</code> von 128 abgestuften Intensit&auml;ten. */
    protected Color[] colors = new Color[128];

    /** Die Intensit&auml;t der Farbe dieses <code>FLGFace</code>. Initial 127 = die kr&auml;ftigste Farbe. */
    protected int brightness = 127;

    /**
     * Erzeugt ein <code>FLGFace</code> und initialisiert es mit den spezifizierten Punkten und
     * der spezifizierten Farbe. Die Punkte sind hier die Positionen der Punkte in dem an das
     * <code>FLGObj3D</code> Punkte-Array.
     * @see		FLGObj3D#FLGObj3D(	FLGPoint[] points, FLGFace[] faces, FLGPoint[] vectors, int
     * trMatrixInd, boolean light, boolean hideFaces, LGWorld3D world3D)
     * @param	points	die Punkte die zu diesem <code>FLGFace</code> geh&ouml;ren.
     * @param color		die Farbe dieser Fl&auml;che.
     */
    public FLGFace(int[] points, Color color) {
        init(points, color);
    }

    /**
     * Vereinfachter Konstruktor f&uuml;r eine dreieckige Fl&auml;che.
     * @param p0,&nbsp;p1,&nbsp;p2	die drei Punkte, die diese Fl&auml;che definieren.
     * @param color		die Farbe dieser Fl&auml;che.
     */
    public FLGFace(int p0, int p1, int p2, Color color) {
        int[] p = new int[3];
        p[0] = p0;
        p[1] = p1;
        p[2] = p2;
        init(p, color);
    }

    /**
     * Vereinfachter Konstruktor f&uuml;r eine viereckige Fl&auml;che.
     * @param p0,&nbsp;p1,&nbsp;p2,&nbsp;p3	die vier Punkte, die diese Fl&auml;che definieren.
     * @param color		die Farbe dieser Fl&auml;che.
     */
    public FLGFace(int p0, int p1, int p2, int p3, Color color) {
        int[] p = new int[4];
        p[0] = p0;
        p[1] = p1;
        p[2] = p2;
        p[3] = p3;
        init(p, color);
    }

    /**
     * Neben der einfachen Initialiserung, wird hier die angegebene Farbe in 128 dunkleren
     * Schattierungen berechnet und in <code>colors</code> gespeichert. Genutzt wird dies f&uuml;r
     * ein realistischeres aussehen der Objekte, je nach Blickwinkel.
     */
    private void init(int[] points, Color color) {
        this.points = points;
        this.color = color;
        int red = color.getRed();
        int green = color.getGreen();
        int blue = color.getBlue();
        for (int i = 0; i < 128; i++)
            colors[i] = new Color((red >> 1) + ((i * red) >> 8), (green >> 1) + ((i * green) >> 8),
                (blue >> 1) + ((i * blue) >> 8));
    }

    /**
     * Liefert die Anzahl der Punkte durch die dieses Fl&auml;che definiert ist, bspw. 4 f&uuml;r ein Quadrat.
     * @return	Anzahl der Punkte.
     */
    public int getSize() {
        return points.length;
    }

    /**
     * Berechnet den Normalvektor und die Distanz dieser Fläche des spezifizierten 3D Objekts auf
     * Basis der ersten 3 Punkte dieser Fl&auml;che.
     * @param	obj	das 3D Objekt.
     */
    public void calculate(FLGObj3D obj) {
        double ax, ay, az;
        double bx, by, bz;
        FLGPoint p0, p1, p2;
        double nx, ny, nz;
        double length;
        p0 = obj.points[points[0]];
        p1 = obj.points[points[1]];
        p2 = obj.points[points[2]];
        if (p0.indirect) {
            FLGPoint ref = obj.points[p0.pntInd];
            FLGPoint vect = obj.vectors[p0.vectInd];
            p0.x = ref.x + vect.x;
            p0.y = ref.y + vect.y;
            p0.z = ref.z + vect.z;
        }
        if (p1.indirect) {
            FLGPoint ref = obj.points[p1.pntInd];
            FLGPoint vect = obj.vectors[p1.vectInd];
            p1.x = ref.x + vect.x;
            p1.y = ref.y + vect.y;
            p1.z = ref.z + vect.z;
        }
        if (p2.indirect) {
            FLGPoint ref = obj.points[p2.pntInd];
            FLGPoint vect = obj.vectors[p2.vectInd];
            p2.x = ref.x + vect.x;
            p2.y = ref.y + vect.y;
            p2.z = ref.z + vect.z;
        }
        ax = p1.x - p0.x;
        ay = p1.y - p0.y;
        az = p1.z - p0.z;
        bx = p2.x - p1.x;
        by = p2.y - p1.y;
        bz = p2.z - p1.z;
        nx = ay * bz - az * by;
        ny = az * bx - ax * bz;
        nz = ax * by - ay * bx;
        length = Math.sqrt(nx * nx + ny * ny + nz * nz);
        nx = nx / length;
        ny = ny / length;
        nz = nz / length;
        normVect = new FLGPoint(nx, ny, nz);
        dist = -(normVect.x * obj.points[points[0]].x + normVect.y * obj.points[points[0]].y + normVect.z *
            obj.points[points[0]].z);
    }

    /** Gibt den durch die Punkte und den Normalvektor belegten Speicherplatz frei. */
    protected void finalize() {
        points = null;
        normVect = null;
    }
}
