/* The following code was generated by JFlex 1.3.5 on 22.01.04 02:53 */
/* UserCode */
/* will be copied verbatim into the beginning of the source file of the generated lexer */
package org.openuss.openformula.mathml.in;

import org.openuss.openformula.mathml.in.java_cup.runtime.Symbol;


/**
 * This class is a scanner generated by
 * <a href="http://www.jflex.de/">JFlex</a> 1.3.5
 * on 22.01.04 02:53 from the specification file
 * <tt>file:/D:/openuss/dev-formula-editor/business/src/org/openuss/business/extension/formula/mathml/in/MyMathML.flex</tt>
 */
public class Scanner extends sym
    implements org.openuss.openformula.mathml.in.java_cup.runtime.Scanner {
    /** This character denotes the end of file */
    final public static int YYEOF = -1;

    /** initial size of the lookahead buffer */
    final private static int YY_BUFFERSIZE = 16384;

    /** lexical states */
    final public static int TEXT = 1;
    final public static int YYINITIAL = 0;
    final public static int CHARLITERAL = 1;

    /**
     * Translates characters to character classes
     */
    final private static String yycmap_packed = 
        "\11\0\1\3\1\2\1\0\1\3\1\1\22\0\1\3\1\5\1\15" + 
         "\1\11\1\0\1\14\1\10\6\14\1\6\1\22\1\21\12\16\1\14" + 
         "\1\12\1\4\1\26\1\7\1\14\1\0\32\13\3\14\1\0\1\14" + 
         "\1\0\1\23\1\43\1\33\1\41\1\34\1\37\1\13\1\25\1\31" + 
         "\2\13\1\45\1\17\1\30\1\27\1\32\1\40\1\35\1\20\1\24" + 
         "\1\42\1\44\1\36\3\13\4\14\105\0\1\14\21\0\1\14\5\0" + 
         "\1\14\7\0\1\14\21\0\1\14\5\0\1\14\uff03\0";

    /**
     * Translates characters to character classes
     */
    final private static char[] yycmap = yy_unpack_cmap(yycmap_packed);

    /**
     * Translates a state to a row index in the transition table
     */
    final private static int[] yy_rowMap = {
        0, 38, 76, 114, 76, 152, 76, 76, 190, 228, 266, 304, 342, 380, 418, 456, 
        494, 532, 570, 228, 608, 304, 646, 684, 722, 760, 798, 836, 874, 912, 
        950, 988, 1026, 1064, 1102, 1140, 1178, 1216, 1254, 1292, 1330, 1368, 
        1406, 1444, 1482, 1520, 76, 1558, 76, 76, 1596, 1634, 1672, 1710, 1748, 
        1786, 1824, 1862, 1900, 1938, 1976, 2014, 2052, 2090, 2128, 76, 2166, 
        2204, 2242, 2280, 2318, 2356, 2394, 2432, 76, 76, 2470, 2508, 2546, 
        2584, 2622, 2660, 2698, 2736, 2774, 2812, 2850, 2888, 2926, 76, 2964, 
        76, 76, 3002, 3040, 3078, 3116, 3154, 3192, 3230, 3268, 3306, 76, 76, 
        3344, 3382, 76, 3420, 3458, 3496, 76, 3534, 3572, 3610, 76, 3648, 3686, 
        3724, 3762, 3800, 76, 76, 3838, 3876, 3914, 3952, 3990, 4028, 4066, 
        4104, 4142, 76, 4180, 4218, 4256, 76, 76, 4294, 76, 4332, 4370, 76, 76, 
        4408, 76, 4446, 4484, 4522, 76, 4560, 4598, 4636, 4674, 4712, 4750, 
        4788, 4826, 4864, 76, 76, 76, 4902, 76, 4940, 4978, 76, 76, 5016, 76, 
        5054, 5092, 5130, 76, 76, 5168, 5206, 5244, 76, 5282, 76, 5320, 76, 76, 
        5358, 76, 76, 5396, 5434, 5472, 76, 5510, 76
    };

    /**
     * The packed transition table of the DFA (part 0)
     */
    final private static String yy_packed0 = "\1\3\1\4\2\5\1\6\2\7\1\10\1\11\2\7" + 
                                             "\1\12\1\7\1\3\1\13\2\12\1\7\1\14\3\12" + 
                                             "\1\7\17\12\46\3\50\0\1\5\50\0\1\15\11\0" + 
                                             "\1\16\1\0\1\17\11\0\1\20\23\0\1\21\1\0" + 
                                             "\1\22\3\0\2\22\2\0\3\22\1\0\17\22\1\0" + 
                                             "\3\23\7\0\1\24\2\0\3\24\2\0\3\24\1\25" + 
                                             "\17\24\16\0\1\13\3\0\1\26\41\0\1\26\35\0" + 
                                             "\1\27\57\0\1\30\2\0\1\31\1\32\2\0\1\33" + 
                                             "\1\34\1\35\3\0\1\36\1\0\1\37\2\0\1\40" + 
                                             "\1\41\21\0\1\42\70\0\1\43\21\0\1\44\41\0" + 
                                             "\1\7\1\22\3\0\2\22\2\0\3\22\1\0\17\22" + 
                                             "\1\0\3\23\22\0\1\25\34\0\1\45\36\0\1\46" + 
                                             "\46\0\1\47\22\0\1\50\5\0\1\51\1\0\1\52" + 
                                             "\27\0\1\53\44\0\1\54\11\0\1\55\3\0\1\56" + 
                                             "\13\0\1\57\34\0\1\60\10\0\1\61\45\0\1\62" + 
                                             "\65\0\1\63\52\0\1\64\1\65\40\0\1\66\52\0" + 
                                             "\1\67\30\0\1\70\2\0\1\71\1\72\2\0\1\73" + 
                                             "\1\74\1\75\3\0\1\76\1\0\1\77\2\0\1\100" + 
                                             "\40\0\1\101\22\0\1\7\3\0\1\44\27\0\1\45" + 
                                             "\2\0\12\45\1\102\30\45\6\46\1\103\37\46\1\104" + 
                                             "\2\0\1\104\1\0\2\104\2\0\4\104\1\0\30\104" + 
                                             "\23\0\1\105\57\0\1\106\42\0\1\107\10\0\1\110" + 
                                             "\27\0\1\111\63\0\1\112\11\0\1\113\45\0\1\114" + 
                                             "\72\0\1\115\40\0\1\116\6\0\1\117\37\0\1\120" + 
                                             "\40\0\1\121\63\0\1\122\25\0\1\123\64\0\1\124" + 
                                             "\1\0\1\125\27\0\1\126\44\0\1\127\11\0\1\130" + 
                                             "\3\0\1\131\13\0\1\132\34\0\1\133\10\0\1\134" + 
                                             "\45\0\1\135\65\0\1\136\52\0\1\137\1\140\40\0" + 
                                             "\1\141\35\0\1\142\25\0\6\46\1\143\37\46\1\104" + 
                                             "\2\0\1\104\1\144\2\104\2\0\4\104\1\0\30\104" + 
                                             "\33\0\1\145\36\0\1\146\30\0\1\147\45\0\1\150" + 
                                             "\10\0\1\151\26\0\3\152\3\0\1\153\103\0\1\154" + 
                                             "\35\0\1\155\34\0\1\156\30\0\1\157\71\0\1\160" + 
                                             "\45\0\1\161\46\0\1\162\20\0\1\163\73\0\1\164" + 
                                             "\42\0\1\165\10\0\1\166\27\0\1\167\63\0\1\170" + 
                                             "\11\0\1\171\45\0\1\172\72\0\1\173\40\0\1\174" + 
                                             "\6\0\1\175\37\0\1\176\40\0\1\177\63\0\1\200" + 
                                             "\33\0\1\201\16\0\6\46\1\143\1\5\36\46\21\0" + 
                                             "\1\202\60\0\1\203\20\0\1\204\100\0\1\205\4\0" + 
                                             "\3\152\7\0\1\206\3\0\2\206\2\0\3\206\1\0" + 
                                             "\17\206\34\0\1\207\20\0\1\210\45\0\1\211\72\0" + 
                                             "\1\212\20\0\1\213\73\0\1\214\34\0\1\215\30\0" + 
                                             "\1\216\45\0\1\217\10\0\1\220\34\0\1\221\103\0" + 
                                             "\1\222\35\0\1\223\34\0\1\224\30\0\1\225\71\0" + 
                                             "\1\226\45\0\1\227\46\0\1\230\46\0\1\231\27\0" + 
                                             "\1\232\47\0\1\233\56\0\1\234\14\0\3\235\7\0" + 
                                             "\1\206\2\0\3\206\2\0\3\206\1\236\17\206\7\0" + 
                                             "\1\237\77\0\1\240\13\0\1\241\17\0\1\242\25\0" + 
                                             "\1\243\100\0\1\244\37\0\1\245\20\0\1\246\45\0" + 
                                             "\1\247\72\0\1\250\20\0\1\251\73\0\1\252\31\0" + 
                                             "\1\253\44\0\1\254\34\0\1\255\45\0\1\256\37\0" + 
                                             "\3\235\22\0\1\236\34\0\1\257\74\0\1\260\33\0" + 
                                             "\1\261\22\0\1\262\77\0\1\263\13\0\1\264\17\0" + 
                                             "\1\265\25\0\1\266\45\0\1\267\36\0\1\257\2\0" + 
                                             "\12\257\1\111\30\257\34\0\1\270\20\0\1\271\45\0" + 
                                             "\1\272\102\0\1\273\36\0\1\274\44\0\1\275\20\0" + 
                                             "\1\276\73\0\1\277\17\0\1\300\36\0";

    /**
     * The transition table of the DFA
     */
    final private static int[] yytrans = yy_unpack();

    /* error codes */
    final private static int YY_UNKNOWN_ERROR = 0;
    final private static int YY_ILLEGAL_STATE = 1;
    final private static int YY_NO_MATCH = 2;
    final private static int YY_PUSHBACK_2BIG = 3;

    /* error messages for the codes above */
    final private static String[] YY_ERROR_MSG = {
        "Unkown internal scanner error", "Internal error: unknown state", 
        "Error: could not match input", "Error: pushback value was too large"
    };

    /**
     * YY_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
     */
    private final static byte[] YY_ATTRIBUTE = {
        0, 0, 9, 1, 9, 1, 9, 9, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 
        9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 
        0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 9, 9, 0, 0, 0, 
        0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 9, 0, 0, 0, 9, 0, 0, 0, 9, 0, 0, 0, 0, 0, 
        9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 9, 9, 0, 9, 0, 0, 9, 9, 0, 
        9, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 9, 0, 0, 9, 9, 0, 
        9, 0, 0, 0, 9, 9, 0, 0, 0, 9, 0, 9, 0, 9, 9, 0, 9, 9, 0, 0, 0, 9, 0, 9
    };

    /** the input device */
    private java.io.Reader yy_reader;

    /** the current state of the DFA */
    private int yy_state;

    /** the current lexical state */
    private int yy_lexical_state = YYINITIAL;

    /** this buffer contains the current text to be matched and is
        the source of the yytext() string */
    private char[] yy_buffer = new char[YY_BUFFERSIZE];

    /** the textposition at the last accepting state */
    private int yy_markedPos;

    /** the textposition at the last state to be included in yytext */
    private int yy_pushbackPos;

    /** the current text position in the buffer */
    private int yy_currentPos;

    /** startRead marks the beginning of the yytext() string in the buffer */
    private int yy_startRead;

    /** endRead marks the last character in the buffer, that has been read
        from input */
    private int yy_endRead;

    /** number of newlines encountered up to the start of the matched text */
    private int yyline;

    /** the number of characters up to the start of the matched text */
    private int yychar;

    /**
     * the number of characters from the last newline up to the start of the
     * matched text
     */
    private int yycolumn;

    /**
     * yy_atBOL == true <=> the scanner is currently at the beginning of a line
     */
    private boolean yy_atBOL = true;

    /** yy_atEOF == true <=> the scanner is at the EOF */
    private boolean yy_atEOF;

    /** denotes if the user-EOF-code has already been executed */
    private boolean yy_eof_done;

    /* user code: */
    StringBuffer string = new StringBuffer();

    /**
     * Creates a new scanner
     * There is also a java.io.InputStream version of this constructor.
     *
     * @param   in  the java.io.Reader to read input from.
     */
    public Scanner(java.io.Reader in) {
        this.yy_reader = in;
    }

    /**
     * Creates a new scanner.
     * There is also java.io.Reader version of this constructor.
     *
     * @param   in  the java.io.Inputstream to read input from.
     */
    public Scanner(java.io.InputStream in) {
        this(new java.io.InputStreamReader(in));
    }

    private Symbol symbol(int type) {
        return new Symbol(type, yyline, yycolumn);
    }

    private Symbol symbol(int type, Object value) {
        return new Symbol(type, yyline, yycolumn, value);
    }

    /**
     * Unpacks the split, compressed DFA transition table.
     *
     * @return the unpacked transition table
     */
    private static int[] yy_unpack() {
        int[] trans = new int[5548];
        int offset = 0;
        offset = yy_unpack(yy_packed0, offset, trans);

        return trans;
    }

    /**
     * Unpacks the compressed DFA transition table.
     *
     * @param packed   the packed transition table
     * @return         the index of the last entry
     */
    private static int yy_unpack(String packed, int offset, int[] trans) {
        int i = 0;/* index in packed string  */
        int j = offset;/* index in unpacked array */
        int l = packed.length();

        while (i < l) {
            int count = packed.charAt(i++);
            int value = packed.charAt(i++);
            value--;

            do
                trans[j++] = value;
            while ((--count) > 0);
        }

        return j;
    }

    /**
     * Unpacks the compressed character translation table.
     *
     * @param packed   the packed character translation table
     * @return         the unpacked character translation table
     */
    private static char[] yy_unpack_cmap(String packed) {
        char[] map = new char[0x10000];
        int i = 0;/* index in packed string  */
        int j = 0;/* index in unpacked array */

        while (i < 136) {
            int count = packed.charAt(i++);
            char value = packed.charAt(i++);

            do
                map[j++] = value;
            while ((--count) > 0);
        }

        return map;
    }

    /**
     * Refills the input buffer.
     *
     * @return      <code>false</code>, iff there was new input.
     *
     * @exception   java.io.IOException  if any I/O-Error occurs
     */
    private boolean yy_refill() throws java.io.IOException {
        /* first: make room (if you can) */
        if (yy_startRead > 0) {
            System.arraycopy(yy_buffer, yy_startRead, yy_buffer, 0, 
                             yy_endRead - yy_startRead);


            /* translate stored positions */
            yy_endRead -= yy_startRead;
            yy_currentPos -= yy_startRead;
            yy_markedPos -= yy_startRead;
            yy_pushbackPos -= yy_startRead;
            yy_startRead = 0;
        }

        /* is the buffer big enough? */
        if (yy_currentPos >= yy_buffer.length) {
            /* if not: blow it up */
            char[] newBuffer = new char[yy_currentPos * 2];
            System.arraycopy(yy_buffer, 0, newBuffer, 0, yy_buffer.length);
            yy_buffer = newBuffer;
        }

        /* finally: fill the buffer with new input */
        int numRead = yy_reader.read(yy_buffer, yy_endRead, 
                                     yy_buffer.length - yy_endRead);

        if (numRead < 0) {
            return true;
        } else {
            yy_endRead += numRead;

            return false;
        }
    }

    /**
     * Closes the input stream.
     */
    final public void yyclose() throws java.io.IOException {
        yy_atEOF = true;/* indicate end of file */
        yy_endRead = yy_startRead;/* invalidate buffer    */

        if (yy_reader != null) {
            yy_reader.close();
        }
    }

    /**
     * Closes the current stream, and resets the
     * scanner to read from a new input stream.
     *
     * All internal variables are reset, the old input stream
     * <b>cannot</b> be reused (internal buffer is discarded and lost).
     * Lexical state is set to <tt>YY_INITIAL</tt>.
     *
     * @param reader   the new input stream
     */
    final public void yyreset(java.io.Reader reader) throws java.io.IOException {
        yyclose();
        yy_reader = reader;
        yy_atBOL = true;
        yy_atEOF = false;
        yy_endRead = yy_startRead = 0;
        yy_currentPos = yy_markedPos = yy_pushbackPos = 0;
        yyline = yychar = yycolumn = 0;
        yy_lexical_state = YYINITIAL;
    }

    /**
     * Returns the current lexical state.
     */
    final public int yystate() {
        return yy_lexical_state;
    }

    /**
     * Enters a new lexical state
     *
     * @param newState the new lexical state
     */
    final public void yybegin(int newState) {
        yy_lexical_state = newState;
    }

    /**
     * Returns the text matched by the current regular expression.
     */
    final public String yytext() {
        return new String(yy_buffer, yy_startRead, yy_markedPos - 
                          yy_startRead);
    }

    /**
     * Returns the character at position <tt>pos</tt> from the
     * matched text.
     *
     * It is equivalent to yytext().charAt(pos), but faster
     *
     * @param pos the position of the character to fetch.
     *            A value from 0 to yylength()-1.
     *
     * @return the character at position pos
     */
    final public char yycharat(int pos) {
        return yy_buffer[yy_startRead + pos];
    }

    /**
     * Returns the length of the matched text region.
     */
    final public int yylength() {
        return yy_markedPos - yy_startRead;
    }

    /**
     * Reports an error that occured while scanning.
     *
     * In a wellformed scanner (no or only correct usage of
     * yypushback(int) and a match-all fallback rule) this method
     * will only be called with things that "Can't Possibly Happen".
     * If this method is called, something is seriously wrong
     * (e.g. a JFlex bug producing a faulty scanner etc.).
     *
     * Usual syntax/scanner level error handling should be done
     * in error fallback rules.
     *
     * @param   errorCode  the code of the errormessage to display
     */
    private void yy_ScanError(int errorCode) {
        String message;

        try {
            message = YY_ERROR_MSG[errorCode];
        } catch (ArrayIndexOutOfBoundsException e) {
            message = YY_ERROR_MSG[YY_UNKNOWN_ERROR];
        }

        throw new Error(message);
    }

    /**
     * Pushes the specified amount of characters back into the input stream.
     *
     * They will be read again by then next call of the scanning method
     *
     * @param number  the number of characters to be read again.
     *                This number must not be greater than yylength()!
     */
    private void yypushback(int number) {
        if (number > yylength()) {
            yy_ScanError(YY_PUSHBACK_2BIG);
        }

        yy_markedPos -= number;
    }

    /**
     * Contains user EOF-code, which will be executed exactly once,
     * when the end of file is reached
     */
    private void yy_do_eof() throws java.io.IOException {
        if (!yy_eof_done) {
            yy_eof_done = true;
            yyclose();
        }
    }

    /**
     * Resumes scanning until the next regular expression is matched,
     * the end of input is encountered or an I/O-Error occurs.
     *
     * @return      the next token
     * @exception   java.io.IOException  if any I/O-Error occurs
     */
    public org.openuss.openformula.mathml.in.java_cup.runtime.Symbol next_token()
        throws java.io.IOException {
        int yy_input;
        int yy_action;

        // cached fields:
        int yy_currentPos_l;
        int yy_startRead_l;
        int yy_markedPos_l;
        int yy_endRead_l = yy_endRead;
        char[] yy_buffer_l = yy_buffer;
        char[] yycmap_l = yycmap;

        int[] yytrans_l = yytrans;
        int[] yy_rowMap_l = yy_rowMap;
        byte[] yy_attr_l = YY_ATTRIBUTE;

        while (true) {
            yy_markedPos_l = yy_markedPos;

            boolean yy_r = false;

            for (yy_currentPos_l = yy_startRead;
                 yy_currentPos_l < yy_markedPos_l;
                 yy_currentPos_l++) {
                switch (yy_buffer_l[yy_currentPos_l]) {
                case '\u000B':
                case '\u000C':
                case '\u0085':
                case '\u2028':
                case '\u2029':
                    yyline++;
                    yycolumn = 0;
                    yy_r = false;

                    break;

                case '\r':
                    yyline++;
                    yycolumn = 0;
                    yy_r = true;

                    break;

                case '\n':

                    if (yy_r) {
                        yy_r = false;
                    } else {
                        yyline++;
                        yycolumn = 0;
                    }

                    break;

                default:
                    yy_r = false;
                    yycolumn++;
                }
            }

            if (yy_r) {
                // peek one character ahead if it is \n (if we have counted one line too much)
                boolean yy_peek;

                if (yy_markedPos_l < yy_endRead_l) {
                    yy_peek = yy_buffer_l[yy_markedPos_l] == '\n';
                } else if (yy_atEOF) {
                    yy_peek = false;
                } else {
                    boolean eof = yy_refill();
                    yy_markedPos_l = yy_markedPos;
                    yy_buffer_l = yy_buffer;

                    if (eof) {
                        yy_peek = false;
                    } else {
                        yy_peek = yy_buffer_l[yy_markedPos_l] == '\n';
                    }
                }

                if (yy_peek) {
                    yyline--;
                }
            }

            yy_action = -1;

            yy_startRead_l = yy_currentPos_l = yy_currentPos = yy_startRead = yy_markedPos_l;

            yy_state = yy_lexical_state;

yy_forAction:  {
                while (true) {
                    if (yy_currentPos_l < yy_endRead_l) {
                        yy_input = yy_buffer_l[yy_currentPos_l++];
                    } else if (yy_atEOF) {
                        yy_input = YYEOF;

                        break yy_forAction;
                    } else {
                        // store back cached positions
                        yy_currentPos = yy_currentPos_l;
                        yy_markedPos = yy_markedPos_l;

                        boolean eof = yy_refill();


                        // get translated positions and possibly new buffer
                        yy_currentPos_l = yy_currentPos;
                        yy_markedPos_l = yy_markedPos;
                        yy_buffer_l = yy_buffer;
                        yy_endRead_l = yy_endRead;

                        if (eof) {
                            yy_input = YYEOF;

                            break yy_forAction;
                        } else {
                            yy_input = yy_buffer_l[yy_currentPos_l++];
                        }
                    }

                    int yy_next = yytrans_l[yy_rowMap_l[yy_state] + 
                                  yycmap_l[yy_input]];

                    if (yy_next == -1) {
                        break yy_forAction;
                    }

                    yy_state = yy_next;

                    int yy_attributes = yy_attr_l[yy_state];

                    if ((yy_attributes & 1) == 1) {
                        yy_action = yy_state;
                        yy_markedPos_l = yy_currentPos_l;

                        if ((yy_attributes & 8) == 8) {
                            break yy_forAction;
                        }
                    }
                }
            }


            // store back cached position
            yy_markedPos = yy_markedPos_l;

            switch (yy_action) {
            case 65:
                return symbol(APARAMETER, new String(yytext()));

            case 193:
                break;

            case 185:
                return symbol(FENCE_CLOSE);

            case 194:
                break;

            case 48:
                return symbol(NUMBER_OPEN);

            case 195:
                break;

            case 159:
                return symbol(FENCE_OPEN);

            case 196:
                break;

            case 166:
                return symbol(ROOT_CLOSE);

            case 197:
                break;

            case 2:
            case 5:
            case 8:
                throw new RuntimeException("Illegal character \"" + yytext() + 
                                           "\" at line " + yyline + 
                                           ", column " + yycolumn);

            case 198:
                break;

            case 182:
                return symbol(ENCLOSED_STRING, 
                              new String(yytext()
                                             .substring(4, 
                                                        yytext().length() - 5)));

            case 199:
                break;

            case 181:
                return symbol(CURSOR);

            case 200:
                break;

            case 3:
            case 4:
            {/* ignore */
            }

            case 201:
                break;

            case 7:
                return symbol(GT);

            case 202:
                break;

            case 114:
                return symbol(MBR);

            case 203:
                break;

            case 110:
                return symbol(ROW_OPEN);

            case 204:
                break;

            case 136:
                return symbol(ROOT_OPEN);

            case 205:
                break;

            case 148:
                return symbol(ROW_CLOSE);

            case 206:
                break;

            case 135:
                return symbol(OVERSCRIPT_OPEN);

            case 207:
                break;

            case 184:
                return symbol(SUBSUPERSCRIPT_CLOSE);

            case 208:
                break;

            case 103:
                return symbol(SUBSCRIPT_OPEN);

            case 209:
                break;

            case 142:
                return symbol(SUBSCRIPT_CLOSE);

            case 210:
                break;

            case 162:
                return symbol(SQUAREROOT_CLOSE);

            case 211:
                break;

            case 144:
                return symbol(MATHHEADER_CLOSE);

            case 212:
                break;

            case 173:
                return symbol(SUBSUPERSCRIPT_OPEN);

            case 213:
                break;

            case 191:
                return symbol(UNDEROVERSCRIPT_CLOSE);

            case 214:
                break;

            case 189:
                return symbol(UNDEROVERSCRIPT_OPEN);

            case 215:
                break;

            case 168:
                return symbol(FRACTION_CLOSE);

            case 216:
                break;

            case 75:
                return symbol(MATRIXELEMENT_OPEN);

            case 217:
                break;

            case 6:
            case 9:
            case 11:
                return symbol(UNICODECHAR, new String(yytext()));

            case 218:
                break;

            case 121:
                return symbol(MATRIXELEMENT_CLOSE);

            case 219:
                break;

            case 131:
                return symbol(SQUAREROOT_OPEN);

            case 220:
                break;

            case 172:
                return symbol(SPACE_OPENCLOSE);

            case 221:
                break;

            case 102:
                return symbol(SUPERSCRIPT_OPEN);

            case 222:
                break;

            case 89:
                return symbol(OPERATOR_CLOSE);

            case 223:
                break;

            case 141:
                return symbol(SUPERSCRIPT_CLOSE);

            case 224:
                break;

            case 46:
                return symbol(OPERATOR_OPEN);

            case 225:
                break;

            case 91:
                return symbol(NUMBER_CLOSE);

            case 226:
                break;

            case 177:
                return symbol(TABLEORMATRIX_CLOSE);

            case 227:
                break;

            case 158:
                return symbol(TABLEORMATRIX_OPEN);

            case 228:
                break;

            case 10:
            case 21:
                return symbol(FLOATING_POINT_LITERAL, new String(yytext()));

            case 229:
                break;

            case 138:
                return symbol(FRACTION_OPEN);

            case 230:
                break;

            case 92:
                return symbol(IDENTIFIER_CLOSE);

            case 231:
                break;

            case 165:
                return symbol(OVERSCRIPT_CLOSE);

            case 232:
                break;

            case 179:
                return symbol(UNDERSCRIPT_CLOSE);

            case 233:
                break;

            case 49:
                return symbol(IDENTIFIER_OPEN);

            case 234:
                break;

            case 160:
                return symbol(UNDERSCRIPT_OPEN);

            case 235:
                break;

            case 106:
                return symbol(MATHHEADER_OPEN);

            case 236:
                break;

            case 74:
                return symbol(MATRIXROW_OPEN);

            case 237:
                break;

            case 120:
                return symbol(MATRIXROW_CLOSE);

            case 238:
                break;

            default:

                if ((yy_input == YYEOF) && (yy_startRead == yy_currentPos)) {
                    yy_atEOF = true;
                    yy_do_eof();

                    return symbol(EOF);
                } else {
                    yy_ScanError(YY_NO_MATCH);
                }
            }
        }
    }
}