package org.openuss.commands;

import java.util.Collection;
import java.util.Date;

import org.apache.commons.lang.Validate;
import org.apache.log4j.Logger;
import org.openuss.foundation.DefaultDomainObject;
import org.openuss.system.SystemService;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

/**
 * Cluster Comand Processor
 * 
 * This processor executes to types of commands node and cluster.
 * 
 * <p>
 * <b>Node commands</b> will be executed on each server node within the cluster,
 * like the index updates or some cleanup services. For performance reasons each node 
 * must know with jobs are already done. Therefore the last processed command id is stored 
 * with the current system id. So each server node can find out which commands must be executed next.
 * </p>
 * <p>
 * <i>According to the autogenerated system identity system startups with a hugh command stack in the database
 * will be extremly slow, because the processor will start at the beginning.</i>
 * </p>
 * 
 * @author Ingo Dueppe
 */
public class ClusterCommandProcessor implements ApplicationContextAware {

	/** Logger **/ 
	private static final Logger logger = Logger.getLogger(ClusterCommandProcessor.class);

	/** Spring Application Context **/
	private ApplicationContext applicationContext;

	/** Command Data Access Object **/
	private CommandDao commandDao;

	/** Last Processed Command Data Access Object **/
	private LastProcessedCommandDao lastProcessedCommandDao;

	/** System Service **/
	private SystemService systemService;

	/**
	 * process all pending node commands
	 */
	public void processNodeCommands() {
		logger.debug("starting processing node commands");
		Collection<Command> commands = loadNextNodeCommands();
		for (Command command : commands) {
			processNodeCommand(command);
			updateLastProcessedCommand(command);
		}
		logger.debug("finished processing node commands");
	}
	
	/**
	 * process command by a given command id
	 * @param commandId - must not be null
	 */
	public void processCommand(Long commandId) {
		Validate.notNull(commandId, "Parameter commandId must not be null.");
		logger.info("starting processing command with id "+commandId);
		Command command = commandDao.load(commandId);
		if (command != null && command.getState() == CommandState.ONCE) {
			try {
				createCommand(command).execute();
				command.setState(CommandState.DONE);
			} catch (Throwable th) {
				logExecutionError(command, th);
				command.setState(CommandState.ERROR);
			} finally {
				command.setExecutionTime(new Date());
				commandDao.update(command);
			}
		}
		logger.info("finished processing command with id "+commandId);
	}

	/**
	 * Create a domain command and executes it.
	 * @param command - object reference to a command
	 */
	private void processNodeCommand(Command command) {
		try {
			createCommand(command).execute();
		} catch (Throwable th) {
			logExecutionError(command, th);
			command.setState(CommandState.ERROR);
			commandDao.update(command);
		}
	}

	/**
	 * Updates the last processed node command. Last processed node commands will be stored with the 
	 * current system indentity. 
	 * @param command
	 */
	private void updateLastProcessedCommand(Command command) {
		LastProcessedCommand last = lastProcessedCommandDao.load(systemService.getInstanceIdentity());
		if (last == null || last.getId() == null) {
			last = new LastProcessedCommandImpl();
			last.setId(systemService.getInstanceIdentity());
			last.setLast(command);
			lastProcessedCommandDao.create(last);
		} else {
			last.setLast(command);
			lastProcessedCommandDao.update(last);
		}
	}

	private void logExecutionError(Command command, Throwable th) {
		StringBuilder msg = new StringBuilder();
		msg.append("\nCommand throw exception on execution:");
		msg.append("\n\t id = "+command.getId());
		msg.append("\n\t DomainIdentifier = "+command.getDomainIdentifier());
		msg.append("\n\t Command = "+command.getCommand());
		msg.append("\n\t CommandType = "+command.getCommandType());
		msg.append("\n\t StartTime = "+command.getStartTime());
		msg.append("\n\t ExecutionTime = "+command.getExecutionTime());
		msg.append("\n\t State = "+command.getState());
		
		logger.error(msg.toString(), th);
	}

	/**
	 * Load all commands that are newer than the last processed one.
	 * @return Collection<Command> 
	 */
	@SuppressWarnings("unchecked")
	private Collection<Command> loadNextNodeCommands() {
		LastProcessedCommand last = lastProcessedCommandDao.load(systemService.getInstanceIdentity());

		if (last == null || last.getLast() == null) {
			return commandDao.findAllEachCommandsAfter(0L);
		} else {
			return commandDao.findAllEachCommandsAfter(last.getLast().getId());
		}
	}
	
	/**
	 * Create domain command object bei Command
	 * @param command
	 * @return DomainCommand instance
	 */
	private DomainCommand createCommand(Command command) {
		DomainCommand domainCommand = (DomainCommand) applicationContext.getBean(command.getCommand());
		domainCommand.setDomainObject(new DefaultDomainObject(command.getDomainIdentifier()));
		domainCommand.setStartTime(command.getStartTime());
		domainCommand.setCommandType(command.getCommandType());
		return domainCommand;
	}

	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		this.applicationContext = applicationContext;
	}

	public CommandDao getCommandDao() {
		return commandDao;
	}

	public void setCommandDao(CommandDao commandDao) {
		this.commandDao = commandDao;
	}

	public LastProcessedCommandDao getLastProcessedCommandDao() {
		return lastProcessedCommandDao;
	}

	public void setLastProcessedCommandDao(LastProcessedCommandDao lastProcessedCommandDao) {
		this.lastProcessedCommandDao = lastProcessedCommandDao;
	}

	public SystemService getSystemService() {
		return systemService;
	}

	public void setSystemService(SystemService systemService) {
		this.systemService = systemService;
	}

}
