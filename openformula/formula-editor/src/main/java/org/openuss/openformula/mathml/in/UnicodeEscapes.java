/**
 * Title:        OpenUSS - Open Source University Support System
 * Description:  OpenFormula
 * Copyright:    Copyright (c) OpenUSS
 * Company:      University of Muenster
 * @author  Jan Kirchhoff
 * @version 1.0
 */
package org.openuss.openformula.mathml.in;

/* The following code was generated by JFlex 1.3.5 on 11.10.03 17:02 */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Copyright (C) 1998-2001 Gerwin Klein <lsf@jflex.de>                     *
 * All rights reserved.                                                    *
 *                                                                         *
 * This program is free software; you can redistribute it and/or modify    *
 * it under the terms of the GNU General Public License. See the file      *
 * COPYRIGHT for more information.                                         *
 *                                                                         *
 * This program is distributed in the hope that it will be useful,         *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
 * GNU General Public License for more details.                            *
 *                                                                         *
 * You should have received a copy of the GNU General Public License along *
 * with this program; if not, write to the Free Software Foundation, Inc., *
 * 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA                 *
 *                                                                         *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* 3.3 of the Java Language Specification :

UnicodeInputCharacter:

             UnicodeEscape

             RawInputCharacter

     UnicodeEscape:

             \ UnicodeMarker HexDigit HexDigit HexDigit HexDigit

     UnicodeMarker:

             u

             UnicodeMarker u

     RawInputCharacter:

             any Unicode character

     HexDigit: one of

             0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F

only an even number of '\' is eligible to start a Unicode escape sequence

*/
import java.io.FilterReader;
import java.io.IOException;


/**
 * This class is a scanner generated by
 * <a href="http://www.jflex.de/">JFlex</a> 1.3.5
 * on 11.10.03 17:02 from the specification file
 * <tt>file:/C:/Formualrix/Source/Formelobjekte/MathMLImport/unicode.flex</tt>
 */
public final class UnicodeEscapes extends FilterReader {
    /** This character denotes the end of file */
    private final static int YYEOF = -1;

    /** initial size of the lookahead buffer */
    final private static int YY_BUFFERSIZE = 16384;

    /** lexical states */
    private final static int DIGITS = 1;
    private final static int YYINITIAL = 0;

    /**
     * Translates characters to character classes
     */
    final private static String yycmap_packed = 
        "\12\0\1\0\45\0\12\2\7\0\6\2\25\0\1\3\4\0\6\2" + "\16\0\1\1\uff8a\0";

    /**
     * Translates characters to character classes
     */
    final private static char[] yycmap = yy_unpack_cmap(yycmap_packed);

    /* error codes */
    final private static int YY_UNKNOWN_ERROR = 0;
    final private static int YY_ILLEGAL_STATE = 1;
    final private static int YY_NO_MATCH = 2;
    final private static int YY_PUSHBACK_2BIG = 3;

    /* error messages for the codes above */
    final private static String[] YY_ERROR_MSG = {
        "Unkown internal scanner error", "Internal error: unknown state", 
        "Error: could not match input", "Error: pushback value was too large"
    };

    /** the input device */
    private java.io.Reader yy_reader;

    /** the current state of the DFA */
    private int yy_state;

    /** the current lexical state */
    private int yy_lexical_state = YYINITIAL;

    /** this buffer contains the current text to be matched and is
     the source of the yytext() string */
    private char[] yy_buffer = new char[YY_BUFFERSIZE];

    /** the textposition at the last accepting state */
    private int yy_markedPos;

    /** the textposition at the last state to be included in yytext */
    private int yy_pushbackPos;

    /** the current text position in the buffer */
    private int yy_currentPos;

    /** startRead marks the beginning of the yytext() string in the buffer */
    private int yy_startRead;

    /** endRead marks the last character in the buffer, that has been read
     from input */
    private int yy_endRead;

    /** number of newlines encountered up to the start of the matched text */
    private int yyline;

    /** the number of characters up to the start of the matched text */
    private int yychar;

    /**
     * the number of characters from the last newline up to the start of the
     * matched text
     */
    private int yycolumn;

    /**
     * yy_atBOL == true <=> the scanner is currently at the beginning of a line
     */
    private boolean yy_atBOL = true;

    /** yy_atEOF == true <=> the scanner is at the EOF */
    private boolean yy_atEOF;

    /* user code: */
    private boolean even;

    /**
     * Creates a new scanner
     * There is also a java.io.InputStream version of this constructor.
     *
     * @param   in  the java.io.Reader to read input from.
     */
    public UnicodeEscapes(final java.io.Reader in) {
        super(in);
        this.yy_reader = in;
    }

    /**
     * Creates a new scanner.
     * There is also java.io.Reader version of this constructor.
     *
     * @param   in  the java.io.Inputstream to read input from.
     */
    public UnicodeEscapes(final java.io.InputStream in) {
        this(new java.io.InputStreamReader(in));
    }

    private int value() {
        int r = 0;

        for (int k = yy_markedPos - 4; k < yy_markedPos; k++) {
            int c = yy_buffer[k];

            if (c >= 'a') {
                c -= ('a' - 10);
            } else if (c >= 'A') {
                c -= ('A' - 10);
            } else {
                c -= '0';
            }

            r <<= 4;
            r += c;
        }

        return r;
    }

    public int read(final char[] cbuf, final int off, int len)
             throws IOException {
        if (!ready()) {
            return -1;
        }

        len += off;

        for (int i = off; i < len; i++) {
            final int c = read();

            if (c < 0) {
                return i - off;
            } else {
                cbuf[i] = (char) c;
            }
        }

        return len - off;
    }

    public boolean markSupported() {
        return false;
    }

    public boolean ready() throws IOException {
        return !yy_atEOF && 
               (yy_currentPos < yy_endRead || yy_reader.ready());
    }

    /**
     * Unpacks the compressed character translation table.
     *
     * @param packed   the packed character translation table
     * @return         the unpacked character translation table
     */
    private static char[] yy_unpack_cmap(final String packed) {
        final char[] map = new char[0x10000];
        int i = 0;/* index in packed string  */
        int j = 0;/* index in unpacked array */

        while (i < 26) {
            int count = packed.charAt(i++);
            final char value = packed.charAt(i++);

            do
                map[j++] = value;
            while ((--count) > 0);
        }

        return map;
    }

    /**
     * Refills the input buffer.
     *
     * @return      <code>false</code>, iff there was new input.
     *
     * @exception   java.io.IOException  if any I/O-Error occurs
     */
    private boolean yy_refill() throws java.io.IOException {
        /* first: make room (if you can) */
        if (yy_startRead > 0) {
            System.arraycopy(yy_buffer, yy_startRead, yy_buffer, 0, 
                             yy_endRead - yy_startRead);


            /* translate stored positions */
            yy_endRead -= yy_startRead;
            yy_currentPos -= yy_startRead;
            yy_markedPos -= yy_startRead;
            yy_pushbackPos -= yy_startRead;
            yy_startRead = 0;
        }

        /* is the buffer big enough? */
        if (yy_currentPos >= yy_buffer.length) {
            /* if not: blow it up */
            final char[] newBuffer = new char[yy_currentPos * 2];
            System.arraycopy(yy_buffer, 0, newBuffer, 0, yy_buffer.length);
            yy_buffer = newBuffer;
        }

        /* finally: fill the buffer with new input */
        final int numRead = yy_reader.read(yy_buffer, yy_endRead, 
                                           yy_buffer.length - yy_endRead);

        if (numRead < 0) {
            return true;
        } else {
            yy_endRead += numRead;

            return false;
        }
    }

    /**
     * Closes the input stream.
     */
    private void yyclose() throws java.io.IOException {
        yy_atEOF = true;/* indicate end of file */
        yy_endRead = yy_startRead;/* invalidate buffer    */

        if (yy_reader != null) {
            yy_reader.close();
        }
    }

    /**
     * Closes the current stream, and resets the
     * scanner to read from a new input stream.
     *
     * All internal variables are reset, the old input stream
     * <b>cannot</b> be reused (internal buffer is discarded and lost).
     * Lexical state is set to <tt>YY_INITIAL</tt>.
     *
     * @param reader   the new input stream
     */
    final public void yyreset(final java.io.Reader reader)
                       throws java.io.IOException {
        yyclose();
        yy_reader = reader;
        yy_atBOL = true;
        yy_atEOF = false;
        yy_endRead = yy_startRead = 0;
        yy_currentPos = yy_markedPos = yy_pushbackPos = 0;
        yyline = yychar = yycolumn = 0;
        yy_lexical_state = YYINITIAL;
    }

    /**
     * Returns the current lexical state.
     */
    final public int yystate() {
        return yy_lexical_state;
    }

    /**
     * Enters a new lexical state
     *
     * @param newState the new lexical state
     */
    private void yybegin(final int newState) {
        yy_lexical_state = newState;
    }

    /**
     * Returns the text matched by the current regular expression.
     */
    final public String yytext() {
        return new String(yy_buffer, yy_startRead, yy_markedPos - 
                          yy_startRead);
    }

    /**
     * Returns the character at position <tt>pos</tt> from the
     * matched text.
     *
     * It is equivalent to yytext().charAt(pos), but faster
     *
     * @param pos the position of the character to fetch.
     *            A value from 0 to yylength()-1.
     *
     * @return the character at position pos
     */
    final public char yycharat(final int pos) {
        return yy_buffer[yy_startRead + pos];
    }

    /**
     * Returns the length of the matched text region.
     */
    private int yylength() {
        return yy_markedPos - yy_startRead;
    }

    /**
     * Reports an error that occured while scanning.
     *
     * In a wellformed scanner (no or only correct usage of
     * yypushback(int) and a match-all fallback rule) this method
     * will only be called with things that "Can't Possibly Happen".
     * If this method is called, something is seriously wrong
     * (e.g. a JFlex bug producing a faulty scanner etc.).
     *
     * Usual syntax/scanner level error handling should be done
     * in error fallback rules.
     *
     * @param   errorCode  the code of the errormessage to display
     */
    private static void yy_ScanError(final int errorCode) {
        String message;

        try {
            message = YY_ERROR_MSG[errorCode];
        } catch (ArrayIndexOutOfBoundsException e) {
            message = YY_ERROR_MSG[YY_UNKNOWN_ERROR];
        }

        throw new Error(message);
    }

    /**
     * Pushes the specified amount of characters back into the input stream.
     *
     * They will be read again by then next call of the scanning method
     *
     * @param number  the number of characters to be read again.
     *                This number must not be greater than yylength()!
     */
    private void yypushback(final int number) {
        if (number > yylength()) {
            yy_ScanError(YY_PUSHBACK_2BIG);
        }

        yy_markedPos -= number;
    }

    /**
     * Resumes scanning until the next regular expression is matched,
     * the end of input is encountered or an I/O-Error occurs.
     *
     * @return      the next token
     * @exception   java.io.IOException  if any I/O-Error occurs
     */
    public int read() throws java.io.IOException {
        int yy_input;
        int yy_action;

        // cached fields:
        int yy_currentPos_l;
        int yy_startRead_l;
        int yy_markedPos_l;
        int yy_endRead_l = yy_endRead;
        char[] yy_buffer_l = yy_buffer;
        final char[] yycmap_l = yycmap;

        int yy_pushbackPos_l = yy_pushbackPos = -1;
        boolean yy_was_pushback;

        while (true) {
            yy_markedPos_l = yy_markedPos;

            yy_action = -1;

            yy_startRead_l = yy_currentPos_l = yy_currentPos = yy_startRead = yy_markedPos_l;

            yy_state = yy_lexical_state;

            yy_was_pushback = false;

yy_forAction:  {
                while (true) {
                    if (yy_currentPos_l < yy_endRead_l) {
                        yy_input = yy_buffer_l[yy_currentPos_l++];
                    } else if (yy_atEOF) {
                        yy_input = YYEOF;

                        break yy_forAction;
                    } else {
                        // store back cached positions
                        yy_currentPos = yy_currentPos_l;
                        yy_markedPos = yy_markedPos_l;
                        yy_pushbackPos = yy_pushbackPos_l;

                        final boolean eof = yy_refill();


                        // get translated positions and possibly new buffer
                        yy_currentPos_l = yy_currentPos;
                        yy_markedPos_l = yy_markedPos;
                        yy_buffer_l = yy_buffer;
                        yy_endRead_l = yy_endRead;
                        yy_pushbackPos_l = yy_pushbackPos;

                        if (eof) {
                            yy_input = YYEOF;

                            break yy_forAction;
                        } else {
                            yy_input = yy_buffer_l[yy_currentPos_l++];
                        }
                    }

                    yy_input = yycmap_l[yy_input];

                    boolean yy_pushback = false;
                    boolean yy_isFinal = false;
                    boolean yy_noLookAhead = false;

yy_forNext:          {
                        switch (yy_state) {
                        case 0:

                            switch (yy_input) {
                            case 3:
                                yy_isFinal = true;
                                yy_pushbackPos_l = yy_currentPos_l;
                                yy_state = 3;

                                break yy_forNext;

                            default:
                                yy_isFinal = true;
                                yy_noLookAhead = true;
                                yy_state = 2;

                                break yy_forNext;
                            }

                        case 1:

                            switch (yy_input) {
                            case 1:
                                yy_isFinal = true;
                                yy_state = 5;

                                break yy_forNext;

                            default:
                                yy_isFinal = true;
                                yy_noLookAhead = true;
                                yy_state = 4;

                                break yy_forNext;
                            }

                        case 3:

                            switch (yy_input) {
                            case 1:
                                yy_isFinal = true;
                                yy_pushback = true;
                                yy_noLookAhead = true;
                                yy_state = 6;

                                break yy_forNext;

                            case 3:
                                yy_isFinal = true;
                                yy_pushback = true;
                                yy_noLookAhead = true;
                                yy_state = 7;

                                break yy_forNext;

                            default:
                                break yy_forAction;
                            }

                        case 5:

                            switch (yy_input) {
                            case 1:
                                yy_state = 8;

                                break yy_forNext;

                            case 2:
                                yy_state = 9;

                                break yy_forNext;

                            default:
                                break yy_forAction;
                            }

                        case 8:

                            switch (yy_input) {
                            case 1:
                                yy_state = 8;

                                break yy_forNext;

                            case 2:
                                yy_state = 9;

                                break yy_forNext;

                            default:
                                break yy_forAction;
                            }

                        case 9:

                            switch (yy_input) {
                            case 2:
                                yy_state = 10;

                                break yy_forNext;

                            default:
                                break yy_forAction;
                            }

                        case 10:

                            switch (yy_input) {
                            case 2:
                                yy_state = 11;

                                break yy_forNext;

                            default:
                                break yy_forAction;
                            }

                        case 11:

                            switch (yy_input) {
                            case 2:
                                yy_isFinal = true;
                                yy_noLookAhead = true;
                                yy_state = 12;

                                break yy_forNext;

                            default:
                                break yy_forAction;
                            }

                        default:
                            yy_ScanError(YY_ILLEGAL_STATE);

                            break;
                        }
                    }

                    if (yy_isFinal) {
                        yy_was_pushback = yy_pushback;
                        yy_action = yy_state;
                        yy_markedPos_l = yy_currentPos_l;

                        if (yy_noLookAhead) {
                            break yy_forAction;
                        }
                    }
                }
            }


            // store back cached position
            yy_markedPos = yy_markedPos_l;

            if (yy_was_pushback) {
                yy_markedPos = yy_pushbackPos_l;
            }

            switch (yy_action) {
            case 7:
            {
                even = !even;

                return '\\';
            }

            case 14:
                break;

            case 6:
            {
                if (even) {
                    even = false;

                    return '\\';
                } else {
                    yybegin(DIGITS);
                }
            }

            case 15:
                break;

            case 3:
            {
                even = false;

                return '\\';
            }

            case 16:
                break;

            case 12:
            {
                yybegin(YYINITIAL);

                return value();
            }

            case 17:
                break;

            case 4:
            case 5:
                throw new Error("incorrect Unicode escape");

            case 18:
                break;

            case 2:
                return yy_buffer[yy_startRead];

            case 19:
                break;

            default:

                if ((yy_input == YYEOF) && (yy_startRead == yy_currentPos)) {
                    yy_atEOF = true;

                    switch (yy_lexical_state) {
                    case DIGITS:
                        throw new Error("EOF in Unicode escape");

                    case 14:
                        break;

                    case YYINITIAL:
                        return -1;

                    case 15:
                        break;

                    default:
                        return YYEOF;
                    }
                } else {
                    yy_ScanError(YY_NO_MATCH);
                }
            }
        }
    }
}